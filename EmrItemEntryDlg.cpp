// EmrItemEntryDlg.cpp : implementation file
//

#include "stdafx.h"
#include <NxPracticeSharedLib/RichEditUtils.h>
#include "AdministratorRc.h"
#include "EmrItemEntryDlg.h"
using namespace ADODB;
#include "EmrUtils.h"
#include "EmrCategoriesDlg.h"
#include "MultiSelectDlg.h"
#include "EmrActionDlg.h"
#include "EMRSelectProductDlg.h"
#include "EMRItemAdvPopupDlg.h"
#include "EMRTableDropdownEditorDlg.h"
#include "EMNDetail.h"
#include "DontShowDlg.h"
#include "EMRTopic.h"
#include "AuditTrail.h"
#include "SpellExUtils.h"
#include "EmrItemEntryDlgSpellCheckHandler.h"
#include "EMREMCodeCategorySetupDlg.h"
#include "EMRImageHotspotSetupDlg.h"
#include "MsgBox.h"
#include "EmrTableEditCalculatedFieldDlg.h"
#include "NxExpression.h"
#include "EmrTableInputMaskDlg.h"
#include "EditComboBox.h"
#include "WellnessDataUtils.h"
#include "EmrEditSentenceFormatDlg.h"
#include "EmrEditAutoNumberSettingsDlg.h"
#include "InvVisionWebUtils.h"
#include "EmrCommonListSetupDlg.h" // (c.haag 2011-03-14) - PLID 42814
#include "EmrTableAutofillSettingsDlg.h"
#include "FileUtils.h"
#include "EmrHotspotLocationDlg.h"
#include "EmrItemSelectStampsDlg.h"
#include "WoundCareCalculator.h" // (r.gonet 08/03/2012) - PLID 51735
#include "ClipboardToStringArray.h"
#include "DontShowDlg.h"
#include "EMRSelectMedicationsDlg.h"
#include "EMR.h"
#include "EMN.h"
#include "NxCache.h"
#include "EMREditTableCellCodeDlg.h"
#include "EMRCodeEditorDlg.h"
#include "NxAutoQuantum.h"

// (a.walling 2014-07-08 14:19) - PLID 62812 - Use MFCArray

// (a.walling 2011-08-11 16:43) - PLID 45021 - TableRow.m_pID is now TableRow.m_ID, which is not allocated on the heap.

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

// (j.gruber 2014-07-30 10:18) - PLID 62630 - Keyword colors
#define HAS_KEYWORD_OVERRIDE_COLOR  RGB(255,255,137)
#define HAS_NO_KEYWORD_OVERRIDE_COLOR   RGB(255,255,255)

// (j.gruber 2014-08-04 14:48) - PLID 62632 - check for a keyword override
#define KEYWORD_OVERRIDE_WARNING "This data has a custom keyword override setup.  Please review to confirm it is still accurate."

// (a.walling 2010-01-21 16:43) - PLID 37022 - Modified all auditing to take in a patient's internal ID when applicable, -1 if not.

//TES 10/28/2010 - PLID 41174 - Special logging to pin down the Current Medications corruption that happens very occasionally.
void Log_CurrentMedicationsEdit(CString strMessage) {
	//add date/time
	COleDateTime dt = COleDateTime::GetCurrentTime();
	CString strTime = dt.Format("%m/%d/%Y %H:%M:%S");

	strMessage = "(" + strTime + ") " + strMessage;

	//add a new line
	if(strMessage.Right(2) != "\r\n")
		strMessage += "\r\n";

	try {
		CFile file("LogCurrentMedicationsEdit.log", CFile::modeCreate|CFile::modeNoTruncate|CFile::modeWrite | CFile::shareCompat);
		file.SeekToEnd();
		file.Write(strMessage, strMessage.GetLength());
		file.Close();

	} catch(CFileException *e) {
		//No choice but to ignore these
		if (e)
			e->Delete();
	}
}


// (c.haag 2008-01-16 12:54) - PLID 17936 - Selections for individual cells of table dropdown
// columns are stored in EMRDetailTableDataT.Data (nvarchar(2000)) as a comma-delimited set of
// numbers that represent EMRTableDropdownInfoT.ID values.
//
// There are several places in this class that need to join EMRDetailTableDataT.Data to a
// specific ID. To do this, we use this utility macro to hide all the abstraction of the logic.
// 
#define TABLEDROPDOWN_JOIN_ON_ELEMENT(data_field, element_field) \
	FormatString("( (%s = %s) OR (%s LIKE '%%,' + %s + '') OR (%s LIKE '' + %s + ',%%') OR (%s LIKE '%%,' + %s + ',%%') )" \
	, data_field, element_field, data_field, element_field, data_field, element_field, data_field, element_field)

using namespace NXDATALISTLib;

// Some remote utilities (should be in globalutils or somewhere) but no time!
int FindDWordArrayElement(const CDWordArray &ary, DWORD dwFindValue);
CString GenerateXMLFromSemiColonDelimitedIDList(const CString &strSemiColonDelimitedIDList);

CString GenerateXMLFromActionArray(const MFCArray<EmrAction> &arActions)
{
	if (arActions.GetSize() > 0) {
		// Loop through all actions, adding a <P> record for each one, all surrounded by a <ROOT> tag pair
		CString strAns = "<ROOT>\r\n";
		for (long i=0; i<arActions.GetSize(); i++) {
			strAns += FormatString("<A ID=\"%li\" DestType=\"%li\" DestID=\"%li\" SortOrder=\"%li\" Popup=\"%i\" SpawnAsChild=\"%i\"/>\r\n", 
				arActions[i].nID, arActions[i].eaoDestType, arActions[i].nDestID, arActions[i].nSortOrder, arActions[i].bPopup?1:0, arActions[i].bSpawnAsChild?1:0);
		}
		strAns += "</ROOT>\r\n";
		// We've successfully generated the complete xml, pass it out to the variable that needs it
		return strAns;
	} else {
		return "";
	}
}

//(s.dhole 7/18/2014 1:46 PM ) - PLID 62597 to support Dignosis datlist 2
CString GenerateXMLFromDiagActionArray(const MFCArray<EmrAction> &arActions)
{
	if (arActions.GetSize() > 0) {
		// Loop through all actions, adding a <P> record for each one, all surrounded by a <ROOT> tag pair
		CString strAns = "<ROOT>\r\n";
		for (long i = 0; i < arActions.GetSize(); i++) {
			if (arActions[i].eaoDestType  == eaoDiagnosis){
				CString  n1 = (arActions[i].diaDiagnosis.nDiagCodeID_ICD9 == -1 ? "NULL" : AsString(arActions[i].diaDiagnosis.nDiagCodeID_ICD9)) ;
				CString n2 = (arActions[i].diaDiagnosis.nDiagCodeID_ICD10 == -1 ? "NULL" : AsString(arActions[i].diaDiagnosis.nDiagCodeID_ICD10));
				strAns += FormatString("<A EmrActionID=\"%li\" %s  %s  />\r\n",
					arActions[i].nID, (arActions[i].diaDiagnosis.nDiagCodeID_ICD9 == -1 ? "" : FormatString ("DiagCodeID_ICD9=\"%s\"", AsString(arActions[i].diaDiagnosis.nDiagCodeID_ICD9))),
					(arActions[i].diaDiagnosis.nDiagCodeID_ICD10 == -1 ? "" : FormatString("DiagCodeID_ICD10 = \"%s\"", AsString(arActions[i].diaDiagnosis.nDiagCodeID_ICD10))));
			}
		}
		strAns += "</ROOT>\r\n";
		// We've successfully generated the complete xml, pass it out to the variable that needs it
		return strAns;
	}
	else {
		return "";
	}
}

//DRT 1/10/2007 - PLID 24181 - This is copied from the GenerateXMLFromActionArray, but modified for the data that goes in 
//	EMRActionChargeDataT only.
CString GenerateChargeDataXMLFromActionArray(const MFCArray<EmrAction> &arActions)
{
	if (arActions.GetSize() > 0) {
		// Loop through all actions, adding a <P> record for each one, all surrounded by a <ROOT> tag pair
		CString strAns = "<ROOT>\r\n";
		for (long i=0; i<arActions.GetSize(); i++) {

			//Only add actions that are for the CPT desttype, those are the only ones saved in the chargedata table
			if(arActions.GetAt(i).eaoDestType == eaoCpt) {
				CString strMod1 = arActions[i].strMod1, 
						strMod2 = arActions[i].strMod2, 
						strMod3 = arActions[i].strMod3, 
						strMod4 = arActions[i].strMod4;

				//If the modifier is an empty string, we reference NULL in the table.  Do this in the XML saving by
				//	just leaving out the data field that should be NULL
				if(strMod1.IsEmpty()) {	strMod1 = "";	}	else {	strMod1.Format("Modifier1Number=\"%s\"", strMod1);	}
				if(strMod2.IsEmpty()) {	strMod2 = "";	}	else {	strMod2.Format("Modifier2Number=\"%s\"", strMod2);	}
				if(strMod3.IsEmpty()) {	strMod3 = "";	}	else {	strMod3.Format("Modifier3Number=\"%s\"", strMod3);	}
				if(strMod4.IsEmpty()) {	strMod4 = "";	}	else {	strMod4.Format("Modifier4Number=\"%s\"", strMod4);	}

				strAns += FormatString("<A ActionID=\"%li\" Prompt=\"%li\" DefaultQuantity=\"%g\" %s %s %s %s />\r\n", 
				arActions[i].nID, arActions[i].bPrompt ? 1 : 0, arActions[i].dblDefaultQuantity, strMod1, strMod2, strMod3, strMod4);
			}
		}
		strAns += "</ROOT>\r\n";
		// We've successfully generated the complete xml, pass it out to the variable that needs it
		return strAns;
	} else {
		return "";
	}
}

// (c.haag 2008-06-20 10:22) - PLID 30221 - This is copied from GenerateChargeDataXMLFromActionArray, but modiifed
// for data that goes in EMRActionsTodoDataT
CString GenerateTodoDataXMLFromActionArray(const MFCArray<EmrAction> &arActions)
{
	if (arActions.GetSize() > 0) {
		// Loop through all actions, adding an <A> record for each one, all surrounded by a <ROOT> tag pair
		CString strAns = "<ROOT>\r\n";
		for (long i=0; i<arActions.GetSize(); i++) {
			const EmrAction& ea = arActions.GetAt(i);

			// Only add actions that are for the Todo desttype, those are the only ones saved in the EMRActionsTodo... tables
			if(ea.eaoDestType == eaoTodo) {
				CString strNotes;
				CString strCategoryID;

				//If the modifier is an empty string, we reference NULL in the table.  Do this in the XML saving by
				//	just leaving out the data field that should be NULL
				if(ea.strTodoNotes.IsEmpty()) { strNotes = "";	} else { strNotes.Format("Notes=\"%s\"", ConvertToQuotableXMLString(ea.strTodoNotes)); }
				if(ea.nTodoCategoryID <= 0) { strCategoryID = ""; } else { strCategoryID.Format("CategoryID=\"%d\"", ea.nTodoCategoryID); }

				strAns += FormatString(
					"<A ActionID=\"%li\" RemindType=\"%d\" RemindInterval=\"%d\" "
					"DeadlineType =\"%d\" DeadlineInterval =\"%d\" Priority =\"%d\" "
					"Task =\"%s\" %s %s />\r\n", 
					ea.nID, ea.nTodoRemindType, ea.nTodoRemindInterval,
					ea.nTodoDeadlineType, ea.nTodoDeadlineInterval, ea.nTodoPriority,
					ConvertToQuotableXMLString(ea.strTodoMethod), strNotes, strCategoryID);
			}
		}
		strAns += "</ROOT>\r\n";
		// We've successfully generated the complete xml, pass it out to the variable that needs it
		return strAns;
	} else {
		return "";
	}
}

// (c.haag 2008-06-20 10:22) - PLID 30221 - This is copied from GenerateChargeDataXMLFromActionArray, but modiifed
// for data that goes in EMRActionsTodoDataT
CString GenerateTodoAssignToXMLFromActionArray(const MFCArray<EmrAction> &arActions)
{
	if (arActions.GetSize() > 0) {
		// Loop through all actions, adding an <A> record for each one, all surrounded by a <ROOT> tag pair
		CString strAns = "<ROOT>\r\n";
		for (long i=0; i<arActions.GetSize(); i++) {
			const EmrAction& ea = arActions.GetAt(i);
			if(ea.eaoDestType == eaoTodo) {
				// (a.walling 2014-07-01 15:28) - PLID 62697
				for (long assignTo : ea.anTodoAssignTo) {
					strAns += FormatString("<A ActionID=\"%li\" AssignTo=\"%d\" />\r\n", ea.nID, assignTo);
				}
			}
		}
		strAns += "</ROOT>\r\n";
		// We've successfully generated the complete xml, pass it out to the variable that needs it
		return strAns;
	} else {
		return "";
	}
}

// (c.haag 2008-07-18 11:53) - PLID 30724 - This is copied from the GenerateXMLFromActionArray, but modified for the data that goes in 
// EmrProblemActionsT only
// (c.haag 2014-07-22) - PLID 62789 - Added SNOMEDCodeID 
// (s.tullis 2015-02-23 17:47) - PLID 64749
CString GenerateEmrProblemDataXMLFromActionArray(const EmrAction& ea, const CProblemActionAry& aryProblems)
{
	// Loop through all actions, adding an <A> record for each one, all surrounded by a <ROOT> tag pair
	CString strAns = "<ROOT>\r\n";
	// (a.walling 2014-07-01 15:28) - PLID 62697
	// (c.haag 2014-07-22) - PLID 62789 - Added SNOMEDCodeID
	// (r.gonet 2015-03-10 14:48) - PLID 65013 - Added DoNotShowOnProblemPrompt.
	for (const auto& epa : aryProblems) {
		strAns += FormatString("<A EmrProblemActionID=\"%li\" ActionID=\"%li\" DefaultStatus=\"%li\" DefaultDescription=\"%s\" SpawnToSourceItem=\"%li\" %s DoNotShowOnCCDA=\"%li\" DoNotShowOnProblemPrompt=\"%li\" />\r\n", 
			epa.nID, ea.nID, epa.nStatus, ConvertToQuotableXMLString(epa.strDescription), epa.bSpawnToSourceItem
			, epa.GetSNOMEDValueForXML(),epa.bDoNotShowOnCCDA, epa.bDoNotShowOnProblemPrompt
			);
	}
	strAns += "</ROOT>\r\n";
	// We've successfully generated the complete xml, pass it out to the variable that needs it
	return strAns;
}

// (j.jones 2007-08-15 09:25) - PLID 27052 - added enums for the E/M category dropdown
enum EMCodeCategoryColumn {
	emcccID = 0,
	emcccDesc = 1,
	// (j.jones 2011-03-08 11:51) - PLID 42282 - this is just the EMCodeUseTableCategories enum, usually 0
	emcccUseTableCategories = 2,
};

// (j.jones 2007-08-14 12:22) - PLID 27053 - added enums for the E/M code type dropdown
enum EMCodeTypeColumn {
	emctcID = 0,
	emctcDesc = 1,
};

//TES 3/14/2011 - PLID 42757 - Colors for when the Glasses Order fields are disabled
#define DISABLED_COLOR	RGB(127,127,127)
#define DISABLED_COLOR_SEL	RGB(64,64,127)

// (a.walling 2010-03-09 14:13) - PLID 37640 - Moved to cpp
CEmrInfoDataElementArray::~CEmrInfoDataElementArray()
{
	 RemoveAllAndFreeEntries();
}

void CEmrInfoDataElementArray::RemoveAllAndFreeEntries()
{
	long nCount = GetSize();
	for (long i=GetSize()-1; i>=0; i--) {

		CEmrInfoDataElement *pElement = ((CEmrInfoDataElement*)GetAt(i));

		if(pElement) {

			pElement->m_arypEMRDropDownList.clear();
			pElement->m_arypEMRDropDownDeleted.clear();

			delete pElement;
			pElement = NULL;
		}
	}
	CArray<CEmrInfoDataElement *, CEmrInfoDataElement *>::RemoveAll();
}

long CEmrInfoDataElementArray::FindDataElement(long nSearchForID, long nStartSearchAtIndex) const
{
	long i;
	// Search from the starting index up to the end
	for (i=nStartSearchAtIndex; i<GetSize(); i++) {
		if (GetAt(i)->m_nID == nSearchForID) { return i; }
	}
	// Now loop back and search from the beginning up to the point we started at
	for (i=0; i<nStartSearchAtIndex; i++) {
		if (GetAt(i)->m_nID == nSearchForID) { return i; }
	}
	// If we made it here, the ID couldn't be found
	return -1;
}

long CEmrInfoDataElementArray::FindDataElement(CString strData) const
{
	for(long i = 0; i < GetSize(); i++) {
		if(!strData.CompareNoCase(GetAt(i)->m_strData)) { return i; }
	}
	return -1;
}

void CEmrInfoDataElementArray::AppendCopy(const CEmrInfoDataElementArray &aryeideCopyFrom)
{
	for (long i=0; i<aryeideCopyFrom.GetSize(); i++) {
		Add(new CEmrInfoDataElement(*aryeideCopyFrom.GetAt(i)));
	}
}

// (z.manning 2010-02-12 09:33) - PLID 37320
BOOL CEmrInfoDataElementArray::DoesElementExist(const long nListType, const BYTE nListSubType)
{
	for(int nIndex = 0; nIndex < this->GetSize(); nIndex++)
	{
		CEmrInfoDataElement *peide = this->GetAt(nIndex);
		if(peide != NULL) {
			// (z.manning 2010-04-09 10:57) - PLID 37937 - We allow smart stamp columns to be marked inactive now
			// so don't check for that when 
			if(peide->m_nListType == nListType && peide->m_nListSubType == nListSubType && !peide->m_bIsLabel)
			{
				peide->m_bDefault = FALSE;
				peide->m_bIsGrouped = FALSE;
				return TRUE;
			}
		}
	}
	return FALSE;
}

// (z.manning 2010-02-12 11:03) - PLID 37320
void CEmrInfoDataElementArray::EnsureSubTypeDoesNotExist(const BYTE nSubType)
{
	for(int nIndex = 0; nIndex < this->GetSize(); nIndex++)
	{
		CEmrInfoDataElement *peide = this->GetAt(nIndex);
		if(peide->m_nListSubType == nSubType) {
			peide->m_nListSubType = lstDefault;
		}
	}
}

/////////////////////////////////////////////////////////////////////////////
// CEmrItemEntryDlg dialog


CEmrItemEntryDlg::CEmrItemEntryDlg(CWnd* pParent /*=NULL*/)
	: CNxDialog(CEmrItemEntryDlg::IDD, pParent)
{
	//{{AFX_DATA_INIT(CEmrItemEntryDlg)
		// NOTE: the ClassWizard will add member initialization here
	//}}AFX_DATA_INIT
	m_nID = -1;
	m_nOriginalInfoID = -1;
	m_pCalledFromDetail = NULL;
	m_bAddingMultipleDataElements = FALSE;
	// (j.jones 2009-08-13 15:48) - PLID 31730 - we now track the sort order of the last multiply-added row
	m_nLastMultiplyAddedItemSortOrder = -1;
	m_pdlCurrentDataElementList = NULL;
	m_bOnePerEmn = FALSE;
	m_bIsEditingOnEMN = FALSE;
	m_bIsEditingOnTemplate = FALSE;
	m_bMaintainCurrentList = FALSE;
	m_bMaintainCurrentTable = FALSE;
	m_bIsCurrentDetailTemplate = FALSE;
	m_bListDataWasAdded = FALSE;
	m_bInactive = FALSE;
	m_bWillAddToTopic = FALSE;
	m_pCurrentEMN = NULL;
	m_pChangedIDMap = NULL;
	m_nEmrInfoMasterID = -1;
	// (j.jones 2007-08-14 16:58) - PLID 27052 - added E/M Category
	m_nEMCodeCategoryID = -1;
	// (j.jones 2011-03-08 12:25) - PLID 42282 - added m_eEMCodeUseTableCategories
	m_eEMCodeUseTableCategories = emcutcNone;
	// (j.jones 2007-08-14 16:58) - PLID 27053 - added E/M Code Type
	m_bUseEMCoding = FALSE;
	m_emctEMCodingType = emctUndefined;
	// (a.walling 2008-01-18 13:18) - PLID 14982 - Flag to prevent type change
	m_bPreventTypeChange = FALSE;
	// (j.jones 2010-02-17 11:55) - PLID 37318 - prevents changing the linked smart stamp table
	m_bPreventSmartStampTableChange = FALSE;
	// (c.haag 2008-01-22 09:25) - PLID 28686 - Set our behavior to normal,
	// which means this dialog will behave as it always has in the past by default
	m_Behavior = eEmrItemEntryDlgBehavior_Normal;
	m_pBehaviorData = NULL;
	m_bMaintainCurrentImage = false;
	m_nPreviewFlags = 0;
	m_nEmrDataCodeID = -1;
	m_bEnableSmartStamps = FALSE;
	m_varSmartStampTableMasterID.vt = VT_NULL;
	m_varSmartStampTableMasterIDForRequeryFinished.vt = VT_NULL;
	// (z.manning 2010-02-09 15:51) - PLID 37228 - Set the default to multi-select list as 
	// that's what we've always used before
	m_eitDefaultDataType = eitMultiList;
	m_bIsSmartStampTable = FALSE;
	// (j.jones 2010-02-26 08:33) - PLID 37231 - we need to track the "remember" settings
	// for the SmartStamp Image parent, as the table cannot be different
	m_bSmartStampImage_RememberForPatient = FALSE;
	m_bSmartStampImage_RememberForEMR = FALSE;
	m_bWarnBold = TRUE;
	m_bHasGlassesOrderData = FALSE; //TES 3/11/2011 - PLID 42757
	m_GlassesOrderLens = golInvalid; //TES 3/11/2011 - PLID 42757
	//TES 3/14/2011 - PLID 42784
	m_bSpellCheckInProgress = false;
	m_bSpellCheckMadeChange = false;
	m_bHasFormulas = FALSE; // (z.manning 2011-05-04 15:06) - PLID 43560
	m_nInfoFlags = 0; // (z.manning 2011-11-15 15:46) - PLID 46485
	m_bHasContactLensData = FALSE; //TES 4/6/2012 - PLID 49367
	m_bSavedHasContactLensData = FALSE; //TES 4/6/2012 - PLID 49367
	m_nCurrentlySelectedDataType = -1; //TES 6/27/2012 - PLID 51241
	m_bUseWithWoundCareCoding = FALSE; // (r.gonet 08/03/2012) - PLID 51735

	
}

CEmrItemEntryDlg::~CEmrItemEntryDlg()
{
	ClearChangedIDMap();
}

void CEmrItemEntryDlg::DoDataExchange(CDataExchange* pDX)
{
	CNxDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CEmrItemEntryDlg)
	DDX_Control(pDX, IDC_REMEMBER_FOR_EMR, m_checkRememberPerEMR);
	DDX_Control(pDX, IDC_CHECK_HIDE_TITLE_ON_PREVIEW_PANE, m_btnHideTitle);
	DDX_Control(pDX, IDC_CHECK_HIDE_ITEM_ON_PREVIEW_PANE, m_btnHideItem);
	DDX_Control(pDX, IDC_RADIO_TEXT_SELECT, m_btnSelText);
	DDX_Control(pDX, IDC_RADIO_LIST_SELECT, m_btnSelList);
	DDX_Control(pDX, IDC_RADIO_LIST_MULTISELECT, m_btnSelMultiList);
	DDX_Control(pDX, IDC_RADIO_IMAGE, m_btnSelImage);
	DDX_Control(pDX, IDC_RADIO_TABLE, m_btnSelTable);
	DDX_Control(pDX, IDC_RADIO_SLIDER, m_btnSelSlider);
	DDX_Control(pDX, IDC_RADIO_NARRATIVE, m_btnSelNarrative);
	DDX_Control(pDX, IDC_DATA_FORMAT_TEXT, m_btnFmtText);
	DDX_Control(pDX, IDC_DATA_FORMAT_LIST, m_btnFmtList);
	DDX_Control(pDX, IDC_DATA_FORMAT_BULLET, m_btnFmtBullet);
	DDX_Control(pDX, IDC_DATA_FORMAT_NUMBER, m_btnFmtNum);
	DDX_Control(pDX, IDC_REMEMBER_FOR_PATIENT, m_checkRememberPerPatient);
	DDX_Control(pDX, IDC_CHECK_ONE_PER_EMN, m_btnOnePerEMN);
	DDX_Control(pDX, IDC_CHECK_DISABLE_TABLE_BORDER, m_btnDisableTableBorder);
	DDX_Control(pDX, IDC_CHECK_USE_FOR_EM_CODING, m_btnUseEMCoding);
	DDX_Control(pDX, IDC_SHOW_INACTIVE_ELEMENTS, m_btnInactiveElements);
	DDX_Control(pDX, IDC_AUTO_ALPHABETIZE_LIST_DATA, m_btnAlphabetizeList);
	DDX_Control(pDX, IDC_TABLE_ROWS_AS_FIELDS, m_btnRowsAsFields);
	DDX_Control(pDX, IDC_CHECK_EMRINFO_INACTIVE, m_btnInactiveInfo);
	DDX_Control(pDX, IDC_PROMPT_FOR_IMAGE, m_btnPromptImage);
	DDX_Control(pDX, IDC_USE_SELECTED_IMAGE, m_btnSelectedImage);
	DDX_Control(pDX, IDC_USE_SELECTED_3DIMAGE, m_btnSelected3DImage);
	DDX_Control(pDX, IDC_INSERT_EMR_DATA_FIELD, m_btnInsertSentenceField);
	DDX_Control(pDX, IDC_ADD_OTHER_DATA_ITEM, m_btnAddOther);
	DDX_Control(pDX, IDC_CANCEL_EMR_ITEM_ENTRY, m_btnCancel);
	DDX_Control(pDX, IDOK, m_btnOK);
	DDX_Control(pDX, IDC_EDIT_EMR_EM_CATEGORIES, m_btnEditEMCategories);
	DDX_Control(pDX, IDC_EDIT_EMR_CATEGORIES, m_btnEditCategories);
	DDX_Control(pDX, IDC_BTN_EDIT_TABLE_DROPDOWN_DATA, m_btnEditDropdownContents);
	DDX_Control(pDX, IDC_BTN_PREVIEW_TABLE, m_btnPreviewTable);
	DDX_Control(pDX, IDC_DELETE_DATA_ITEM, m_btnDeleteDataItem);
	DDX_Control(pDX, IDC_ADD_MULTIPLE_DATA_ITEM, m_btnAddMultiDataItem);
	DDX_Control(pDX, IDC_ADD_DATA_ITEM, m_btnAddDataItem);
	DDX_Control(pDX, IDC_INSERT_EMR_FIELD, m_btnInsertField);
	DDX_Control(pDX, IDC_ITEM_ACTION, m_btnAction);
	DDX_Control(pDX, IDC_MODIFY_HOTSPOTS, m_ctrlModifyHotSpots);
	DDX_Control(pDX, IDC_COLOR_LEFT, m_nxclrLeft);
	DDX_Control(pDX, IDC_COLOR_RIGHT_TOP, m_nxclrRightTop);
	DDX_Control(pDX, IDC_COLOR_RIGHT_BOTTOM, m_nxclrRightBottom);
	DDX_Control(pDX, IDC_ITEM_NAME, m_nxeditItemName);
	DDX_Control(pDX, IDC_SENTENCE, m_nxeditSentence);
	DDX_Control(pDX, IDC_DATA_FORMAT_SEPARATOR, m_nxeditDataFormatSeparator);
	DDX_Control(pDX, IDC_DATA_FORMAT_SEPARATOR_FINAL, m_nxeditDataFormatSeparatorFinal);
	DDX_Control(pDX, IDC_DEFAULT_TEXT, m_nxeditDefaultText);
	DDX_Control(pDX, IDC_DATA_LONGFORM, m_nxeditDataLongform);
	DDX_Control(pDX, IDC_EMR_MINIMUM, m_nxeditEmrMinimum);
	DDX_Control(pDX, IDC_EMR_INCREMENT, m_nxeditEmrIncrement);
	DDX_Control(pDX, IDC_EMR_MAXIMUM, m_nxeditEmrMaximum);
	DDX_Control(pDX, IDC_EMR_CATEGORY_CAPTION, m_nxstaticEmrCategoryCaption);
	DDX_Control(pDX, IDC_DATA_TYPE_LABEL, m_nxstaticDataTypeLabel);
	DDX_Control(pDX, IDC_SENTENCE_FORMAT_CAPTION, m_nxstaticSentenceFormatCaption);
	DDX_Control(pDX, IDC_DATA_FORMAT_LABEL, m_nxstaticDataFormatLabel);
	DDX_Control(pDX, IDC_DATA_FORMAT_SEPARATOR_LABEL, m_nxstaticDataFormatSeparatorLabel);
	DDX_Control(pDX, IDC_DATA_FORMAT_SEPARATOR_FINAL_LABEL, m_nxstaticDataFormatSeparatorFinalLabel);
	DDX_Control(pDX, IDC_DATA_LABEL, m_nxstaticDataLabel);
	DDX_Control(pDX, IDC_DEFAULT_TEXT_CAPTION, m_nxstaticDefaultTextCaption);
	DDX_Control(pDX, IDC_ROW_LABEL, m_nxstaticRowLabel);
	DDX_Control(pDX, IDC_COLUMN_LABEL, m_nxstaticColumnLabel);
	DDX_Control(pDX, IDC_DATA_LONGFORM_LABEL, m_nxstaticDataLongformLabel);
	DDX_Control(pDX, IDC_EMR_EM_CATEGORY_CAPTION, m_nxstaticEmrEmCategoryCaption);
	DDX_Control(pDX, IDC_EMR_EM_CODE_TYPE_CAPTION, m_nxstaticEmrEmCodeTypeCaption);
	DDX_Control(pDX, IDC_EMR_MIN_LABEL, m_nxstaticEmrMinLabel);
	DDX_Control(pDX, IDC_EMR_INC_LABEL, m_nxstaticEmrIncLabel);
	DDX_Control(pDX, IDC_EMR_MAX_LABEL, m_nxstaticEmrMaxLabel);
	DDX_Control(pDX, IDC_EMR_IMAGE_FRAME, m_nxstaticEmrImageFrame);
	DDX_Control(pDX, IDC_BTN_EDIT_TABLE_CALCULATED_FIELD, m_btnEditTableCalculatedField);
	DDX_Control(pDX, IDC_BTN_EDIT_TABLE_AUTOFILL, m_btnEditTableAutofill);
	DDX_Control(pDX, IDC_EMR_SLIDER, m_Slider);
	DDX_Control(pDX, IDC_DATA_DOWN, m_btnDataDown);
	DDX_Control(pDX, IDC_DATA_UP, m_btnDataUp);
	DDX_Control(pDX, IDC_COLUMN_DATA_DOWN, m_btnColumnDataDown);
	DDX_Control(pDX, IDC_COLUMN_DATA_UP, m_btnColumnDataUp);
	DDX_Control(pDX, IDC_EMR_IMAGE, m_btnEmrImage);
	DDX_Control(pDX, IDC_SPELLCHECK_BTN, m_btnSpellCheck);
	DDX_Control(pDX, IDC_DATA_CODE_LABEL, m_nxstaticDataCodeLabel);
	DDX_Control(pDX, IDC_DATA_UNIT_LABEL, m_nxstaticDataUnitLabel);
	DDX_Control(pDX, IDC_BTN_EDIT_EMRDATACODES, m_btnEditEmrDataCodes);
	DDX_Control(pDX, IDC_EDIT_EMRDATACODEUNIT, m_nxeditDataUnit);
	DDX_Control(pDX, IDC_ENABLE_SMART_STAMPS, m_btnEnableSmartStamps);
	DDX_Control(pDX, IDC_EDIT_SMART_STAMP_TABLE, m_btnEditSmartStampTable);
	DDX_Control(pDX, IDC_NEW_SMART_STAMP_TABLE, m_btnNewSmartStampTable);
	DDX_Control(pDX, IDC_ASSOCIATE_WITH_GLASSES_ORDER, m_btnAssociateWithGlassesOrder);
	DDX_Control(pDX, IDC_EDIT_COMMON_LISTS, m_btnEditCommonLists);
	DDX_Control(pDX, IDC_EMR_ITEM_SELECT_STAMPS, m_btnSelectStamps);
	DDX_Control(pDX, IDC_ASSOCIATE_WITH_GLASSES_ORDER_OR_CL, m_btnAssociateWithGlassesOrderOrCL);
	DDX_Control(pDX, IDC_GO_CL_TOGGLE, m_nxlGOCLToggle);
	DDX_Control(pDX, IDC_USE_WITH_WOUND_CARE_CALC, m_btnUseWithWoundCareCoding);
	DDX_Control(pDX, IDC_PASTE_SETUP_DATA, m_btnPasteRows);
	DDX_Control(pDX, IDC_PASTE_SETUP_DATA_COLUMNS, m_btnPasteCols);
	DDX_Control(pDX, IDC_BTN_EDIT_TABLE_CELL_CODES, m_btnTableCellCodes);	
	//}}AFX_DATA_MAP
}


// (c.haag 2006-07-05 16:49) - PLID 19862 - We no longer let the user edit the current list
/*BEGIN_MESSAGE_MAP(CAdminCurrentListHelpDlg, CNxDialog)
	ON_WM_CTLCOLOR()
END_MESSAGE_MAP()*/

BEGIN_MESSAGE_MAP(CEmrItemEntryDlg, CNxDialog)
	//{{AFX_MSG_MAP(CEmrItemEntryDlg)
	ON_BN_CLICKED(IDC_RADIO_TEXT_SELECT, OnDataTypeSelected)
	ON_BN_CLICKED(IDC_DATA_FORMAT_LIST, OnDataFormatSelected)
	ON_BN_CLICKED(IDC_USE_SELECTED_IMAGE, OnImageTypeSelected)
	ON_BN_CLICKED(IDC_PROMPT_FOR_IMAGE, OnPromptForImage)
	ON_BN_CLICKED(IDC_CHECK_EMRINFO_INACTIVE, OnInactivate)
	ON_WM_DESTROY()
	ON_BN_CLICKED(IDC_EDIT_EMR_CATEGORIES, OnEditEmrCategories)
	ON_BN_CLICKED(IDC_INSERT_EMR_FIELD, OnInsertEmrField)
	ON_BN_CLICKED(IDC_EMR_IMAGE, OnEmrImage)
	ON_BN_CLICKED(IDC_ITEM_ACTION, OnItemAction)
	ON_BN_CLICKED(IDC_SHOW_INACTIVE_ELEMENTS, OnShowInactiveElements)
	ON_WM_CONTEXTMENU()
	ON_BN_CLICKED(IDC_DATA_UP, OnDataUp)
	ON_BN_CLICKED(IDC_DATA_DOWN, OnDataDown)
	ON_BN_CLICKED(IDC_COLUMN_DATA_UP, OnColumnDataUp)
	ON_BN_CLICKED(IDC_COLUMN_DATA_DOWN, OnColumnDataDown)
	ON_BN_CLICKED(IDC_DELETE_DATA_ITEM, OnBtnDeleteDataItem)
	ON_BN_CLICKED(IDC_ADD_DATA_ITEM, OnBtnAddDataItem)
	ON_BN_CLICKED(IDC_ADD_MULTIPLE_DATA_ITEM, OnBtnAddMultipleDataItem)
	ON_BN_CLICKED(IDC_ADD_OTHER_DATA_ITEM, OnBtnAddOtherDataItem)
	ON_BN_CLICKED(IDC_BTN_PREVIEW_TABLE, OnBtnPreviewTable)
	ON_BN_CLICKED(IDC_BTN_EDIT_TABLE_DROPDOWN_DATA, OnBtnEditTableDropdownData)
	ON_EN_KILLFOCUS(IDC_DATA_LONGFORM, OnKillfocusDataLongform)
	ON_EN_CHANGE(IDC_DATA_LONGFORM, OnChangeDataLongform)
	ON_BN_CLICKED(IDC_INSERT_EMR_DATA_FIELD, OnInsertEmrDataField)
	ON_BN_CLICKED(IDC_AUTO_ALPHABETIZE_LIST_DATA, OnAutoAlphabetizeListData)
	ON_EN_KILLFOCUS(IDC_EMR_INCREMENT, OnKillfocusEmrIncrement)
	ON_BN_CLICKED(IDC_SPELLCHECK_BTN, OnSpellCheckBtn)
	ON_BN_CLICKED(IDC_EDIT_EMR_EM_CATEGORIES, OnEditEmrEmCategories)
	ON_BN_CLICKED(IDC_CHECK_USE_FOR_EM_CODING, OnCheckUseForEmCoding)
	ON_BN_CLICKED(IDC_MODIFY_HOTSPOTS, OnModifyHotspots)
	ON_BN_CLICKED(IDC_BTN_EDIT_TABLE_CALCULATED_FIELD, OnBtnEditTableCalculatedField)
	ON_BN_CLICKED(IDC_BTN_EDIT_TABLE_AUTOFILL, OnBtnEditTableAutofill)
	ON_BN_CLICKED(IDC_REMEMBER_FOR_PATIENT, OnRememberForPatient)
	ON_BN_CLICKED(IDC_DATA_FORMAT_TEXT, OnDataFormatSelected)
	ON_BN_CLICKED(IDC_RADIO_LIST_SELECT, OnDataTypeSelected)
	ON_BN_CLICKED(IDC_RADIO_LIST_MULTISELECT, OnDataTypeSelected)
	ON_BN_CLICKED(IDC_RADIO_IMAGE, OnDataTypeSelected)
	ON_BN_CLICKED(IDC_RADIO_SLIDER, OnDataTypeSelected)
	ON_BN_CLICKED(IDC_RADIO_TABLE, OnDataTypeSelected)
	ON_BN_CLICKED(IDC_RADIO_NARRATIVE, OnDataTypeSelected)
	ON_BN_CLICKED(IDC_DATA_FORMAT_BULLET, OnDataFormatSelected)
	ON_BN_CLICKED(IDC_DATA_FORMAT_NUMBER, OnDataFormatSelected)
	ON_BN_CLICKED(IDC_REMEMBER_FOR_EMR, OnRememberForEmr)
	ON_BN_CLICKED(IDC_TABLE_ROWS_AS_FIELDS, OnTableRowsAsFields)
	ON_BN_CLICKED(IDC_BTN_EDIT_EMRDATACODES, OnBtnEditEmrDataCodes)
	ON_BN_CLICKED(IDC_ENABLE_SMART_STAMPS, OnEnableSmartStamps)
	ON_BN_CLICKED(IDC_EDIT_SMART_STAMP_TABLE, OnEditSmartStampTable)
	ON_BN_CLICKED(IDC_NEW_SMART_STAMP_TABLE, OnNewSmartStampTable)
	//}}AFX_MSG_MAP
	ON_BN_CLICKED(IDC_CANCEL_EMR_ITEM_ENTRY, &CEmrItemEntryDlg::OnBnClickedCancelEmrItemEntry)
	ON_BN_CLICKED(IDC_ASSOCIATE_WITH_GLASSES_ORDER, &CEmrItemEntryDlg::OnAssociateWithGlassesOrder)
	ON_BN_CLICKED(IDC_EDIT_COMMON_LISTS, &CEmrItemEntryDlg::OnEditCommonLists)
	ON_WM_TIMER()
	ON_BN_CLICKED(IDC_USE_SELECTED_3DIMAGE, &CEmrItemEntryDlg::OnBnClickedUseSelected3dimage)
	ON_BN_CLICKED(IDC_EMR_ITEM_SELECT_STAMPS, &CEmrItemEntryDlg::OnBnClickedEmrItemSelectStamps)
	ON_BN_CLICKED(IDC_ASSOCIATE_WITH_GLASSES_ORDER_OR_CL, &CEmrItemEntryDlg::OnAssociateWithGlassesOrderOrCL)
	ON_WM_SETCURSOR()
	ON_MESSAGE(NXM_NXLABEL_LBUTTONDOWN, &CEmrItemEntryDlg::OnLabelClick)
	ON_BN_CLICKED(IDC_USE_WITH_WOUND_CARE_CALC, &CEmrItemEntryDlg::OnUseWithWoundCareCoding)
	ON_BN_CLICKED(IDC_PASTE_SETUP_DATA, OnPasteSetupData)
	ON_BN_CLICKED(IDC_PASTE_SETUP_DATA_COLUMNS, OnPasteSetupDataColumns)
	ON_BN_CLICKED(IDC_BTN_EDIT_TABLE_CELL_CODES, &CEmrItemEntryDlg::OnBnClickedBtnEditTableCellCodes)
END_MESSAGE_MAP()

BEGIN_EVENTSINK_MAP(CEmrItemEntryDlg, CNxDialog)
    //{{AFX_EVENTSINK_MAP(CEmrItemEntryDlg)
	ON_EVENT(CEmrItemEntryDlg, IDC_EMR_CATEGORIES, 1 /* SelChanging */, OnSelChangingEmrCategories, VTS_PI4)
	ON_EVENT(CEmrItemEntryDlg, IDC_EMR_CATEGORIES, 16 /* SelChosen */, OnSelChosenEmrCategories, VTS_I4)
	ON_EVENT(CEmrItemEntryDlg, IDC_SELECT_LIST_TAB, 1 /* SelectTab */, OnSelectTabSelectList, VTS_I2 VTS_I2)
	ON_EVENT(CEmrItemEntryDlg, IDC_EMR_CATEGORIES, 23 /* ChangeColumnSortFinished */, OnChangeColumnSortFinishedEmrCategories, VTS_I2 VTS_BOOL VTS_I2 VTS_BOOL)
	ON_EVENT(CEmrItemEntryDlg, IDC_EMR_EM_CATEGORIES, 16 /* SelChosen */, OnSelChosenEmrEmCategories, VTS_DISPATCH)
	ON_EVENT(CEmrItemEntryDlg, IDC_EMR_EM_CODE_TYPE, 16 /* SelChosen */, OnSelChosenEmrEmCodeType, VTS_DISPATCH)
	ON_EVENT(CEmrItemEntryDlg, IDC_LIST_EMRDATACODES, 16, OnSelChosenListEmrDataCodes, VTS_DISPATCH)	
	ON_EVENT(CEmrItemEntryDlg, IDC_LIST_EMRDATACODES, 1, CEmrItemEntryDlg::SelChangingListEmrdatacodes, VTS_DISPATCH VTS_PDISPATCH)
	ON_EVENT(CEmrItemEntryDlg, IDC_SMART_STAMP_TABLE_COMBO, 18, CEmrItemEntryDlg::RequeryFinishedSmartStampTableCombo, VTS_I2)
	ON_EVENT(CEmrItemEntryDlg, IDC_SMART_STAMP_TABLE_COMBO, 16, OnSelChosenSmartStampTableCombo, VTS_DISPATCH)
	//}}AFX_EVENTSINK_MAP
	ON_EVENT(CEmrItemEntryDlg, IDC_EMR_DATA_LIST, 2, CEmrItemEntryDlg::OnSelChangedEmrDataList, VTS_DISPATCH VTS_DISPATCH)
	ON_EVENT(CEmrItemEntryDlg, IDC_EMR_DATA_LIST, 6, CEmrItemEntryDlg::OnRButtonDownEmrDataList, VTS_DISPATCH VTS_I2 VTS_I4 VTS_I4 VTS_I4)
	ON_EVENT(CEmrItemEntryDlg, IDC_EMR_DATA_LIST, 10, CEmrItemEntryDlg::OnEditingFinishedEmrDataList, VTS_DISPATCH VTS_I2 VTS_VARIANT VTS_VARIANT VTS_BOOL)
	ON_EVENT(CEmrItemEntryDlg, IDC_EMR_DATA_LIST, 19, CEmrItemEntryDlg::OnLeftClickEmrDataList, VTS_DISPATCH VTS_I2 VTS_I4 VTS_I4 VTS_I4)
	ON_EVENT(CEmrItemEntryDlg, IDC_EMR_DATA_LIST, 9, CEmrItemEntryDlg::OnEditingFinishingEmrDataList, VTS_DISPATCH VTS_I2 VTS_VARIANT VTS_BSTR VTS_PVARIANT VTS_PBOOL VTS_PBOOL)
	ON_EVENT(CEmrItemEntryDlg, IDC_EMR_DATA_LIST, 8, CEmrItemEntryDlg::EditingStartingEmrDataList, VTS_DISPATCH VTS_I2 VTS_PVARIANT VTS_PBOOL)
	ON_EVENT(CEmrItemEntryDlg, IDC_EMR_COLUMN_LIST, 8, CEmrItemEntryDlg::OnEditingStartingEmrColumnList, VTS_DISPATCH VTS_I2 VTS_PVARIANT VTS_PBOOL)
	ON_EVENT(CEmrItemEntryDlg, IDC_EMR_COLUMN_LIST, 2, CEmrItemEntryDlg::OnSelChangedEmrColumnList, VTS_DISPATCH VTS_DISPATCH)
	ON_EVENT(CEmrItemEntryDlg, IDC_EMR_COLUMN_LIST, 6, CEmrItemEntryDlg::OnRButtonDownEmrColumnList, VTS_DISPATCH VTS_I2 VTS_I4 VTS_I4 VTS_I4)
	ON_EVENT(CEmrItemEntryDlg, IDC_EMR_COLUMN_LIST, 9, CEmrItemEntryDlg::OnEditingFinishingEmrColumnList, VTS_DISPATCH VTS_I2 VTS_VARIANT VTS_BSTR VTS_PVARIANT VTS_PBOOL VTS_PBOOL)
	ON_EVENT(CEmrItemEntryDlg, IDC_EMR_COLUMN_LIST, 10, CEmrItemEntryDlg::OnEditingFinishedEmrColumnList, VTS_DISPATCH VTS_I2 VTS_VARIANT VTS_VARIANT VTS_BOOL)
	ON_EVENT(CEmrItemEntryDlg, IDC_EMR_COLUMN_LIST, 19, CEmrItemEntryDlg::LeftClickEmrColumnList, VTS_DISPATCH VTS_I2 VTS_I4 VTS_I4 VTS_I4)
END_EVENTSINK_MAP()

/////////////////////////////////////////////////////////////////////////////
// CEmrItemEntryDlg message handlers

BOOL CEmrItemEntryDlg::OnInitDialog() 
{
	CNxDialog::OnInitDialog();

	// (j.jones 2013-03-07 12:45) - PLID 55511 - remarkably this never had a cache before
	g_propManager.CachePropertiesInBulk("EmrItemEntryDlg", propNumber,
		"(Username = '<None>' OR Username = '%s') AND ("
		"Name = 'EMRShowInactiveElements' "
		"OR Name = 'DisableSmartStampTableDropdownStampFilters' "	// (j.jones 2013-03-07 12:41) - PLID 55511
		")",
		_Q(GetCurrentUserName()));

	//TES 12/14/2006 - PLID 23833 - We should always be given m_nInfoMasterID, not m_nID.
	ASSERT(m_nID == -1);
	if(m_nEmrInfoMasterID != -1) {
		//Look up the EmrInfoT ID.
		CParamSqlBatch sqlBatch;
		// (j.jones 2010-06-07 09:39) - PLID 39029 - also load the DataSubType
		sqlBatch.Add("SELECT ActiveEmrInfoID, EMRInfoT.DataSubType FROM EmrInfoMasterT "
			"INNER JOIN EMRInfoT ON EMRInfoMasterT.ActiveEmrInfoID = EMRInfoT.ID "
			"WHERE EmrInfoMasterT.ID = {INT} \r\n", m_nEmrInfoMasterID);
		if(!m_bIsSmartStampTable) {
			// (z.manning 2010-02-10 11:04) - PLID 37228 - If we don't already know this to be
			// a smart stamp table then let's check.
			// (j.jones 2010-02-26 08:33) - PLID 37231 - we need to track the "remember" settings
			// for the SmartStamp Image parent, as the table cannot be different
			sqlBatch.Add(
				"SELECT EmrInfoT.ID, RememberForPatient, RememberForEMR "
				"FROM EmrInfoT "
				"INNER JOIN EMRInfoMasterT ON EMRInfoT.ID = EMRInfoMasterT.ActiveEMRInfoID "
				"WHERE SmartStampsEnabled = 1 AND ChildEmrInfoMasterID = {INT} "
				, m_nEmrInfoMasterID);
		}
		_RecordsetPtr rsEmrInfoMaster = sqlBatch.CreateRecordsetNoTransaction(GetRemoteData());
		m_nID = AdoFldLong(rsEmrInfoMaster, "ActiveEmrInfoID");
		
		EmrInfoSubType eDataSubType = (EmrInfoSubType)AdoFldByte(rsEmrInfoMaster, "DataSubType");

		// (j.jones 2010-06-04 15:55) - PLID 39029 - Prevent modifying generic tables
		if(eDataSubType == eistGenericTable) {
			MsgBox("This item is built-in and cannot be edited.");
			CDialog::OnCancel();
			return TRUE;
		}
		// (j.jones 2012-10-08 17:50) - PLID 46298 - prevent changing the type of 3D images
		else if(eDataSubType == eist3DImage) {
			m_bPreventTypeChange = TRUE;
		}

		if(!m_bIsSmartStampTable) {
			rsEmrInfoMaster = rsEmrInfoMaster->NextRecordset(NULL);
			if(!rsEmrInfoMaster->eof) {
				// (z.manning 2010-02-10 11:07) - PLID 37228 - This item is associated with a smart stamp image
				m_bIsSmartStampTable = TRUE;
				m_bPreventTypeChange = TRUE;

				// (j.jones 2010-02-26 08:33) - PLID 37231 - we need to track the "remember" settings
				// for the SmartStamp Image parent, as the table cannot be different
				m_bSmartStampImage_RememberForPatient = AdoFldBool(rsEmrInfoMaster, "RememberForPatient", FALSE);
				m_bSmartStampImage_RememberForEMR = AdoFldBool(rsEmrInfoMaster, "RememberForEMR", FALSE);
			}
		}
		rsEmrInfoMaster->Close();
	}

	//TES 12/14/2006 - PLID 23833 - It's now our responsibility to prevent them from modifying the built in image.
	if(m_nID == EMR_BUILT_IN_INFO__IMAGE) {
		MsgBox("The 'Image' item is built-in and cannot be edited.");
		CDialog::OnCancel();
		return TRUE;
	}

	// (c.haag 2008-06-16 11:12) - PLID 30319 - Prevent modifying EMR macro text-based items
	else if(m_nID == EMR_BUILT_IN_INFO__TEXT_MACRO) {
		MsgBox("This item is built-in and cannot be edited.");
		CDialog::OnCancel();
		return TRUE;
	}
	
	// Set the up/down buttons to have the appropriate images
	m_btnDataUp.AutoSet(NXB_UP);
	m_btnDataDown.AutoSet(NXB_DOWN);
	m_btnColumnDataUp.AutoSet(NXB_UP);
	m_btnColumnDataDown.AutoSet(NXB_DOWN);
	// (b.cardillo 2007-01-23 14:47) - PLID 24388 - Changed the spellcheck button to an NxIconButton so we could include the icon.
	m_btnSpellCheck.SetIcon(IDI_SPELLCHECK_ICON);
	

	//DRT 2/18/2008 - PLID 29001 - Converted all buttons to NxIconButton type.  Need to auto set a few of them.
	m_btnOK.AutoSet(NXB_OK);
	m_btnCancel.AutoSet(NXB_CANCEL);
	m_btnAddMultiDataItem.AutoSet(NXB_NEW);
	m_btnAddDataItem.AutoSet(NXB_NEW);
	m_btnAddOther.AutoSet(NXB_NEW);
	m_btnDeleteDataItem.AutoSet(NXB_DELETE);
	m_btnEditEMCategories.AutoSet(NXB_MODIFY);
	m_btnEditCategories.AutoSet(NXB_MODIFY);
	m_btnEditDropdownContents.AutoSet(NXB_MODIFY);
	m_btnAction.AutoSet(NXB_MODIFY);
	m_ctrlModifyHotSpots.AutoSet(NXB_MODIFY);
	m_btnEditTableCalculatedField.AutoSet(NXB_MODIFY);
	m_btnEditSmartStampTable.AutoSet(NXB_MODIFY);
	m_btnNewSmartStampTable.AutoSet(NXB_NEW);
	m_btnEditCommonLists.AutoSet(NXB_MODIFY); // (c.haag 2011-03-14) - PLID 42814
	m_btnEditTableAutofill.AutoSet(NXB_MODIFY); // (z.manning 2011-03-18 14:49) - PLID 23662
	m_btnSelectStamps.AutoSet(NXB_MODIFY); // (z.manning 2011-10-24 12:40) - PLID 46082
	// (d.thompson 2012-10-16) - PLID 53184 - Apply the icon to the new paste buttons
	m_btnPasteRows.SetIcon(IDI_PASTE);
	m_btnPasteCols.SetIcon(IDI_PASTE);

	// (j.gruber 2013-12-11 13:18) - PLID 58816
	m_btnTableCellCodes.AutoSet(NXB_MODIFY);

	//Set up the select list tab control if we have to maintain a Current list
	//(The current list must be populated before initializing this dlg.)
	// (c.haag 2006-07-05 16:49) - PLID 19862 - We no longer let the user edit the current list
	/*if(m_bMaintainCurrentList) {
		GetDlgItem(IDC_SELECT_LIST_TAB)->ShowWindow(SW_SHOW); // It's invisible by default.
		GetDlgItem(IDC_CURRENT_ADMIN_LIST_HELP)->ShowWindow(SW_SHOW); // Show the help button as well
		m_pSelectListTab = GetDlgItem(IDC_SELECT_LIST_TAB)->GetControlUnknown();
		m_pSelectListTab->PutSize(2);
		m_pSelectListTab->PutTabWidth(2);
		m_pSelectListTab->PutLabel(sltCurrentList, "Current List");
		m_pSelectListTab->PutLabel(sltAdminList, "Admin List");
	}*/
	/*
	CFont fontListHelpButton;
	fontListHelpButton.CreateFont(12, 0, 0, 0, FW_BOLD, FALSE, FALSE, 0, ANSI_CHARSET, OUT_DEFAULT_PRECIS, CLIP_DEFAULT_PRECIS, DEFAULT_QUALITY, DEFAULT_PITCH, "Arial");
	GetDlgItem(IDC_CURRENT_ADMIN_LIST_HELP)->SetFont(&fontListHelpButton);*/
	//For the admin vs current list help button	
	// (c.haag 2006-07-05 16:49) - PLID 19862 - We no longer let the user edit the current list
	//m_dlgAdminCurrentListHelp.Create(IDD_CURRENT_ADMIN_HELP, this);

	m_pdlUsedOnTemplateList = BindNxDataListCtrl(this, IDC_USED_ON_TEMPLATE_LIST, GetRemoteData(), false);
	// (b.cardillo 2007-01-30 11:56) - PLID 24418 - We now adjust the sort priorities BEFORE starting 
	// the requery, so we can't pass "true" to BindNxDataListCtrl() anymore.
	m_pdlCategoryCombo = BindNxDataListCtrl(this, IDC_EMR_CATEGORIES, GetRemoteData(), false);

	// (z.manning 2011-07-21 17:30) - PLID 44676 - Bind the 3D image control
	m_p3DImage = GetDlgItem(IDC_EMR_ITEM_ENTRY_3DIMAGE)->GetControlUnknown();
	m_p3DImage->SetTextDataVersion(CURRENT_TEXT_STRUCTURE_VERSION);
	m_p3DImage->UseCustomStamps = VARIANT_FALSE; // (z.manning 2011-09-14 12:09) - PLID 44693
	m_p3DImage->BackColor = GetNxColor(GNC_ADMIN, 0);

	// (a.walling 2009-05-28 13:33) - PLID 34389
	m_dlEmrDataCode = BindNxDataList2Ctrl(IDC_LIST_EMRDATACODES, true);
	{
		NXDATALIST2Lib::IRowSettingsPtr pRow = m_dlEmrDataCode->GetNewRow();

		pRow->PutValue(lcID, (long)-1);
		pRow->PutValue(lcCode, " <None>");
		pRow->PutValue(lcDescription, g_cvarNull);
		pRow->PutValue(lcDefaultUnit, g_cvarNull);
		pRow->PutValue(lcVital, g_cvarNull);

		m_dlEmrDataCode->AddRowSorted(pRow, NULL);
	}

	// (z.manning 2010-02-09 17:30) - PLID 37228 - Smart stamp table combo
	m_pdlSmartStampTable = BindNxDataList2Ctrl(IDC_SMART_STAMP_TABLE_COMBO, false);

	// (j.jones 2010-07-28 13:03) - PLID 39029 - do not show the generic table (DataSubType = 3)
	// (z.manning 2011-03-23 12:21) - PLID 42971 - Do not show allergies and current meds here!! Only tables with a sub type of 0.
	CString strFrom = FormatString(
		"(SELECT EmrInfoMasterID, Name \r\n"
		" FROM EmrInfoMasterT \r\n"
		" INNER JOIN EmrInfoT ON EmrInfoMasterT.ActiveEmrInfoID = EmrInfoT.ID \r\n"
		" WHERE (EmrInfoMasterT.Inactive = 0 AND EmrInfoT.DataType = %d \r\n"
		"	AND EMRInfoT.DataSubType = %li) \r\n"
		, eitTable, eistNone);
	if(m_nID != -1) {
		strFrom += FormatString(
			" OR (EmrInfoMasterID = COALESCE((SELECT ChildEmrInfoMasterID FROM EmrInfoT WHERE ID = %li), -1)) \r\n"
			, m_nID);
	}
	strFrom += ") SmartStampTableQ";
	m_pdlSmartStampTable->PutFromClause(_bstr_t(strFrom));
	m_pdlSmartStampTable->Requery();

	// (b.cardillo 2007-01-30 11:56) - PLID 24418 - We now adjust the sort priorities BEFORE starting 
	// the requery, so this code is shifted above the adding of the built-in rows.
	// (j.armen 2012-05-31 14:39) - PLID 50718 - Check if we are licensed using the helper function
	if(g_pLicense->HasEMR(CLicense::cflrSilent) == 2) {
		//if L2 EMR, sort the Category combo by name
		m_pdlCategoryCombo->GetColumn(1)->SortPriority = 0;
	}
	else {
		//otherwise sort by priority
		m_pdlCategoryCombo->GetColumn(2)->SortPriority = 0;
	}

	// (b.cardillo 2007-01-30 11:56) - PLID 24418 - We now adjust the sort priorities BEFORE starting 
	// the requery.  So call Requery() now.
	m_pdlCategoryCombo->Requery();

	{
		IRowSettingsPtr pRow = m_pdlCategoryCombo->GetRow(sriGetNewRow);
		pRow->PutValue(0, (long)clsrvMultiCategory);
		pRow->PutValue(1, " { Multiple Categories... }");
		pRow->PutValue(2, (long)-1);
		m_pdlCategoryCombo->InsertRow(pRow, 0);
	}
	{
		IRowSettingsPtr pRow = m_pdlCategoryCombo->GetRow(sriGetNewRow);
		pRow->PutValue(0, (long)clsrvNoCategory);
		pRow->PutValue(1, " { No Categories }");
		pRow->PutValue(2, (long)-2);
		m_pdlCategoryCombo->InsertRow(pRow, 0);
	}

	// (j.jones 2007-08-14 08:43) - PLID 27052 - added E/M Categories
	m_pdlEMCategoryCombo = BindNxDataList2Ctrl(this, IDC_EMR_EM_CATEGORIES, GetRemoteData(), true);

	// (j.jones 2007-08-14 11:52) - PLID 27053 - added E/M calculation options
	m_pdlEMCodeTypeCombo = BindNxDataList2Ctrl(this, IDC_EMR_EM_CODE_TYPE, GetRemoteData(), false);	

	//TES 3/14/2011 - PLID 42784 - Converted to datalist2
	m_pdlDataElementList = BindNxDataList2Ctrl(this, IDC_EMR_DATA_LIST, GetRemoteData(), false);
	m_pdlColumnDataElementList = BindNxDataList2Ctrl(this, IDC_EMR_COLUMN_LIST, GetRemoteData(), false);
	m_RichEditCtrl = GetDlgItem(IDC_NARRATIVE_DEFAULT_TEXT)->GetControlUnknown();
	m_RichEditCtrl->BackColor = PaletteColor(GetNxColor(GNC_ADMIN, 0));

	// (j.jones 2011-03-08 12:25) - PLID 42282 - because the lists do not requery,
	// we must force the E/M category combo to reload its sql
	RequeryTableEMCategoryComboColumns();	

	//TES 3/11/2011 - PLID 42757 - Added Glasses Order data
	m_pdlGlassesOrderLens = BindNxDataList2Ctrl(this, IDC_GLASSES_ORDER_LENS, NULL, false);
	NXDATALIST2Lib::IRowSettingsPtr pLensRow = m_pdlGlassesOrderLens->GetNewRow();
	pLensRow->PutValue(golcCode, (long)golOD);
	pLensRow->PutValue(golcDescription, _bstr_t(GetGlassesOrderLensDescription(golOD)));
	m_pdlGlassesOrderLens->AddRowAtEnd(pLensRow, NULL);
	pLensRow = m_pdlGlassesOrderLens->GetNewRow();
	pLensRow->PutValue(golcCode, (long)golOS);
	pLensRow->PutValue(golcDescription, _bstr_t(GetGlassesOrderLensDescription(golOS)));
	m_pdlGlassesOrderLens->AddRowAtEnd(pLensRow, NULL);

	//TES 4/6/2012 - PLID 49367 - A hyperlink toggle to switch between Glasses Order Data and Contact Lens Data (for tables only)
	m_nxlGOCLToggle.SetColor(RGB(255, 170, 170));
	m_nxlGOCLToggle.SetType(dtsDisabledHyperlink);
	m_nxlGOCLToggle.SetText("Glasses Order Data");
	m_nxlGOCLToggle.AskParentToRedrawWindow();

	CheckDlgButton(IDC_SHOW_INACTIVE_ELEMENTS, GetRemotePropertyInt("EMRShowInactiveElements", 0, 0, GetCurrentUserName(), true));
	
	((CNxEdit*)GetDlgItem(IDC_ITEM_NAME))->SetLimitText(255);
	((CNxEdit*)GetDlgItem(IDC_SENTENCE))->SetLimitText(2000);
	((CNxEdit*)GetDlgItem(IDC_DATA_FORMAT_SEPARATOR))->SetLimitText(50);
	((CNxEdit*)GetDlgItem(IDC_DATA_FORMAT_SEPARATOR_FINAL))->SetLimitText(50);
	((CNxEdit*)GetDlgItem(IDC_DATA_LONGFORM))->SetLimitText(2000);
	// (a.walling 2009-05-28 15:11) - PLID 34389
	m_nxeditDataUnit.SetLimitText(10);

	if (m_bPreventTypeChange) {
		// (a.walling 2008-01-18 13:19) - PLID 14982 - Disable the item type controls
		GetDlgItem(IDC_RADIO_TEXT_SELECT)->EnableWindow(FALSE);
		GetDlgItem(IDC_RADIO_LIST_SELECT)->EnableWindow(FALSE);
		GetDlgItem(IDC_RADIO_LIST_MULTISELECT)->EnableWindow(FALSE);
		GetDlgItem(IDC_RADIO_IMAGE)->EnableWindow(FALSE);
		GetDlgItem(IDC_RADIO_SLIDER)->EnableWindow(FALSE);
		GetDlgItem(IDC_RADIO_NARRATIVE)->EnableWindow(FALSE);
		GetDlgItem(IDC_RADIO_TABLE)->EnableWindow(FALSE);

		// (z.manning 2011-10-07 12:27) - PLID 44676 - Also disable the image radio buttons as that's essentially a potential
		GetDlgItem(IDC_PROMPT_FOR_IMAGE)->EnableWindow(FALSE);
		GetDlgItem(IDC_USE_SELECTED_IMAGE)->EnableWindow(FALSE);
		GetDlgItem(IDC_USE_SELECTED_3DIMAGE)->EnableWindow(FALSE);
	}

	// (j.jones 2010-02-17 11:55) - PLID 37318 - prevent changing the linked smart stamp table
	if(m_bPreventSmartStampTableChange) {
		GetDlgItem(IDC_ENABLE_SMART_STAMPS)->EnableWindow(FALSE);		
		m_pdlSmartStampTable->PutEnabled(VARIANT_FALSE);
		m_btnEditSmartStampTable.EnableWindow(FALSE);
		m_btnNewSmartStampTable.EnableWindow(FALSE);
	}

	
	// If the ID has been set, we're editing an existing one, otherwise we're creating a new one
	try {
		// Load the variables from data (or from detaults if we're on a new one)
		Load();
		// Since we just loaded the member variables, we need to reflect them on screen
		ReflectState();
	} NxCatchAllCall("CEmrItemEntryDlg::OnInitDialog", {
		EndDialog(IDCANCEL);
		return FALSE;
	});

	// (z.manning 2010-02-12 09:19) - PLID 37320 - If this is a smart stamp table then we need
	// to ensure the type, location, and quantity columns exist
	if(m_bIsSmartStampTable)
	{
		// (z.manning 2010-08-11 10:43) - PLID 40074 - Starting with the auto number ("Problem") column, it is now possible
		// to have new smart stamp columns since the initial release of the feature. Since many users will likely
		// want to use these new columns, we add them automatically even when editing existing smart stamp tables.
		// We will prompt them, however, with a don't show me again box. Keep track of any columns that need prompted in this
		// array.
		CStringArray arystrColumnsToPrompt;

		// (j.jones 2011-03-08 12:25) - PLID 42282 - added EMCodeCategoryID, defaults to -1
		//TES 3/11/2011 - PLID 42757 - Added Glasses Order Data
		// (r.gonet 08/03/2012) - PLID 51735 - Added a default value for Wound Care Data Type
		// (j.jones 2012-09-19 12:22) - PLID 52316 - added ParentLabelID, always defaults to -1
		// (j.gruber 2013-09-26 09:13) - PLID 58754 - added datagroupID, defaults to -1
		// (j.gruber 2014-07-17 13:39) - PLID 62621 - keyword fields, default to "" and false
		// (j.gruber 2014-12-05 15:37) - PLID 64361 - Load the new values for UseNameForKeyword
		CEmrInfoDataElement eideBase(-1, "", 1, FALSE, FALSE, LIST_TYPE_TEXT, FALSE, "", FALSE, -1, "", NULL, FALSE, -1, "", 0, "", lstDefault, FALSE, "", etantInvalid, "", godtInvalid, -1, etatNone, 0, ", ", ", ", ", ", wcdtNone, -1, "", FALSE, FALSE);

		eideBase.m_strData = EnsureUniqueDataName("Quantity", TRUE);
		eideBase.m_nListSubType = lstSmartStampQuantity;
		if(!m_aryCurColumnDataElements.DoesElementExist(eideBase.m_nListType, eideBase.m_nListSubType)) {
			m_aryCurColumnDataElements.EnsureSubTypeDoesNotExist(eideBase.m_nListSubType);
			AddDataElement(new CEmrInfoDataElement(eideBase), TRUE);
		}

		eideBase.m_strData = EnsureUniqueDataName("Description", TRUE);
		eideBase.m_nListSubType = lstSmartStampDescription;
		if(!m_aryCurColumnDataElements.DoesElementExist(eideBase.m_nListType, eideBase.m_nListSubType)) {
			m_aryCurColumnDataElements.EnsureSubTypeDoesNotExist(eideBase.m_nListSubType);
			AddDataElement(new CEmrInfoDataElement(eideBase), TRUE);
		}

		eideBase.m_strData = EnsureUniqueDataName("Location", TRUE);
		eideBase.m_nListSubType = lstSmartStampLocation;
		if(!m_aryCurColumnDataElements.DoesElementExist(eideBase.m_nListType, eideBase.m_nListSubType)) {
			m_aryCurColumnDataElements.EnsureSubTypeDoesNotExist(eideBase.m_nListSubType);
			AddDataElement(new CEmrInfoDataElement(eideBase), TRUE);
		}

		eideBase.m_strData = EnsureUniqueDataName("Type", TRUE);
		eideBase.m_nListSubType = lstSmartStampType;
		if(!m_aryCurColumnDataElements.DoesElementExist(eideBase.m_nListType, eideBase.m_nListSubType)) {
			m_aryCurColumnDataElements.EnsureSubTypeDoesNotExist(eideBase.m_nListSubType);
			AddDataElement(new CEmrInfoDataElement(eideBase), TRUE);
		}

		// (z.manning 2010-08-11 13:35) - PLID 40074 - New auto-number column
		eideBase.m_strData = EnsureUniqueDataName("Problem", TRUE);
		eideBase.m_nListSubType = lstSmartStampAutoNumber;
		if(!m_aryCurColumnDataElements.DoesElementExist(eideBase.m_nListType, eideBase.m_nListSubType)) {
			m_aryCurColumnDataElements.EnsureSubTypeDoesNotExist(eideBase.m_nListSubType);
			CEmrInfoDataElement *peideAutoNumber = new CEmrInfoDataElement(eideBase);
			peideAutoNumber->m_nAutoNumberType = etantPerRow;
			peideAutoNumber->m_strAutoNumberPrefix = "Problem";
			AddDataElement(peideAutoNumber, TRUE);
			arystrColumnsToPrompt.Add(eideBase.m_strData);
		}

		//TES 3/8/2012 - PLID 48728 - New Initial Type column
		eideBase.m_strData = EnsureUniqueDataName("Initial Type", TRUE);
		eideBase.m_nListSubType = lstSmartStampInitialType;
		if(!m_aryCurColumnDataElements.DoesElementExist(eideBase.m_nListType, eideBase.m_nListSubType)) {
			m_aryCurColumnDataElements.EnsureSubTypeDoesNotExist(eideBase.m_nListSubType);
			AddDataElement(new CEmrInfoDataElement(eideBase), TRUE);
			arystrColumnsToPrompt.Add(eideBase.m_strData);
		}
		

		// (z.manning 2010-08-11 11:04) - PLID 40074 - If this is an existing table and we added columns to it
		// warn the user with a don't show me again popup.
		if(m_nID != -1 && arystrColumnsToPrompt.GetSize() > 0 &&m_Behavior != eEmrItemEntryDlgBehavior_OpenInvisibleAndSave)
		{
			CString strCols, strColsWithNewLines;
			for(int nNewColIndex = arystrColumnsToPrompt.GetSize() - 1; nNewColIndex >= 0; nNewColIndex--) {
				CString strCol = arystrColumnsToPrompt.GetAt(nNewColIndex);
				strCols += strCol;
				strColsWithNewLines += strCol + "\r\n";
			}

			// (z.manning 2010-08-11 11:15) - PLID 40074 - Set the don't show me again property name specific to 
			// the columns we're prompting about.
			CString strPropName = "SmartStampBuiltInColumnPrompt" + strCols;

			// (z.manning 2010-08-11 11:50) - PLID 40074 - Now show the don't show me again
			CString strItem = IsDlgButtonChecked(IDC_TABLE_ROWS_AS_FIELDS) == BST_CHECKED ? "row(s)" : "column(s)";
			CString strMessage = FormatString("The following new built in %s have been added to this table:\r\n\r\n"
				"%s\r\nIf you do not want to have these %s in your table then you can inactivate them."
				, strItem, strColsWithNewLines, strItem);
			DontShowMeAgain(this, strMessage, strPropName);
		}
	}

	// (j.jones 2011-05-03 16:00) - PLID 43527 - if this is the current medications table,
	// we will need to add the built-in Sig column, and warn them that we did so so they don't
	// panic when it tries to save something on close
	if(m_DataSubType == eistCurrentMedicationsTable) {
		// (r.gonet 08/03/2012) - PLID 51735 - Added a default value for Wound Care Data Type
		// (j.jones 2012-09-19 12:22) - PLID 52316 - added ParentLabelID, always defaults to -1
		// (j.gruber 2013-09-26 09:14) - PLID 58754 - added data group ID, defaults to -1
		// (j.gruber 2014-07-17 13:39) - PLID 62621 - keyword fields, default to "" and false
		// (j.gruber 2014-12-05 15:37) - PLID 64361 - Load the new values for UseNameForKeyword
		CEmrInfoDataElement eideBase(-1, "", 1, FALSE, FALSE, LIST_TYPE_TEXT, FALSE, "", FALSE, -1, "", NULL, FALSE, -1, "", 0, "", lstDefault, FALSE, "", etantInvalid, "", godtInvalid, -1, etatNone, 0, ", ", ", ", ", ", wcdtNone, -1, "", FALSE, FALSE);

		eideBase.m_strData = EnsureUniqueDataName("Sig", TRUE);
		eideBase.m_nListSubType = lstCurrentMedicationSig;
		//the Sig field defaults to inactive, because most people do not want it
		eideBase.m_bInactive = TRUE;

		//insert the column after the Rx checkbox, which is fixed at sort order 1
		eideBase.m_nSortOrder = 2;

		if(!m_aryCurColumnDataElements.DoesElementExist(eideBase.m_nListType, eideBase.m_nListSubType)) {
			m_aryCurColumnDataElements.EnsureSubTypeDoesNotExist(eideBase.m_nListSubType);
			CEmrInfoDataElement *peideSig = new CEmrInfoDataElement(eideBase);
			AddDataElement(peideSig, TRUE);

			//if this is an existing table, warn about how we added this field
			if(m_nID != -1 && m_Behavior != eEmrItemEntryDlgBehavior_OpenInvisibleAndSave) {
				
				CString strType = IsDlgButtonChecked(IDC_TABLE_ROWS_AS_FIELDS) == BST_CHECKED ? "row" : "column";
				//change the message based on whether we are currently viewing inactive items
				CString strMessage;
				if(IsDlgButtonChecked(IDC_SHOW_INACTIVE_ELEMENTS)) {
					strMessage = FormatString("A new Sig %s can optionally be added to the Current Medications table. It is currently inactive.\n"
						"If you would like to display the Sig %s, uncheck the Inactive flag for the Sig %s.", strType, strType, strType);
				}
				else {
					strMessage = FormatString("A new Sig %s can optionally be added to the Current Medications table. It is currently inactive.\n"
						"If you would like to display the Sig %s, click on \"Show Inactive\" and then uncheck the Inactive flag for the Sig %s.", strType, strType, strType);
				}
				DontShowMeAgain(this, strMessage, "CurrentMedsBuiltInColumnPromptSig");
			}
		}
	}

	// (c.haag 2008-01-22 09:43) - PLID 28686 - Based on our behavior enumeration,
	// choose a course of action

	switch (m_Behavior) {
	case eEmrItemEntryDlgBehavior_AddNewDropdownColumnSelection:
		// (c.haag 2008-01-22 09:44) - PLID 28686 - If we get here, the user opened
		// the dialog with intent to add a new selection to an embedded dropdown for
		// a column.
		//
		// Since a user will not be allowed to change any other content, don't bother
		// displaying the allergy/medication warnings.
		{
			const long nColumnID = (long)m_pBehaviorData;
			//TES 3/14/2011 - PLID 42784 - Converted to datalist2
			NXDATALIST2Lib::IRowSettingsPtr pRow = m_pdlColumnDataElementList->SetSelByColumn(cdelcID, nColumnID);
			if (pRow == NULL) {
				// The column doesn't exist! This should never happen.
				ASSERT(FALSE);
				ThrowNxException("The column you have chosen to add a new selection for does not exist!");
			}

			const long nColumnType = VarLong(pRow->GetValue(cdelcType));
			// (z.manning 2011-03-09) - PLID 42722 - Also allow text columns to do this
			if (LIST_TYPE_DROPDOWN != nColumnType && LIST_TYPE_TEXT != nColumnType) {
				// This is not a dropdown!
				ASSERT(FALSE);
				ThrowNxException("The column you have chosen to add a new selection for is not a dropdown or text column!");
			}

			// If we get here, we've selected the column whose embedded dropdown we want to edit. Go for it.
			OnBtnEditTableDropdownData();

			// Now terminate the dialog.
			OnOK();
			EndDialog(IDOK);
			return FALSE;
		}
		break;

	// (z.manning 2010-02-12 11:55) - PLID 37320 - Added a behavior option to never show this dialog and just
	// save silently.
	case eEmrItemEntryDlgBehavior_OpenInvisibleAndSave:
		if(!ValidateSaveAndClose()) {
			ThrowNxException("Failed to silently save emr item (MasterID = %li, InfoID = %li)", m_nEmrInfoMasterID, m_nID);
		}
		return FALSE;
		break;

	// (c.haag 2011-03-30) - PLID 43047 - Open straight into the common list configuration if requested.
	case eEmrItemEntryDlgBehavior_EditCommonLists:
		if(eistCurrentMedicationsTable != m_DataSubType && eistAllergiesTable != m_DataSubType) {
			// This should never happen when used correctly
			ThrowNxException("Attempted to edit Common Lists for a non-system table item!");
		}
		else {
			PostMessage(WM_COMMAND, IDC_EDIT_COMMON_LISTS);
		}
		break;

	default:
		// (c.haag 2007-01-29 16:53) - PLID 24423 - If this is the system Current Medications item,
		// warn the user of the consequences of changing it
		if (IsSystemCurrentMedicationsItem()) {
			MsgBox("You have chosen to edit the system Current Medications EMR table item.\n\n"
				"You may add or remove medications from this table; however, any changes you make "
				"will also be made to the master medications list. This list may be accessed from "
				"the Medications tab of the Patients module.");
		}
		// (c.haag 2007-04-03 09:04) - PLID 25468 - Warn the user about Allergies items as well
		if (IsSystemAllergiesItem()) {
			MsgBox("You have chosen to edit the system Allergies EMR table item.\n\n"
				"You may add or remove allergies from this table; however, any changes you make "
				"will also be made to the master allergy list. This list may be accessed from "
				"the Medications tab of the Patients module.");
		}
		break;
	}

	// If we're creating a new one, then we want to set focus and highlight the whole text 
	// in the info name field
	if (m_nID == -1) {
		// Set the focus
		GetDlgItem(IDC_ITEM_NAME)->SetFocus();
		// Set the selection
		CString str;
		GetDlgItemText(IDC_ITEM_NAME, str);
		SendDlgItemMessage(IDC_ITEM_NAME, EM_SETSEL, 0, str.GetLength());
		// Return false since we set the focus
		return FALSE;
	} else {
		return TRUE;  // return TRUE unless you set the focus to a control
		              // EXCEPTION: OCX Property Pages should return FALSE
	}
}

long CEmrItemEntryDlg::GetID()
{
	return m_nID;
}

long CEmrItemEntryDlg::GetInfoMasterID()
{
	return m_nEmrInfoMasterID;
}

CString CEmrItemEntryDlg::GetName()
{
	return m_strName;
}

long CEmrItemEntryDlg::GetDataType()
{
	return m_nDataType;
}

int CEmrItemEntryDlg::OpenWithMasterID(long nInfoMasterID, EEmrItemEntryDlgBehavior behavior /* = eEmrItemEntryDlgBehavior_Normal */, LPVOID pBehaviorData /* = NULL */)
{
	// (c.haag 2008-01-22 09:30) - PLID 28686 - We now support a behavior enumeration.
	// Depending on its value, the dialog may open normally; or, it may open to a specific section
	// (such as the edit dropdown dialog when a user wants to add a new dropdown selection for an 
	// EMR item on the spot)
	m_Behavior = behavior;
	m_pBehaviorData = pBehaviorData;
	m_nEmrInfoMasterID = nInfoMasterID;
	return CDialog::DoModal();
}

void CEmrItemEntryDlg::OnDestroy() 
{
	//DRT 1/17/2008 - PLID 28602 - Need to cleanup memory associated with image hotspots.
	try {
		//These are the spots we saved, or last loaded if there was an apply at some point during dialog execution.  These
		//	all need cleaned up, they are our responsibility.
		int i = 0;
		for(i = 0; i < m_aryLastSavedHotSpots.GetSize(); i++) {
			CEMRHotSpot *pSpot = m_aryLastSavedHotSpots.GetAt(i);
			delete pSpot;
		}
		m_aryLastSavedHotSpots.RemoveAll();

		//These are newly added hotspots since the dialog opened.  If the user hit OK this should be empty (shifted to the above), but
		//	if they cancel the dialog, these need cleaned up by us.
		for(i = 0; i < m_aryNewHotSpots.GetSize(); i++) {
			CEMRHotSpot *pSpot = m_aryNewHotSpots.GetAt(i);
			delete pSpot;
		}
		m_aryNewHotSpots.RemoveAll();

		//These are spots that were removed.  If the user hit OK this should be empty (already deleted).  However, since you can only
		//	delete pre-saved spots, these spots *must* exist in m_aryLastSavedHotSpots, thus we've already deleted them 2 loops ago.
		//Just empty the array.
		m_aryRemovedHotSpots.RemoveAll();

		//These are spots that were changed.  Again, to be changed, you must have been pre-saved, and thus in m_aryLastSavedHotSpots.
		//Just empty the array
		m_aryChangedHotSpots.RemoveAll();
	} NxCatchAll("Error in OnDestroy");

	CDialog::OnDestroy();
}

// Given a valid m_nID, this pulls the properties out of the database, places the values into 
// variables, and then reflects the variables on screen.
void CEmrItemEntryDlg::Load()
{
	// Load everything into variables
	if (m_nID != -1) {
		// Make sure it's not a built-in ID (built-in IDs are all less than or equal to -25), or some other 
		// sentinel ID (all sentinel IDs are between -24 and -1, inclusive) or 0 (0 is an invalid ID).  So in 
		// other words, now that we know it's not -1 (the only sentinel value we support), just make sure it's 
		// greater than 0.
		if (m_nID <= 0) {
			ThrowNxException("CEmrItemEntryDlg::Load: Cannot load EMR Info Item for invalid ID %li!", m_nID);
		}

		// Ok, we're good, run the query (we expect to get exactly one record)
		_RecordsetPtr prs = CreateRecordset(

			// (c.haag 2006-02-14 12:44) - PLID 19051 - We cannot assume NOCOUNT is off here.
			// If we do, then if NOCOUNT is on, then the call to NextRecordset will return NULL
			//
			"SET NOCOUNT OFF\r\n"
			// basic info
			// (c.haag 2007-01-29 15:20) - PLID 24423 - Added support for DataSubType
			// (j.jones 2007-08-14 17:32) - PLID 27052 - added E/M Category
			// (j.jones 2007-08-14 17:32) - PLID 27053 - added E/M Code Type
			// (a.walling 2008-06-30 14:51) - PLID 30570 - Added PreviewFlags
			// (j.jones 2008-09-22 13:08) - PLID 31476 - added RememberForEMR
			// (c.haag 2008-10-16 09:53) - PLID 31708 - Added TableRowsAsFields
			// (a.walling 2009-05-28 15:12) - PLID 34389 - Added DataCodeID, DataUnit
			// (z.manning 2010-02-09 14:24) - PLID 37228 - Added SmartStampsEnabled and ChildEmrInfoMasterID
			//TES 2/18/2010 - PLID 37234 - Added UseSmartStampsLongForm and SmartStampsLongForm
			// (z.manning 2010-07-26 14:39) - PLID 39848 - Removed UseSmartStampsLongForm and SmartStampsLongForm
			// (j.jones 2011-03-08 12:25) - PLID 42282 - added EMCodeUseTableCategories			
			//TES 3/11/2011 - PLID 42757 - Added HasGlassesOrderData, GlassesOrderLens
			// (z.manning 2011-11-15 15:45) - PLID 46485 - Added InfoFlags
			//TES 4/6/2012 - PLID 49367 - Added HasContactLensData
			// (r.gonet 08/03/2012) - PLID 51735 - UseWithWoundCareCoding			
			"SELECT Name, EmrInfoMasterT.Inactive, OnePerEmn, DataType, DataSubType, RememberForPatient, RememberForEMR, LongForm, DataFormat, DataSeparator, DataSeparatorFinal, \r\n"
			"	BackgroundImageType, BackgroundImageFilePath, DefaultText, SliderMin, SliderMax, SliderInc, AutoAlphabetizeListData, DisableTableBorder, \r\n"
			"	EMCodeCategoryID, EMCodeUseTableCategories, UseEMCoding, EMCodingType, PreviewFlags, TableRowsAsFields, DataCodeID, DataUnit, SmartStampsEnabled, \r\n"
			"	ChildEmrInfoMasterID, HasGlassesOrderData, GlassesOrderLens, InfoFlags, HasContactLensData, UseWithWoundCareCoding, \r\n"
			"	EmrInfoT.UseWithWoundCareCoding\r\n"
			"FROM EMRInfoT \r\n"
			"INNER JOIN EmrInfoMasterT ON EmrInfoT.ID = EmrInfoMasterT.ActiveEmrInfoID \r\n"
			"WHERE EmrInfoMasterT.ID = %li \r\n"
			// categories
			"SELECT EMRCategoryID FROM EMRInfoCategoryT WHERE EMRInfoID = %li \r\n"
			// actions
			//DRT 1/10/2007 - PLID 24181 - Added special data for charge type actions
			//(s.dhole 7/17/2014 4:24 PM ) - PLID 62724 Added DiagCodeID_ICD10 , DiagCodeID_ICD9
			"SELECT ID, SourceID, SourceType, DestType, DestID, SortOrder, Popup, SpawnAsChild, EMRActionChargeDataT.Prompt, EMRActionChargeDataT.DefaultQuantity, "
			"RemindType, RemindInterval, DeadlineType, DeadlineInterval, Notes, Priority, Task, CategoryID, "
			"EMRActionChargeDataT.Modifier1Number, EMRActionChargeDataT.Modifier2Number, EMRActionChargeDataT.Modifier3Number, "
			"EMRActionChargeDataT.Modifier4Number,EmrActionDiagnosisDataT.DiagCodeID_ICD9,EmrActionDiagnosisDataT.DiagCodeID_ICD10  FROM EmrActionsT "
			"LEFT JOIN EMRActionChargeDataT ON EMRActionsT.ID = EMRActionChargeDataT.ActionID "
			// (c.haag 2008-06-04 11:26) - PLID 30221 - EMR todo actions
			"LEFT JOIN EMRActionsTodoDataT ON EMRActionsT.ID = EMRActionsTodoDataT.ActionID "
			"LEFT JOIN EmrActionDiagnosisDataT ON EMRActionsT.ID = EmrActionDiagnosisDataT.emrActionID "
			"WHERE Deleted = 0 AND SourceType = %li AND SourceID = %li \r\n"
			// data elements
			// (j.jones 2007-08-15 12:26) - PLID 27053 - added UseEMCoding
			// (z.manning, 05/22/2008) - PLID 16443 - Added Formula and DecimalPlaces
			// (z.manning 2009-01-15 15:13) - PLID 32724 - Added input mask
			// (z.manning 2010-02-11 17:02) - PLID 37324 - ListSubType
			// (c.haag 2010-02-23 17:44) - PLID 37488 - AutoAlphabetizeDropdown
			// (j.gruber 2010-04-26 11:57) - PLID 38336 - BOLD Codes
			// (z.manning 2010-08-11 13:34) - PLID 40074 - AutoNumber fields
			// (j.jones 2011-03-08 12:25) - PLID 42282 - added EMCodeCategoryID
			//TES 3/11/2011 - PLID 42757 - Added Glasses Order data
			// (z.manning 2011-03-21 09:52) - PLID 23662 - Added autofill type
			// (z.manning 2011-05-26 15:03) - PLID 43865 - DataFlags
			// (z.manning 2011-09-19 13:24) - PLID 41954 - Dropdown separators
			// (z.manning 2011-11-07 10:50) - PLID 46309 - SpawnedItemsSeparator
			// (r.gonet 08/03/2012) - PLID 51735 - WoundCareDataType
			// (j.jones 2012-09-19 12:22) - PLID 52316 - added ParentLabelID,
			// the ParentLabelName is only used for auditing
			// (j.gruber 2013-09-25 13:07) - PLID 58754 - dataGroupID	
			// (j.gruber 7/10/2014) plid 62621 - useKeyword, keywordoverride
			// (j.gruber 2014-12-05 15:37) - PLID 64361 - Load the new values for UseNameForKeyword
			"SELECT EMRDataT.ID, EMRDataT.Data, SortOrder, Inactive, ListType, IsGrouped, BoldCode, AutoNumberType, AutoNumberPrefix, "
			"	CONVERT(BIT, (CASE WHEN EXISTS (SELECT * FROM EMRInfoDefaultsT WHERE EMRDataID = EMRDataT.ID) THEN 1 ELSE 0 END)) AS IsDefault, "
			"	LongForm, IsLabel, ParentLabelID, ParentLabelDataT.Data AS ParentLabelName, UseEMCoding, EMCodeCategoryID, Formula, DecimalPlaces, InputMask, ListSubType, AutoAlphabetizeDropdown, EmrDataT.DataFlags, "
			"	GlassesOrderDataType, GlassesOrderDataID, AutofillType, DropdownSeparator, DropdownSeparatorFinal, SpawnedItemsSeparator, "
			"	WoundCareDataType, EMRDataT.EMRDataGroupID as DataGroupID, "
			" EMRDataT.UseKeyword, EMRDataT.KeywordOverride, EMRDataT.UseNameForKeyword "
			"FROM EMRDataT "
			"INNER JOIN EMRDataGroupsT ON EMRDataT.EMRDataGroupID = EMRDataGroupsT.ID "
			"LEFT JOIN (SELECT ID, Data FROM EMRDataT) AS ParentLabelDataT ON EMRDataT.ParentLabelID = ParentLabelDataT.ID "
			"WHERE EMRDataT.EMRInfoID = %li ORDER BY EMRDataT.SortOrder \r\n"
			// data element actions
			//DRT 1/10/2007 - PLID 24181 - Added special data for charge type actions			
			//(s.dhole 7/17/2014 4:24 PM ) - PLID 62724 Added DiagCodeID_ICD10 , DiagCodeID_ICD9
			"SELECT ID, SourceType, SourceID, DestType, DestID, SortOrder, Popup, SpawnAsChild, EMRActionChargeDataT.Prompt, EMRActionChargeDataT.DefaultQuantity, "
			"RemindType, RemindInterval, DeadlineType, DeadlineInterval, Notes, Priority, Task, CategoryID, "
			"EMRActionChargeDataT.Modifier1Number, EMRActionChargeDataT.Modifier2Number, EMRActionChargeDataT.Modifier3Number, "
			"EMRActionChargeDataT.Modifier4Number ,EmrActionDiagnosisDataT.DiagCodeID_ICD9,EmrActionDiagnosisDataT.DiagCodeID_ICD10   FROM EmrActionsT "
			"LEFT JOIN EMRActionChargeDataT ON EMRActionsT.ID = EMRActionChargeDataT.ActionID "
			// (c.haag 2008-06-04 11:26) - PLID 30221 - EMR todo actions
			"LEFT JOIN EMRActionsTodoDataT ON EMRActionsT.ID = EMRActionsTodoDataT.ActionID "
			"LEFT JOIN EmrActionDiagnosisDataT ON EMRActionsT.ID = EmrActionDiagnosisDataT.emrActionID "
			"WHERE SourceType = %li AND SourceID IN (SELECT ID FROM EMRDataT WHERE EMRInfoID = %li) AND Deleted = 0 ORDER BY SourceID \r\n"
			// (j.gruber 2013-10-01 13:47) - PLID 58674 - add EMR codes on data items
			// (j.gruber 2013-10-21 09:10) - PLID 59101 - and now rows and columns
			" SELECT EMRDataGroupCodesT.EMRDataGroupID, CodesT.ID as CodeID, CodesT.Code as Code, EMRDataT.ID AS EMRDataID, CodesT.Name as CodeName, CodesT.Vocab, EMRDataT.ListType "
			" FROM EMRDataT INNER JOIN EMRDataGroupCodesT ON EMRDataT.EMRDataGroupID = EMRDataGroupCodesT.EMRDataGroupID "
			" INNER JOIN CodesT ON EMRDataGroupCodesT.CodeID = CodesT.ID "
			" WHERE EMRDataT.EMRInfoID = %li "
			" ORDER BY EMRDataT.SortOrder "
			//hot spot data
			//DRT 1/17/2008 - PLID 28602 - Added hot spot data for images
			//TES 2/9/2010 - PLID 37223 - Added Anatomic Location info to hotspots.
			//TES 2/10/2010 - PLID 37296 - Add location and qualifier names, for auditing.
			// (z.manning 2011-07-22 16:09) - PLID 44676 - Added ImageHotSpotID
			"SELECT EmrImageHotSpotsT.ID, EmrImageHotSpotsT.Data, EmrImageHotSpotsT.AnatomicLocationID, ImageHotSpotID, "
			"	LabAnatomyT.Description AS AnatomicLocation, AnatomicQualifierID, AnatomyQualifiersT.Name AS AnatomicQualifier, AnatomySide "
			"FROM EMRImageHotSpotsT "
			"LEFT JOIN LabAnatomyT ON EmrImageHotSpotsT.AnatomicLocationID = LabAnatomyT.ID "
			"LEFT JOIN AnatomyQualifiersT ON EmrImageHotSpotsT.AnatomicQualifierID = AnatomyQualifiersT.ID "
			"WHERE EMRInfoID = %li \r\n"
			//DRT 1/17/2008 - PLID 28602 - Added the action data for hot spots
			"SELECT ID, SourceType, SourceID, DestType, DestID, SortOrder, Popup, SpawnAsChild, EMRActionChargeDataT.Prompt, EMRActionChargeDataT.DefaultQuantity, "
			"RemindType, RemindInterval, DeadlineType, DeadlineInterval, Notes, Priority, Task, CategoryID, "
			"EMRActionChargeDataT.Modifier1Number, EMRActionChargeDataT.Modifier2Number, EMRActionChargeDataT.Modifier3Number, "
			"EMRActionChargeDataT.Modifier4Number ,EMRActionDiagnosisDataT.DiagCodeID_ICD9 ,EMRActionDiagnosisDataT.DiagCodeID_ICD10 FROM EmrActionsT "
			"LEFT JOIN EMRActionChargeDataT  ON EMRActionsT.ID = EMRActionChargeDataT.ActionID "
			// (c.haag 2008-06-20 10:49) - PLID 30221 - EMR todo actions
			"LEFT JOIN EMRActionsTodoDataT ON EMRActionsT.ID = EMRActionsTodoDataT.ActionID "
			//(s.dhole 7/17/2014 4:24 PM ) - PLID 62724 Added DiagCodeID_ICD10 , DiagCodeID_ICD9
			" LEFT JOIN EMRActionDiagnosisDataT ON  EMRActionsT.ID =  EMRActionDiagnosisDataT.EmrActionID  "
			"WHERE SourceType = %li AND SourceID IN (SELECT ID FROM EMRImageHotSpotsT WHERE EMRInfoID = %li) AND Deleted = 0 ORDER BY SourceID \r\n"
			// (c.haag 2008-07-17 16:02) - PLID 30724 - EMR problem actions
			// (c.haag 2014-07-22) - PLID 62789 - Added SNOMEDCodeID
			// (s.tullis 2015-02-23 17:47) - PLID 64749 
			// (r.gonet 2015-03-10 14:48) - PLID 65013 - Added DoNotShowOnProblemPrompt.
			// (a.walling 2016-01-26 08:59) - PLID 67684 - Replaced complex predicate with separate UNIONed queries, avoiding pathological plans
			// and also using EMRTableDropdownInfoJoinedV in lieu of the nested IN clauses for EMRTableDropdownInfoT + EMRDataT for EMRInfoID
			"; WITH EMRProblemActionsQ AS ( "
				"SELECT EMRProblemActionsT.ID "
					",EmrActionID "
					",DefaultDescription "
					",DefaultStatus "
					",SpawnToSourceItem "
					",SNOMEDCodeID "
					",EmrActionsT.SourceID "
					",EmrActionsT.SourceType "
					",EMRProblemActionsT.DoNotShowOnCCDA "
					",EMRProblemActionsT.DoNotShowOnProblemPrompt "
				"FROM EMRProblemActionsT "
				"INNER JOIN EMRActionsT ON EMRActionsT.ID = EMRProblemActionsT.EmrActionID "
				// (c.haag 2008-08-05 09:12) - PLID 30941 - Check for inactive problem actions
				"WHERE EMRActionsT.Deleted = 0 "
					"AND EMRProblemActionsT.Inactive = 0 "
			") "
			"SELECT * FROM EMRProblemActionsQ WHERE "
					"( "
						"SourceType = %li "
						"AND SourceID = %li "
					") "
			""
			"UNION ALL "
			""
			"SELECT * FROM EMRProblemActionsQ WHERE "
					"( "
						"SourceType = %li "
						"AND SourceID IN ( "
							"SELECT ID "
							"FROM EMRDataT "
							"WHERE EMRInfoID = %li "
						") "
					") "
			""
			"UNION ALL "
			""
			"SELECT * FROM EMRProblemActionsQ WHERE "
					"( "
						"SourceType = %li "
						"AND SourceID IN ( "
							"SELECT ID "
							"FROM EMRImageHotSpotsT "
							"WHERE EMRInfoID = %li "
						") "
					") "
			""
			"UNION ALL "
			""
			// (z.manning 2009-02-11 10:17) - PLID 33029 - Problem actions for EMR dropdown item actions
			"SELECT * FROM EMRProblemActionsQ WHERE "
					"( "
						"SourceType = %li "
						"AND SourceID IN ( "
							"SELECT ID "
							"FROM EMRTableDropdownInfoJoinedV "
							"WHERE EMRTableDropdownInfoJoinedV.EMRInfoID = %li "
						") "
					"); \r\n"
			// (c.haag 2011-03-14) - PLID 42813 - Load Common Lists (They appear as buttons in CM/Allergy tables)
			// (c.haag 2011-04-11) - PLID 43234 - Added GroupOnPreviewPane
			"SELECT ID, Name, Color, OrderID, Inactive, GroupOnPreviewPane "
			"FROM EmrInfoCommonListT "
			"WHERE EmrInfoID = %d "
			"ORDER BY OrderID \r\n"
			"SELECT EmrInfoCommonListItemsT.ID, EmrInfoCommonListItemsT.ListID, EmrInfoCommonListItemsT.EmrDataID, EmrDataT.Data "
			"FROM EmrInfoCommonListItemsT "
			"INNER JOIN EmrDataT ON EmrDataT.ID = EmrInfoCommonListItemsT.EmrDataID "
			"INNER JOIN EmrInfoCommonListT ON EmrInfoCommonListT.ID = EmrInfoCommonListItemsT.ListID "
			"WHERE EmrInfoCommonListT.EmrInfoID = %d \r\n"
			// (z.manning 2011-10-24 11:34) - PLID 46082 - Load per-item stamp info
			"SELECT StampID FROM EmrInfoStampExclusionsT WHERE EmrInfoMasterID = %li \r\n"
			// (j.gruber 2013-09-20 13:28) - PLID 58676 - Load Table Cell Codes - load the row values
			" SELECT EMRDataGroupID_X, EMRDataGroupID_Y, CodeID, CodesT.Code, CodesT.Vocab, CodesT.Name as CodeName, EMRDataT_Y.Data as Y_Data, EMRDataT_X.Data as X_Data  "
			" FROM EmrTableDataGroupCodesT "
			" INNER JOIN EMRDataGroupsT EMRDataGroupT_Y ON EmrTableDataGroupCodesT.EMRDataGroupID_Y = EMRDataGroupT_Y.ID "
			" INNER JOIN EMRDataGroupsT EMRDataGroupT_X ON EmrTableDataGroupCodesT.EMRDataGroupID_X = EMRDataGroupT_X.ID "
			" INNER JOIN EMRDataT EMRDataT_Y ON EMRDataGroupT_Y.ID = EMRDataT_Y.EMRDataGroupID "
			" INNER JOIN EMRDataT EMRDataT_X ON EMRDataGroupT_X.ID = EMRDataT_X.EMRDataGroupID "
			" INNER JOIN CodesT ON EMRTableDataGroupCodesT.CodeID = CodesT.ID "
			" WHERE  "
			" EMRDataT_Y.EMRInfoID = %li AND "
			" EMRDataT_X.EMRInfoID = %li "
			, m_nEmrInfoMasterID
			, m_nID
			, eaoEmrItem, m_nID
			, m_nID
			, eaoEmrDataItem, m_nID
			, m_nID // (j.gruber 2013-10-01 13:54) - PLID 58674 - EMRDataGroupCodes
			, m_nID
			, eaoEmrImageHotSpot, m_nID
			, eaoEmrItem, m_nID, eaoEmrDataItem, m_nID, eaoEmrImageHotSpot, m_nID, eaoEmrTableDropDownItem, m_nID
			, m_nID
			, m_nID
			, m_nEmrInfoMasterID
			,m_nID
			,m_nID
			);
		if (!prs->eof) {
			// Got the record data out of the 'basic info' recordset
			{
				// Get a pointer to the fields
				FieldsPtr pflds = prs->GetFields();

				// Load the member variables from the record
				m_strName = AdoFldString(pflds, "Name");
				m_nDataType = AdoFldByte(pflds, "DataType");
				m_DataSubType = (EmrInfoSubType)AdoFldByte(pflds, "DataSubType"); // (c.haag 2007-01-29 15:20) - PLID 24423 - Added support for DataSubType
				//TES 10/28/2010 - PLID 41174 - Special logging
				if (IsSystemCurrentMedicationsItem()) {
					Log_CurrentMedicationsEdit("Loading Current Medications");
				}
				m_bRememberForPatient = AdoFldBool(pflds, "RememberForPatient");
				m_bRememberForEMR = AdoFldBool(pflds, "RememberForEMR");	// (j.jones 2008-09-22 13:04) - PLID 31476 - added
				m_bTableRowsAsFields = AdoFldBool(pflds, "TableRowsAsFields"); // (c.haag 2008-10-16 09:54) - PLID 31708
				m_bAutoAlphabetizeListData = AdoFldBool(pflds, "AutoAlphabetizeListData");
				
				//m.hancock - 2/28/2006 - PLID 15864 - Allow user to disable border on EMR table items when merging
				_variant_t var = pflds->Item["DisableTableBorder"]->Value;
				m_bDisableTableBorder = VarBool(var, FALSE);

				// (j.jones 2007-08-14 16:58) - PLID 27052 - added E/M Category
				m_nEMCodeCategoryID = AdoFldLong(pflds, "EMCodeCategoryID", -1);

				// (j.jones 2011-03-08 12:25) - PLID 42282 - added m_eEMCodeUseTableCategories
				m_eEMCodeUseTableCategories = (EMCodeUseTableCategories)AdoFldLong(pflds, "EMCodeUseTableCategories", (long)emcutcNone);

				// (j.jones 2007-08-14 16:58) - PLID 27053 - added E/M Code Type
				m_bUseEMCoding = AdoFldBool(pflds, "UseEMCoding");
				m_emctEMCodingType = (EMCodingTypes)AdoFldLong(pflds, "EMCodingType", (long)emctUndefined);

				// Change data list sort order if needed
				if (GetAutoAlphabetizeRowData()) {
					// (j.jones 2009-09-21 08:54) - PLID 35605 - ensured we sort by the correct column enum
					m_pdlDataElementList->GetColumn(delcSortOrder)->SortPriority = -1;
					m_pdlDataElementList->GetColumn(delcData)->SortPriority = 0;
					m_pdlDataElementList->GetColumn(delcData)->SortAscending = TRUE;
				}
				if (GetAutoAlphabetizeColumnData()) {
					// (j.jones 2009-09-21 08:54) - PLID 35605 - ensured we sort by the correct column enum
					m_pdlColumnDataElementList->GetColumn(cdelcSortOrder)->SortPriority = -1;
					m_pdlColumnDataElementList->GetColumn(cdelcData)->SortPriority = 0;
					m_pdlColumnDataElementList->GetColumn(cdelcData)->SortAscending = TRUE;
				}

				// (c.haag 2007-02-13 08:45) - PLID 24728 - If this is the current medications
				// item, we have to limit the row name size to 255
				if (IsSystemCurrentMedicationsItem()) {
					m_pdlDataElementList->GetColumn(delcData)->MaxTextLen = 255;
				}

				m_strLongForm = AdoFldString(pflds, "LongForm");
				m_nDataFormat = AdoFldLong(pflds, "DataFormat", 0);
				m_strDataSeparator = AdoFldString(pflds, "DataSeparator", ", ");
				m_strDataSeparatorFinal = AdoFldString(pflds, "DataSeparatorFinal", m_strDataSeparator == ", " ? " and " : m_strDataSeparator);
				m_bOnePerEmn = AdoFldBool(pflds, "OnePerEmn");
				m_bInactive = AdoFldBool(pflds, "Inactive");

				// (a.walling 2009-05-28 15:13) - PLID 34389
				m_nEmrDataCodeID = AdoFldLong(pflds, "DataCodeID", -1);
				m_strEmrDataCodeUnit = AdoFldString(pflds, "DataUnit", "");

				// (z.manning 2010-02-09 14:38) - PLID 37228
				m_bEnableSmartStamps = AdoFldBool(pflds, "SmartStampsEnabled", FALSE);
				m_varSmartStampTableMasterID = pflds->GetItem("ChildEmrInfoMasterID")->GetValue();

				long nBgImageType = AdoFldLong(pflds, "BackgroundImageType", -1);
				if (nBgImageType == 2) {
					// In the data, this means "anatomical diagram" and implies the BackgroundImageFilePath field 
					// will refer to an actual file
					m_bImageSpecified = TRUE;
					m_strImagePath = AdoFldString(pflds, "BackgroundImageFilePath", "");
				} else if (nBgImageType == -1) {
					// This means the data was null for this field, which means the user must make a selection at runtime
					m_bImageSpecified = FALSE;
					m_strImagePath = "";
				} else {
					// This is an unexpected case because the only other acceptable value for the ImageType is 1, 
					// and that value is an indication to load the image from "the current patient" but since we're 
					// not on a patient, we're on an info item, it makes no sense to have a value of 1.  So we have 
					// to fail.
					ThrowNxException("CEmrItemEntryDlg::Load: Could not load image information for EMR Info Item %li!", m_nID);
				}
				m_strDefaultText = AdoFldString(pflds, "DefaultText", "");
				m_dblSliderMin = AdoFldDouble(pflds, "SliderMin", 0.0);
				m_dblSliderMax = AdoFldDouble(pflds, "SliderMax", 10.0);
				m_dblSliderInc = AdoFldDouble(pflds, "SliderInc", 1.0);
				//correct bad data
				if(m_dblSliderInc <= 0.0)
					m_dblSliderInc = 1.0;

				// (a.walling 2008-06-30 14:51) - PLID 30570 - Preview Pane flags
				m_nPreviewFlags = AdoFldLong(pflds, "PreviewFlags", 0);

				//TES 3/11/2011 - PLID 42757 - Added Glasses Order data
				m_bHasGlassesOrderData = AdoFldBool(pflds, "HasGlassesOrderData");
				m_GlassesOrderLens = (GlassesOrderLens)AdoFldLong(pflds, "GlassesOrderLens",golInvalid);

				m_nInfoFlags = AdoFldLong(pflds, "InfoFlags", 0); // (z.manning 2011-11-15 15:47) - PLID 46485
				//TES 4/6/2012 - PLID 49367 - Added Contact Lens data
				m_bSavedHasContactLensData = m_bHasContactLensData = AdoFldBool(pflds, "HasContactLensData");
				// (r.gonet 08/03/2012) - PLID 51735 - Added UseWithWoundCareCoding
				m_bUseWithWoundCareCoding = AdoFldBool(pflds, "UseWithWoundCareCoding");				
			}

			// Now get the categories (loaded from the 'categories' recordset)
			{
				m_arynCategoryIDs.RemoveAll();
				prs = prs->NextRecordset(NULL);
				if (NULL == prs) {
					// (c.haag 2006-02-15 09:04) - PLID 19051 - If this is NULL, something bad happened
					AfxThrowNxException("CEmrItemEntryDlg::Load: Failed to load NextRecordset!");
				}
				FieldPtr fldCatId = prs->GetFields()->GetItem("EMRCategoryID");
				while (!prs->eof) {
					m_arynCategoryIDs.Add(AdoFldLong(fldCatId));
					prs->MoveNext();
				}
			}

			// Now get the actions (loaded from the 'actions' recordset)
			{
				m_arActions.RemoveAll();
				prs = prs->NextRecordset(NULL);
				if (NULL == prs) {
					// (c.haag 2006-02-15 09:04) - PLID 19051 - If this is NULL, something bad happened
					AfxThrowNxException("CEmrItemEntryDlg::Load: Failed to load NextRecordset!");
				}
				while (!prs->eof) {
					EmrAction ea;
					// (z.manning 2009-02-12 10:18) - PLID 33029 - I moved the code for setting an action
					// object to a utility function.
					SetActionFromFields(prs->GetFields(), ea);
					m_arActions.Add(ea);
					prs->MoveNext();
				}
			}

			// And get all the data elements (loaded from the 'data elements' recordset)
			{
				// First get the data elements themselves
				{
					m_aryDataElements.RemoveAllAndFreeEntries();
					m_aryColumnDataElements.RemoveAllAndFreeEntries();
					prs = prs->NextRecordset(NULL);
					if (NULL == prs) {
						// (c.haag 2006-02-15 09:04) - PLID 19051 - If this is NULL, something bad happened
						AfxThrowNxException("CEmrItemEntryDlg::Load: Failed to load NextRecordset!");
					}
					FieldsPtr pflds = prs->GetFields();
					FieldPtr fldID = pflds->GetItem("ID");
					FieldPtr fldData = pflds->GetItem("Data");
					FieldPtr fldIsDefault = pflds->GetItem("IsDefault");
					FieldPtr fldSortOrder = pflds->GetItem("SortOrder");
					FieldPtr fldInactive = pflds->GetItem("Inactive");
					FieldPtr fldListType = pflds->GetItem("ListType");
					FieldPtr fldListSubType = pflds->GetItem("ListSubType");
					FieldPtr fldAutoAlphabetizeDropdown = pflds->GetItem("AutoAlphabetizeDropDown"); // (c.haag 2010-02-23 17:44) - PLID 37488 - AutoAlphabetizeDropdown
					FieldPtr fldIsGrouped = pflds->GetItem("IsGrouped");
					FieldPtr fldLongForm = pflds->GetItem("LongForm");
					FieldPtr fldIsLabel = pflds->GetItem("IsLabel");
					// (j.jones 2012-09-19 12:22) - PLID 52316 - added ParentLabelID,
					// the ParentLabelName is only used for auditing
					FieldPtr fldParentLabelID = pflds->GetItem("ParentLabelID");
					FieldPtr fldParentLabelName = pflds->GetItem("ParentLabelName");
					FieldPtr fldFormula = pflds->GetItem("Formula");
					FieldPtr fldDecimalPlaces = pflds->GetItem("DecimalPlaces");
					FieldPtr fldInputMask = pflds->GetItem("InputMask"); // (z.manning 2009-01-15 15:18) - PLID 32724
					// (j.jones 2007-08-15 12:26) - PLID 27053 - added UseEMCoding
					FieldPtr fldUseEMCoding = pflds->GetItem("UseEMCoding");
					// (j.jones 2011-03-08 12:25) - PLID 42282 - added EMCodeCategoryID
					FieldPtr fldEMCodeCategoryID = pflds->GetItem("EMCodeCategoryID");
					// (j.gruber 2010-04-26 12:29) - PLID 38336 - BOLD Codes
					FieldPtr fldBOLDCode = pflds->GetItem("BOLDCode");
					// (z.manning 2010-08-11 13:35) - PLID 40074 - AutoNumber fields
					FieldPtr fldAutoNumberType = pflds->GetItem("AutoNumberType");
					FieldPtr fldAutoNumberPrefix = pflds->GetItem("AutoNumberPrefix");
					//TES 3/11/2011 - PLID 42757 - Added Glasses Order data
					FieldPtr fldGlassesOrderDataType = pflds->GetItem("GlassesOrderDataType");
					FieldPtr fldGlassesOrderDataID = pflds->GetItem("GlassesOrderDataID");
					FieldPtr fldAutofillType = pflds->GetItem("AutofillType");
					FieldPtr fldFlags = pflds->GetItem("DataFlags");
					FieldPtr fldDropdownSeparator = pflds->GetItem("DropdownSeparator");
					FieldPtr fldDropdownSeparatorFinal = pflds->GetItem("DropdownSeparatorFinal");
					FieldPtr fldSpawnedItemsSeparator = pflds->GetItem("SpawnedItemsSeparator");
					// (r.gonet 08/03/2012) - PLID 51735 - Added Wound Care Data Type
					FieldPtr fldWoundCareDataType = pflds->GetItem("WoundCareDataType");
					// (j.gruber 2013-09-25 13:07) - PLID 58754 - Data Group ID
					FieldPtr fldDataGroupID = pflds->GetItem("DataGroupID");
					//j.gruber 62621 - Keywords
					FieldPtr fldKeywordOverride = pflds->GetItem("KeywordOverride");
					FieldPtr fldUseKeyword = pflds->GetItem("UseKeyword");
					// (j.gruber 2014-12-05 15:37) - PLID 64361 - Load the new values for UseNameForKeyword
					FieldPtr fldUseNameForKeyword = pflds->GetItem("UseNameForKeyword");
					while (!prs->eof)
					{
						CString strFormula = AdoFldString(fldFormula);
						// (z.manning 2011-05-04 15:07) - PLID 43560 - If this data element has a formula flag the item as such.
						if(!strFormula.IsEmpty()) {
							m_bHasFormulas = TRUE;
						}

						if(AdoFldLong(fldListType) >= 3) {
							// (z.manning 2009-01-15 15:18) - PLID 32724 - Added InputMask
							// (j.jones 2011-03-08 12:25) - PLID 42282 - added EMCodeCategoryID
							//TES 3/11/2011 - PLID 42757 - Added Glasses Order data
							// (z.manning 2011-03-21 09:54) - PLID 23662 - Added autofill type
							// (r.gonet 08/03/2012) - PLID 51735 - Added Wound Care Data Type
							// (j.jones 2012-09-19 12:22) - PLID 52316 - added ParentLabelID, but it's always null on columns
							// (j.gruber 2014-07-17 13:39) - PLID 62621 - keyword fields
							// (j.gruber 2014-12-05 15:37) - PLID 64361 - Load the new values for UseNameForKeyword
							m_aryColumnDataElements.Add(new CEmrInfoDataElement(AdoFldLong(fldID), AdoFldString(fldData), AdoFldLong(fldSortOrder), AdoFldBool(fldIsDefault), AdoFldBool(fldInactive), AdoFldLong(fldListType), AdoFldBool(fldIsGrouped), AdoFldString(fldLongForm), AdoFldBool(fldIsLabel), -1, "", NULL, AdoFldBool(fldUseEMCoding), AdoFldLong(fldEMCodeCategoryID, -1), strFormula, AdoFldByte(fldDecimalPlaces,2), AdoFldString(fldInputMask,""), AdoFldByte(fldListSubType,lstDefault), AdoFldBool(fldAutoAlphabetizeDropdown), AdoFldString(fldBOLDCode), (EEmrTableAutoNumberType)AdoFldByte(fldAutoNumberType,etantInvalid), AdoFldString(fldAutoNumberPrefix,""), (GlassesOrderDataType)AdoFldLong(fldGlassesOrderDataType,godtInvalid),AdoFldLong(fldGlassesOrderDataID,-1),(EmrTableAutofillType)AdoFldByte(fldAutofillType,etatNone), AdoFldLong(fldFlags,0), AdoFldString(fldDropdownSeparator,", "), AdoFldString(fldDropdownSeparatorFinal,", "), AdoFldString(fldSpawnedItemsSeparator,", "), (EWoundCareDataType)AdoFldLong(fldWoundCareDataType, (long)wcdtNone), AdoFldLong(fldDataGroupID), AdoFldString(fldKeywordOverride), AdoFldBool(fldUseKeyword), AdoFldBool(fldUseNameForKeyword)));
							//see if there is a dropdown list associated with this element
							// (z.manning 2009-02-10 17:14) - PLID 33029 - Need to load dropdown item actions
							// (also parameterized this)
							// (z.manning 2009-08-06) - PLID 35134 - The code to load dropdown item actions assumes
							// that all records are loaded with the same EMRTableDropdownInfoT items grouped together,
							// but we previously did not specify an order by clause so I added one.
							//TES 3/15/2011 - PLID 42757 - Added GlassesOrderDataID and GlassesOrderDataName
							// (z.manning 2011-03-21 09:55) - PLID 23668 - Added autofill type
							// (z.manning 2011-09-28 11:26) - PLID 45729 - Added EmrTableDropdownStampFilterT
							// (z.manning 2011-10-12 13:15) - PLID 45728 - Added IsDefault
							// (j.jones 2012-11-26 16:51) - PLID 53144 - added EMRTableDropdownStampDefaultsT
							// (j.jones 2013-03-04 15:51) - PLID 55422 - split actions, stamp filters, and stamp defaults into their own queries
							// (j.gruber 2013-09-30 11:32) - PLID 58675 - added drop down codes, groupID
							// (j.gruber 2014-07-22 12:48) - PLID 62627 - added keyword fields
							_RecordsetPtr rs = CreateParamRecordset(
								"SELECT EMRTableDropdownInfoT.ID AS DropdownID, EMRTableDropdownInfoT.Data, EMRTableDropdownInfoT.Inactive, EMRTableDropdownInfoT.SortOrder AS DropdownSortOrder, \r\n"
								"	EMRTableDropdownInfoT.GlassesOrderDataID, EMRTableDropDownInfoT.DropDownGroupID, "
								"	CASE WHEN EmrDataT.GlassesOrderDataType = {INT} THEN GlassesCatalogDesignsT.DesignName "
								"	WHEN EmrDataT.GlassesOrderDataType = {INT} THEN GlassesCatalogMaterialsT.MaterialName "
								"	WHEN EmrDataT.GlassesOrderDataType = {INT} THEN GlassesCatalogTreatmentsT.TreatmentName "
								"	ELSE NULL END AS GlassesOrderDataName, EMRTableDropDownInfoT.UseKeyword, EMRTableDropDownInfoT.KeywordOverride "
								"FROM EMRTableDropdownInfoT \r\n"
								"LEFT JOIN EmrDataT ON EMRTableDropdownInfoT.EMRDataID = EmrDataT.ID \r\n"
								"LEFT JOIN GlassesCatalogDesignsT ON EMRTableDropdownInfoT.GlassesOrderDataID = GlassesCatalogDesignsT.ID "
								"LEFT JOIN GlassesCatalogMaterialsT ON EMRTableDropdownInfoT.GlassesOrderDataID = GlassesCatalogMaterialsT.ID "
								"LEFT JOIN GlassesCatalogTreatmentsT ON EMRTableDropdownInfoT.GlassesOrderDataID = GlassesCatalogTreatmentsT.ID "
								"WHERE EMRTableDropdownInfoT.EMRDataID = {INT} \r\n"
								"ORDER BY EMRTableDropdownInfoT.ID \r\n"
								"\r\n"
								"SELECT EMRTableDropdownInfoT.ID AS EMRTableDropdownInfoID, \r\n"
								"	EmrActionsT.ID, SourceType, SourceID, DestType, DestID, EmrActionsT.SortOrder, Popup, SpawnAsChild, EMRActionChargeDataT.Prompt, EMRActionChargeDataT.DefaultQuantity, \r\n"
								"	RemindType, RemindInterval, DeadlineType, DeadlineInterval, Notes, Priority, Task, CategoryID, \r\n"
								"	EMRActionChargeDataT.Modifier1Number, EMRActionChargeDataT.Modifier2Number, EMRActionChargeDataT.Modifier3Number, \r\n"
								"	EMRActionChargeDataT.Modifier4Number \r\n"
								//(s.dhole 7/17/2014 4:24 PM ) - PLID 62724 Added DiagCodeID_ICD10 , DiagCodeID_ICD9
								" , EMRActionDiagnosisDataT.DiagCodeID_ICD9, EMRActionDiagnosisDataT.DiagCodeID_ICD10 \r\n"
								"FROM EMRTableDropdownInfoT \r\n"
								"INNER JOIN EmrActionsT ON EmrActionsT.SourceID = EMRTableDropdownInfoT.ID \r\n"
								"	AND EmrActionsT.SourceType = {INT} AND Deleted = 0 \r\n"
								"LEFT JOIN EMRActionChargeDataT ON EMRActionsT.ID = EMRActionChargeDataT.ActionID "
								"LEFT JOIN EMRActionsTodoDataT ON EMRActionsT.ID = EMRActionsTodoDataT.ActionID "
								//(s.dhole 7/17/2014 4:24 PM ) - PLID 62724 Added DiagCodeID_ICD10 , DiagCodeID_ICD9
								" LEFT JOIN EMRActionDiagnosisDataT ON  EMRActionsT.ID =  EMRActionDiagnosisDataT.EmrActionID  "
								"WHERE EMRTableDropdownInfoT.EMRDataID = {INT} \r\n"
								"\r\n"
								"SELECT EmrTableDropdownStampFilterT.EMRTableDropdownInfoID, EmrTableDropdownStampFilterT.StampID \r\n"
								"FROM EmrTableDropdownStampFilterT \r\n"
								"INNER JOIN EMRTableDropdownInfoT ON EmrTableDropdownStampFilterT.EMRTableDropdownInfoID = EMRTableDropdownInfoT.ID\r\n"
								"WHERE EMRTableDropdownInfoT.EMRDataID = {INT} \r\n"
								"\r\n"
								"SELECT EMRTableDropdownStampDefaultsT.EMRTableDropdownInfoID, EMRTableDropdownStampDefaultsT.StampID \r\n"
								"FROM EMRTableDropdownStampDefaultsT \r\n"
								"INNER JOIN EMRTableDropdownInfoT ON EMRTableDropdownStampDefaultsT.EMRTableDropdownInfoID = EMRTableDropdownInfoT.ID \r\n"
								"WHERE EMRTableDropdownInfoT.EMRDataID = {INT} \r\n"
								"\r\n"
								"SELECT EMRTableDropDownInfoT.ID as EMRTableDropdownInfoID, EMRTableDropDownGroupID, CodeID, CodesT.Code, CodesT.Vocab, CodesT.Name as CodeName \r\n"
								"FROM EMRTableDropDownInfoT \r\n"
								"INNER JOIN EmrTableDropdownGroupCodesT ON EMRTableDropDownInfoT.DropDownGroupID = EMRTableDropDownGroupCodesT.EMRTableDropDownGroupID \r\n"
								"INNER JOIN CodesT ON EmrTableDropdownGroupCodesT.CodeID = CodesT.ID \r\n"
								"WHERE EMRTableDropDownInfoT.EMRDataID = {INT} \r\n"
								,
								godtDesign, godtMaterial, godtTreatment, AdoFldLong(fldID),
								eaoEmrTableDropDownItem, AdoFldLong(fldID),
								AdoFldLong(fldID),
								AdoFldLong(fldID), AdoFldLong(fldID));

							// (j.jones 2013-03-04 16:20) - PLID 55422 - this recordset is now broken up into three,
							// the first recordset is all the dropdown entries, second is all stamp filters, third
							// is all default stamp IDs

							//map the dropdown pointers in the array
							// (a.walling 2014-06-30 10:21) - PLID 62497 - Using unordered_map
							std::unordered_map<long, CEmrTableDropDownItem*> mapDropdownIDToPtr;

							//first load all the dropdowns
							while(!rs->eof) {
								CEmrInfoDataElement *peide = m_aryColumnDataElements.GetAt(m_aryColumnDataElements.GetSize() - 1);
								// (a.walling 2014-06-30 10:21) - PLID 62497 - ID must be set in constructor
								CEmrTableDropDownItem *pDDI = new CEmrTableDropDownItem(AdoFldLong(rs, "DropdownID", -1));
								pDDI->strData = AdoFldString(rs, "Data","");
								pDDI->nSortOrder = AdoFldLong(rs, "DropdownSortOrder",-1);
								pDDI->bInactive = AdoFldBool(rs, "Inactive",FALSE);
								pDDI->nGlassesOrderDataID = AdoFldLong(rs, "GlassesOrderDataID", -1);
								pDDI->strGlassesOrderDataName = AdoFldString(rs, "GlassesOrderDataName", "");

								// (j.gruber 2013-09-30 11:50) - PLID 58675 - load the dataID
								pDDI->nDropDownGroupID = AdoFldLong(rs, "DropDownGroupID", -1);

								// (j.gruber 2014-07-22 12:52) - PLID 62627 - Keyword fields
								pDDI->bUseKeyword = AdoFldBool(rs, "UseKeyword", FALSE);
								pDDI->strKeywordOverride = AdoFldString(rs, "KeywordOverride", "");

								peide->m_arypEMRDropDownList.Add(pDDI);															

								// (j.jones 2013-03-04 16:23) - PLID 55422 - map this pointer by dropdown ID
								mapDropdownIDToPtr.emplace(pDDI->nID, pDDI);


								rs->MoveNext();
							}

							rs = rs->NextRecordset(NULL);

							// (j.jones 2013-03-04 16:21) - PLID 55422 - now load all the actions
							while(!rs->eof) {
								long nDropdownID = AdoFldLong(rs, "EMRTableDropdownInfoID");

								//get the dropdown item
								// (a.walling 2014-06-30 10:21) - PLID 62497 - Now returns a CEmrTableDropDownItem* directly
								if(auto pDDI = mapDropdownIDToPtr[nDropdownID]) {
									EmrAction ea;
									SetActionFromFields(rs->Fields, ea);
									pDDI->aryActions.Add(ea);
								}
								else {
									//should be impossible
									ThrowNxException("Load failed to find a dropdown item for ID %li for action loading.", nDropdownID);
								}

								rs->MoveNext();
							}

							rs = rs->NextRecordset(NULL);

							// (j.jones 2013-03-04 16:21) - PLID 55422 - now load all the stamp filters
							while(!rs->eof) {
								// (z.manning 2011-10-11 09:11) - PLID 42061 - Load the stamp filter for this dropdown item.
								long nDropdownID = AdoFldLong(rs, "EMRTableDropdownInfoID");
								long nStampID = AdoFldLong(rs, "StampID");

								//get the dropdown item
								// (a.walling 2014-06-30 10:21) - PLID 62497 - Now returns a CEmrTableDropDownItem* directly
								if (auto pDDI = mapDropdownIDToPtr[nDropdownID]) {
									pDDI->aryStampFilter.push_back(nStampID);
								}
								else {
									//should be impossible
									ThrowNxException("Load failed to find a dropdown item for ID %li for the filter on stamp ID %li.", nDropdownID, nStampID);
								}

								rs->MoveNext();
							}

							rs = rs->NextRecordset(NULL);

							// (j.jones 2013-03-04 16:21) - PLID 55422 - now load all the stamp defaults
							while(!rs->eof) {
								// (z.manning 2011-10-12 15:00) - PLID 45728 - If this is a default stamp/dropdown option, let the column know.
								// (j.jones 2012-11-27 10:44) - PLID 53144  - the default value is now in a separate list
								long nDropdownID = AdoFldLong(rs, "EMRTableDropdownInfoID");
								long nStampID = AdoFldLong(rs, "StampID");
								
								//get the dropdown item
								// (a.walling 2014-06-30 10:21) - PLID 62497 - Now returns a CEmrTableDropDownItem* directly
								if (auto pDDI = mapDropdownIDToPtr[nDropdownID]) {
									pDDI->aryStampDefaults.push_back(nStampID);
								}
								else {
									//should be impossible
									ThrowNxException("Load failed to find a dropdown item for ID %li for the default for stamp ID %li.", nDropdownID, nStampID);
								}

								rs->MoveNext();
							}

							// (j.gruber 2013-09-30 11:52) - PLID 58675 - codes
							rs = rs->NextRecordset(NULL);

							// (j.gruber 2013-09-30 11:54) - PLID 58675 - now load all the codes
							while(!rs->eof) {																								   
								long nDropdownID = AdoFldLong(rs, "EMRTableDropdownInfoID");
								long nCodeID = AdoFldLong(rs, "CodeID");
								CString strCode = AdoFldString(rs, "Code");
								CString strVocab = AdoFldString(rs, "Vocab");
								CString strCodeName = AdoFldString(rs, "CodeName");

								CEMRCode code(nCodeID, strVocab, strCode, strCodeName);
								
								//get the dropdown item
								// (a.walling 2014-06-30 10:21) - PLID 62497 - Now returns a CEmrTableDropDownItem* directly
								if (auto pDDI = mapDropdownIDToPtr[nDropdownID]) {
									pDDI->aryCodes.Add(code);
								}
								else {
									//should be impossible
									ThrowNxException("Load failed to find a dropdown item for ID %li for code %li.", nDropdownID, nCodeID);
								}

								rs->MoveNext();
							}


							rs->Close();
						} 
						else {
							// (z.manning 2009-01-15 15:18) - PLID 32724 - Added InputMask
							// (j.jones 2011-03-08 12:25) - PLID 42282 - added EMCodeCategoryID
							//TES 3/11/2011 - PLID 42757 - Added Glasses Order data
							// (r.gonet 08/03/2012) - PLID 51735 - Added Wound Care Data Type
							// (j.jones 2012-09-19 12:22) - PLID 52316 - added ParentLabelID, the pointer always defaults to NULL, will be assigned later
							// (j.gruber 2014-07-17 13:39) - PLID 62621 - keyword fields
							// (j.gruber 2014-12-05 15:37) - PLID 64361 - Load the new values for UseNameForKeyword
							m_aryDataElements.Add(new CEmrInfoDataElement(AdoFldLong(fldID), AdoFldString(fldData), AdoFldLong(fldSortOrder), AdoFldBool(fldIsDefault), AdoFldBool(fldInactive), AdoFldLong(fldListType), AdoFldBool(fldIsGrouped), AdoFldString(fldLongForm), AdoFldBool(fldIsLabel), AdoFldLong(fldParentLabelID, -1), AdoFldString(fldParentLabelName, ""), NULL, AdoFldBool(fldUseEMCoding), AdoFldLong(fldEMCodeCategoryID, -1), strFormula, AdoFldByte(fldDecimalPlaces,2), AdoFldString(fldInputMask,""), AdoFldByte(fldListSubType,lstDefault), AdoFldBool(fldAutoAlphabetizeDropdown), AdoFldString(fldBOLDCode), (EEmrTableAutoNumberType)AdoFldByte(fldAutoNumberType,etantInvalid), AdoFldString(fldAutoNumberPrefix,""), (GlassesOrderDataType)AdoFldLong(fldGlassesOrderDataType,godtInvalid), AdoFldLong(fldGlassesOrderDataID,-1), (EmrTableAutofillType)AdoFldByte(fldAutofillType,etatNone), AdoFldLong(fldFlags,0), AdoFldString(fldDropdownSeparator, ", "), AdoFldString(fldDropdownSeparatorFinal,", "), AdoFldString(fldSpawnedItemsSeparator,", "), (EWoundCareDataType)AdoFldLong(fldWoundCareDataType, (long)wcdtNone), AdoFldLong(fldDataGroupID), AdoFldString(fldKeywordOverride), AdoFldBool(fldUseKeyword), AdoFldBool(fldUseNameForKeyword)));
						}
						prs->MoveNext();
					}
				}
	
				// Then get all the actions for the above data elements (loaded from the 'data element actions' recordset)
				{
					prs = prs->NextRecordset(NULL);
					if (NULL == prs) {
						// (c.haag 2006-02-15 09:04) - PLID 19051 - If this is NULL, something bad happened
						AfxThrowNxException("CEmrItemEntryDlg::Load: Failed to load NextRecordset!");
					}
					FieldsPtr pflds = prs->GetFields();
					FieldPtr fldID = pflds->GetItem("ID");
					FieldPtr fldSourceID = pflds->GetItem("SourceID");
					FieldPtr fldDestType = pflds->GetItem("DestType");
					FieldPtr fldDestID = pflds->GetItem("DestID");
					FieldPtr fldSortOrder = pflds->GetItem("SortOrder");
					FieldPtr fldPopup = pflds->GetItem("Popup");
					FieldPtr fldSpawnAsChild = pflds->GetItem("SpawnAsChild");
					

					

					long nLastFoundIndex = -1;
					while (!prs->eof) {
						// First get the ID and find our corresponding entry in the m_aryDataElements array
						long nIndex = m_aryDataElements.FindDataElement(AdoFldLong(fldSourceID), nLastFoundIndex + 1);
						if (nIndex != -1) {
							// Good, we found it (we better have!!) so we can add this action to that data element's action array
							EmrAction ea;
							ea.nID = AdoFldLong(fldID);
							ea.eaoSourceType = eaoEmrDataItem;
							ea.nSourceID = AdoFldLong(fldSourceID);
							ea.eaoDestType = (EmrActionObject)AdoFldLong(fldDestType);
							ea.nDestID = AdoFldLong(fldDestID);
							ea.nSortOrder = AdoFldLong(fldSortOrder);
							ea.bPopup = AdoFldBool(fldPopup);
							ea.bSpawnAsChild = AdoFldBool(fldSpawnAsChild);
							//(s.dhole 7/17/2014 4:24 PM ) - PLID 62724 Added DiagCodeID_ICD10 , DiagCodeID_ICD9
							if (ea.eaoDestType == eaoDiagnosis ) {
								//(s.dhole 7/17/2014 4:45 PM ) - PLID 62724
								ea.diaDiagnosis.nDiagCodeID_ICD9 = AdoFldLong(pflds, "DiagCodeID_ICD9", -1);
								ea.diaDiagnosis.nDiagCodeID_ICD10 = AdoFldLong(pflds, "DiagCodeID_ICD10", -1);

							}
							//DRT 1/10/2007 - PLID 24181 - We now have a separate table for extra charge information.  This only
							//	applies to eaoCpt type items.
							if(ea.eaoDestType == eaoCpt) {
								//If you get a BadVariableType on either of the next fields, you have bad data.  Every EMRActionsT record
								//	with a DestType of 1 must have a corresponding EMRActionChargeDataT record.
								//However, in anticipation of such a possible event, I've written this code to gracefully handle bad data, 
								//	you'll get the bad var type error, but the prompt and default qty will be set to their default values, 
								//	and program execution will continue to load the action.
								try {
									ea.bPrompt = AdoFldBool(pflds, "Prompt", 0);
									ea.dblDefaultQuantity = AdoFldDouble(pflds, "DefaultQuantity");
								} NxCatchAllCall("Error in LoadActionInfo : EMRActionChargeData", {	ea.bPrompt = FALSE;	ea.dblDefaultQuantity = 1.0; }	);
								ea.strMod1 = AdoFldString(pflds, "Modifier1Number", "");
								ea.strMod2 = AdoFldString(pflds, "Modifier2Number", "");
								ea.strMod3 = AdoFldString(pflds, "Modifier3Number", "");
								ea.strMod4 = AdoFldString(pflds, "Modifier4Number", "");
							}
							else if (ea.eaoDestType == eaoTodo) {
								// (c.haag 2008-06-20 10:39) - PLID 30221 - Load EMR todo action data
								ea.nDestID = ea.nID;
								ea.nTodoRemindType = AdoFldLong(pflds, "RemindType", -2);
								ea.nTodoRemindInterval = AdoFldLong(pflds, "RemindInterval", -2);
								ea.nTodoDeadlineType = AdoFldLong(pflds, "DeadlineType", -2);
								ea.nTodoDeadlineInterval = AdoFldLong(pflds, "DeadlineInterval", -2);
								ea.strTodoNotes = AdoFldString(pflds, "Notes", "");
								ea.nTodoPriority = AdoFldByte(pflds, "Priority", -2);
								ea.strTodoMethod = AdoFldString(pflds, "Task", "");
								ea.nTodoCategoryID = AdoFldLong(pflds, "CategoryID", -2);
								if (ea.nTodoRemindType > -2) {
									FillEmrActionWithTodoAssignTos(GetRemoteData(), ea);
								} else {
									// If we get here, it can only mean that this is not a todo action because RemindType cannot be NULL in data.
									// So, don't bother trying to load AssignTo values.
								}
							}
							// (j.jones 2007-07-16 16:16) - PLID 26694 - bOnePerEmn is a value of EmrAction for the
							// purposes of efficiency, but is not a property of the action, and isn't needed here
							// for future saving purposes.

							m_aryDataElements.GetAt(nIndex)->m_arActions.Add(ea);
							// Remember this is now the "last index that we found"
							nLastFoundIndex = nIndex;
						} else {
							// How could it not be found?  The SourceID comes from a recordset that was based on the fact 
							// that the SourceID was one of the data elements that we JUST added to m_aryDataElements!
							ASSERT(FALSE);
						}
						prs->MoveNext();
					}
				}
			}

			// (j.gruber 2013-10-01 13:58) - PLID 58674 - EMRDataGroupCodes
			{
				prs = prs->NextRecordset(NULL);
				if (NULL == prs) {						
					AfxThrowNxException("CEmrItemEntryDlg::Load: Failed to load NextRecordset for EMRDataGroupCodes!");
				}

				long nLastFoundIndex = -1;
				long nLastFoundColIndex = -1;
				while (!prs->eof)
				{
					long nEMRDataID = AdoFldLong(prs->Fields, "EMRDataID");
					long nListType = AdoFldLong(prs->Fields, "ListType");
					long nRowIndex = -1;
					long nColIndex = -1;
					if (nListType < 3) {
						//its a row or select list
						nRowIndex = m_aryDataElements.FindDataElement(nEMRDataID, nLastFoundIndex + 1);
						if (nRowIndex != -1) {
							CEMRCode code(AdoFldLong(prs->Fields, "CodeID"), AdoFldString(prs->Fields, "Vocab"), AdoFldString(prs->Fields, "code"), AdoFldString(prs->Fields, "CodeName"));
							m_aryDataElements.GetAt(nRowIndex)->m_aryCodes.Add(code);
						}
						else {
							ASSERT(FALSE);
						}
					}
					else {
						nColIndex = m_aryColumnDataElements.FindDataElement(nEMRDataID, nLastFoundColIndex + 1);
						if (nColIndex != -1) {
							CEMRCode code(AdoFldLong(prs->Fields, "CodeID"), AdoFldString(prs->Fields, "Vocab"), AdoFldString(prs->Fields, "code"), AdoFldString(prs->Fields, "CodeName"));
							m_aryColumnDataElements.GetAt(nColIndex)->m_aryCodes.Add(code);
						}
						else
						{
							ASSERT(FALSE);
						}
					}
					
					nLastFoundIndex = nRowIndex;
					nLastFoundColIndex = nColIndex;
					prs->MoveNext();
				}

			}

			//Hot spot data.  Pretty much the same as data elements above
			{
				//DRT 1/17/2008 - PLID 28602 - Next get the image hotspot info
				{
					m_aryLastSavedHotSpots.RemoveAll();

					prs = prs->NextRecordset(NULL);
					if (NULL == prs) {
						// (c.haag 2006-02-15 09:04) - PLID 19051 - If this is NULL, something bad happened
						AfxThrowNxException("CEmrItemEntryDlg::Load: Failed to load NextRecordset!");
					}

					//Loop through all the image hotspot data
					while (!prs->eof) {
						long nID = AdoFldLong(prs, "ID");
						CString strData = AdoFldString(prs, "Data", "");

						//Create a new hotspot
						CEMRHotSpot *pSpot = new CEMRHotSpot();
						pSpot->SetID(nID);
						pSpot->LoadData(strData);
						//TES 2/9/2010 - PLID 37223 - Load the anatomic location information.
						//TES 2/10/2010 - PLID 37296 - Added names, for auditing.
						pSpot->SetOriginalAnatomicLocation(AdoFldLong(prs, "AnatomicLocationID", -1), AdoFldString(prs, "AnatomicLocation",""));
						pSpot->SetOriginalAnatomicQualifier(AdoFldLong(prs, "AnatomicQualifierID",-1), AdoFldString(prs, "AnatomicQualifier",""));
						pSpot->SetOriginalSide((AnatomySide)AdoFldLong(prs, "AnatomySide"));
						// (z.manning 2011-07-22 16:22) - PLID 44676 - Added ImageHotSpotID
						pSpot->Set3DHotSpotID(AdoFldShort(prs, "ImageHotSpotID", -1));

						//Put it in our current array
						m_aryLastSavedHotSpots.Add(pSpot);

						prs->MoveNext();
					}
				}

				//Part 2 -- Get the actions for the hotspots
				{
					prs = prs->NextRecordset(NULL);
					if (NULL == prs) {
						// (c.haag 2006-02-15 09:04) - PLID 19051 - If this is NULL, something bad happened
						AfxThrowNxException("CEmrItemEntryDlg::Load: Failed to load NextRecordset!");
					}
					FieldsPtr pflds = prs->GetFields();
					FieldPtr fldID = pflds->GetItem("ID");
					FieldPtr fldSourceID = pflds->GetItem("SourceID");
					FieldPtr fldDestType = pflds->GetItem("DestType");
					FieldPtr fldDestID = pflds->GetItem("DestID");
					FieldPtr fldSortOrder = pflds->GetItem("SortOrder");
					FieldPtr fldPopup = pflds->GetItem("Popup");
					FieldPtr fldSpawnAsChild = pflds->GetItem("SpawnAsChild");
					while (!prs->eof) {
						// First get the ID and find our corresponding entry in the array of hotspots
						CEMRHotSpot *pSpot = NULL;
						for(int i = 0; i < m_aryLastSavedHotSpots.GetSize() && pSpot == NULL; i++) {
							if(m_aryLastSavedHotSpots.GetAt(i)->GetID() == AdoFldLong(fldSourceID)) {
								pSpot = m_aryLastSavedHotSpots.GetAt(i);
							}
						}

						if (pSpot != NULL) {
							// Good, we found it (we better have!!) so we can add this action to that hot spot's action array
							EmrAction ea;
							// (z.manning 2009-02-12 10:18) - PLID 33029 - I moved the code for setting an action
							// object to a utility function.
							SetActionFromFields(prs->Fields, ea);

							//Set the action to the hotspot
							pSpot->AddOriginalAction(ea);
						} else {
							// How could it not be found?  The SourceID comes from a recordset that was based on the fact 
							// that the SourceID was one of the data elements that we JUST added to our array!
							ASSERT(FALSE);
						}
						prs->MoveNext();
					}
				}

			}

			// (c.haag 2008-07-17 16:03) - PLID 30724 - EMR problem actions. The structure is one-action-to-many-problems,
			// so we will need to map each one to an action
			{
				prs = prs->NextRecordset(NULL);
				if (NULL == prs) {
					AfxThrowNxException("CEmrItemEntryDlg::Load: Failed to load problem action recordset!");
				}

				// Loop through the problem actions and associate them with EMR actions
				while (!prs->eof) {

					// Read in the problem action
					EmrProblemAction epa;
					const long nEmrActionID = AdoFldLong(prs, "EmrActionID");
					const long nSourceID = AdoFldLong(prs, "SourceID");
					epa.nID = AdoFldLong(prs, "ID");
					epa.bSpawnToSourceItem = AdoFldBool(prs, "SpawnToSourceItem");
					epa.nStatus = AdoFldLong(prs, "DefaultStatus");
					epa.strDescription = AdoFldString(prs, "DefaultDescription");
					epa.nSNOMEDCodeID = AdoFldLong(prs, "SNOMEDCodeID", -1); // (c.haag 2014-07-22) - PLID 62789
					epa.bDoNotShowOnCCDA = AdoFldBool(prs, "DoNotShowOnCCDA", FALSE);// (s.tullis 2015-02-23 17:47) - PLID 64749 
					// (r.gonet 2015-03-10 14:48) - PLID 65013 - Added DoNotShowOnProblemPrompt.
					epa.bDoNotShowOnProblemPrompt = AdoFldBool(prs, "DoNotShowOnProblemPrompt", FALSE);
					// Now associate it with the Emr action. 
					int i;
					BOOL bFound = FALSE;

					// First, search on data element actions
					long nIndex = m_aryDataElements.FindDataElement(nSourceID, 0);
					if (nIndex != -1) {
						MFCArray<EmrAction>& arActions = m_aryDataElements.GetAt(nIndex)->m_arActions;
						const int nActions = arActions.GetSize();
						for (i=0; i < nActions && !bFound; i++) {
							if (arActions[i].nID == nEmrActionID) {
								arActions[i].aProblemActions.push_back(epa);
								bFound = TRUE;
							}
						}
					}
					// Now search on hot spot actions
					if (!bFound) {
						for (int nSpot = 0; nSpot < m_aryLastSavedHotSpots.GetSize() && !bFound; nSpot++) {
							if(m_aryLastSavedHotSpots.GetAt(nSpot)->GetID() == nSourceID) {
								MFCArray<EmrAction>* parOriginalActions = m_aryLastSavedHotSpots.GetAt(nSpot)->GetOriginalActionArray();
								MFCArray<EmrAction>* parCurrentActions = m_aryLastSavedHotSpots.GetAt(nSpot)->GetCurrentActionArray();
								const int nActions = parCurrentActions->GetSize();
								for (i=0; i < nActions && !bFound; i++) {
									EmrAction eaOrig = parOriginalActions->GetAt(i);
									EmrAction eaCur = parCurrentActions->GetAt(i);
									if (eaOrig.nID == nEmrActionID) {
										eaOrig.aProblemActions.push_back(epa);
										parOriginalActions->SetAt(i, eaOrig);
										eaCur.aProblemActions.push_back(epa);
										parCurrentActions->SetAt(i, eaCur);
										bFound = TRUE;
									}
								}
							}
						}
					}
					// Now search on item actions
					if (!bFound) {
						MFCArray<EmrAction>& arActions = m_arActions;
						const int nActions = arActions.GetSize();
						for (i=0; i < nActions && !bFound; i++) {
							if (arActions[i].nID == nEmrActionID) {
								arActions[i].aProblemActions.push_back(epa);
								bFound = TRUE;
							}
						}
					}
					
					// (z.manning 2009-02-11 10:38) - PLID 33029 - Also search dropdown item actions
					if(!bFound) {
						for(int nColIndex = 0; nColIndex < m_aryColumnDataElements.GetSize(); nColIndex++) {
							CEmrInfoDataElement *peide = m_aryColumnDataElements.GetAt(nColIndex);
							// (a.walling 2014-06-30 10:21) - PLID 62497 - Now returns a CEmrTableDropDownItem* directly
							if (CEmrTableDropDownItem *pddi = peide->m_arypEMRDropDownList.FindDropdownElement(nSourceID)) {
								for(i = 0; i < pddi->aryActions.GetSize(); i++) {
									if(pddi->aryActions.GetAt(i).nID == nEmrActionID) {
										pddi->aryActions.GetAt(i).aProblemActions.push_back(epa);
										bFound = TRUE;
									}
								}
							}
						}
					}

					prs->MoveNext();
				}
			}

			// (c.haag 2011-03-14) - PLID 42813 - Load common lists. We just take all the fields and
			// read them in; nothing fancy.
			{
				prs = prs->NextRecordset(NULL);
				if (NULL == prs) {
					AfxThrowNxException("CEmrItemEntryDlg::Load: Failed to load common lists!");
				}

				// Load the lists
				m_SavedCommonListCollection.Clear();
				m_SavedCommonListCollection.LoadLists(prs);
			}

			// (c.haag 2011-03-14) - PLID 42813 - Load common list items. We just take all the fields and
			// read them in; nothing fancy. Note that all common list items are loaded with EmrDataID's
			// and not with CEmrInfoDataElements.
			{
				prs = prs->NextRecordset(NULL);
				if (NULL == prs) {
					AfxThrowNxException("CEmrItemEntryDlg::Load: Failed to load common list items!");
				}

				// Load the items
				m_SavedCommonListCollection.LoadListItems(prs);
			}

			// Now copy the saved list to the current list
			m_CommonListCollection = m_SavedCommonListCollection;

			// (z.manning 2011-10-24 11:36) - PLID 46082 - Load stamp exclusions
			{
				prs = prs->NextRecordset(NULL);
				if (prs == NULL) {
					AfxThrowNxException("CEmrItemEntryDlg::Load: Failed to load stamp exclusions!");
				}

				m_StampExclusions.LoadFromRecordset(prs);
				m_SavedStampExclusions = m_StampExclusions;
			}

			// (j.gruber 2013-09-20 13:48) - PLID 58676 - cell codes
			{
				prs = prs->NextRecordset(NULL);
				if (prs == NULL) {
					AfxThrowNxException("CEmrItemEntryDlg::Load: Failed to load table cell codes!");
				}

				m_TableCellCodes.Load(prs);

				//copy the map
				m_SavedCellCodes = m_TableCellCodes;

			}

		} else {
			// We expected a record with the given ID, but we didn't get one.  We have to fail
			ThrowNxException("CEmrItemEntryDlg::Load: Could not find EMR item for ID %li!", m_nID);
		}
	} else {
		// Negative 1 id indicates to load the defaults
		m_strName = "[Enter a name for this item]";
		// (z.manning 2010-02-09 15:52) - PLID 37228 - We now have a variable for the default type
		m_nDataType = m_eitDefaultDataType; // Defaulting to multi-select list, because I think that's the most common.
		m_DataSubType = eistNone; // (c.haag 2007-01-29 15:20) - PLID 24423 - Added support for DataSubType
		m_bRememberForPatient = FALSE;
		m_bRememberForEMR = FALSE;	// (j.jones 2008-09-22 13:04) - PLID 31476 - added
		m_bTableRowsAsFields = FALSE; // (c.haag 2008-10-16 09:55) - PLID 31708 - Added
		m_bAutoAlphabetizeListData = FALSE;		
		if(m_bIsSmartStampTable) {
			//TES 2/18/2010 - PLID 37234 - Additionally, we want to default the smart stamp sentence format to something useful.  I set the default
			// here rather than in data so as not to have to make a .mod if we decide to change it.
			m_strLongForm = "<Type> on <Location>, Description: <Description>, Quantity: <Quantity>";
			m_nDataFormat = emsfList;
		}
		else {
			m_strLongForm = "<Data>";
			m_nDataFormat = emsfText;
		}
		m_strDataSeparator = ", ";
		m_strDataSeparatorFinal = " and ";

		// (a.walling 2009-05-28 15:14) - PLID 34389
		m_nEmrDataCodeID = -1;
		m_strEmrDataCodeUnit.Empty();

		// (z.manning 2010-02-09 14:54) - PLID 37228
		m_bEnableSmartStamps = FALSE;
		m_varSmartStampTableMasterID.vt = VT_NULL;

		m_bImageSpecified = FALSE;
		m_strImagePath = "";
		m_strDefaultText = "";
		m_dblSliderMin = 0.0;
		m_dblSliderMax = 10.0;
		m_dblSliderInc = 1.0;
		m_arynCategoryIDs.RemoveAll();
		m_arActions.RemoveAll();
		m_aryDataElements.RemoveAllAndFreeEntries();
		m_aryColumnDataElements.RemoveAllAndFreeEntries();
		// (j.jones 2007-08-14 16:58) - PLID 27052 - added E/M Category
		m_nEMCodeCategoryID = -1;
		// (j.jones 2011-03-08 12:25) - PLID 42282 - added m_eEMCodeUseTableCategories
		m_eEMCodeUseTableCategories = emcutcNone;
		// (j.jones 2007-08-14 16:58) - PLID 27053 - added E/M Code Type
		m_bUseEMCoding = FALSE;
		m_emctEMCodingType = emctUndefined;
		// (a.walling 2008-06-30 14:52) - PLID 30570 - Preview Pane flags
		m_nPreviewFlags = 0;
		//TES 3/11/2011 - PLID 42757 - Added Glasses Order data
		m_bHasGlassesOrderData = FALSE;
		m_GlassesOrderLens = golInvalid;
		m_nInfoFlags = 0;
		//TES 4/6/2012 - PLID 49367 - Added Cotnact Lens data
		m_bHasContactLensData = FALSE;
		m_bSavedHasContactLensData = FALSE;
		// (r.gonet 08/03/2012) - PLID 51735 - Added UseWithWoundCareCoding
		m_bUseWithWoundCareCoding = FALSE;
	}
}

CString AsStringCleanDouble(double dbl)
{
	CString strNumber;
	strNumber.Format("%f", dbl);
	strNumber.TrimRight("0");
	strNumber.TrimRight(".");
	return strNumber;
}

// Reflect the local variables on screen
void CEmrItemEntryDlg::ReflectState()
{
	// Name
	SetDlgItemText(IDC_ITEM_NAME, m_strName);
	
	// Category
	m_arynCurCategoryIDs.RemoveAll();
	m_arynCurCategoryIDs.Append(m_arynCategoryIDs);
	m_pdlCategoryCombo->TrySetSelByColumn(0, (long)(m_arynCategoryIDs.GetSize() == 1 ? m_arynCategoryIDs.GetAt(0) : 
		(m_arynCategoryIDs.GetSize() == 0 ? clsrvNoCategory : clsrvMultiCategory)));

	// (j.jones 2011-03-08 12:25) - PLID 42282 - added m_eEMCodeUseTableCategories
	if(m_nDataType == 7 && m_eEMCodeUseTableCategories != emcutcNone) {
		//tables might have a special category option, but it is just a menu item in the category list

		//make sure these options exist
		EnsureEMCodeUseTableCategoriesListOptions(TRUE);
		
		NXDATALIST2Lib::IRowSettingsPtr pRow = m_pdlEMCategoryCombo->SetSelByColumn(emcccUseTableCategories, (long)m_eEMCodeUseTableCategories);
		//ASSERT if this fails, it means the rows had not yet been added
		ASSERT(pRow != NULL);
	}
	else {
		//just use the regular category ID

		// (j.jones 2007-08-14 17:42) - PLID 27052 - added E/M Category
		m_pdlEMCategoryCombo->SetSelByColumn(emcccID, m_nEMCodeCategoryID);
	}

	// (j.jones 2007-08-14 17:42) - PLID 27053 - added E/M Coding
	CheckDlgButton(IDC_CHECK_USE_FOR_EM_CODING, m_bUseEMCoding);
	//do not need to call ReflectEMCodeInterface() because ReflectDataType() will do that for us

	// Data type
	CheckDlgButton(IDC_RADIO_TEXT_SELECT, m_nDataType == 1 ? BST_CHECKED : BST_UNCHECKED);
	CheckDlgButton(IDC_RADIO_LIST_SELECT, m_nDataType == 2 ? BST_CHECKED : BST_UNCHECKED);
	CheckDlgButton(IDC_RADIO_LIST_MULTISELECT, m_nDataType == 3 ? BST_CHECKED : BST_UNCHECKED);
	CheckDlgButton(IDC_RADIO_IMAGE, m_nDataType == 4 ? BST_CHECKED : BST_UNCHECKED);
	CheckDlgButton(IDC_RADIO_SLIDER, m_nDataType == 5 ? BST_CHECKED : BST_UNCHECKED);
	CheckDlgButton(IDC_RADIO_NARRATIVE, m_nDataType == 6 ? BST_CHECKED : BST_UNCHECKED);
	CheckDlgButton(IDC_RADIO_TABLE, m_nDataType == 7 ? BST_CHECKED : BST_UNCHECKED);
	CheckDlgButton(IDC_CHECK_ONE_PER_EMN, m_bOnePerEmn ? BST_CHECKED : BST_UNCHECKED);
	CheckDlgButton(IDC_CHECK_EMRINFO_INACTIVE, m_bInactive ? BST_CHECKED : BST_UNCHECKED);

	//TES 2/18/2010 - PLID 37234 - We need to set this before calling ReflectDataType(), as it will affect which controls are visible.
	if(m_bIsSmartStampTable) {
		// (j.jones 2010-02-26 09:13) - PLID 37231 - the remember settings are not editable on a SmartStamp Table
		GetDlgItem(IDC_REMEMBER_FOR_PATIENT)->EnableWindow(FALSE);
		GetDlgItem(IDC_REMEMBER_FOR_EMR)->EnableWindow(FALSE);
	}

	//TES 3/11/2011 - PLID 42757 - Added Glasses Order data
	//TES 4/6/2012 - PLID 49367 - Tables can switch between Glasses Order Data and Contact Lens Data
	if(m_nDataType == 7) {
		CheckDlgButton(IDC_ASSOCIATE_WITH_GLASSES_ORDER_OR_CL, (m_bHasGlassesOrderData || m_bHasContactLensData) ? BST_CHECKED : BST_UNCHECKED);
		if(m_bHasContactLensData) {
			m_nxlGOCLToggle.SetText("Contact Lens Data");
		}
		else {
			m_nxlGOCLToggle.SetText("Glasses Order Data");
		}
	}
	else {
		CheckDlgButton(IDC_ASSOCIATE_WITH_GLASSES_ORDER, m_bHasGlassesOrderData ? BST_CHECKED : BST_UNCHECKED);
	}
	
	ReflectGlassesOrderCheck();
	m_pdlGlassesOrderLens->SetSelByColumn(golcCode, (long)m_GlassesOrderLens);

	// (r.gonet 08/03/2012) - PLID 51735 - Added UseWithWoundCareCoding
	if(m_nDataType == 7) {
		CheckDlgButton(IDC_USE_WITH_WOUND_CARE_CALC, m_bUseWithWoundCareCoding ? BST_CHECKED : BST_UNCHECKED);
	}

	ReflectDataType();

	// (j.jones 2007-08-14 17:42) - PLID 27053 - added E/M Code Type
	//The code type combo is not populated until ReflectEMCodeInterface() is done,
	//which occurs within ReflectDataType(). Even then, it will only be populated
	//if E/M Coding is in use for this item.
	if(m_bUseEMCoding) 
		m_pdlEMCodeTypeCombo->SetSelByColumn(emctcID, (long)m_emctEMCodingType);
	//ReflectDataElementList() is called later, and will show/hide the E/M column
	//for a table or or column as needed

	// Actions (store locally in CURRENT member variable since the on-screen control can't store it)
	m_arCurActions.RemoveAll();
	for(int i = 0; i < m_arActions.GetSize(); i++) m_arCurActions.Add(m_arActions[i]);

	// (j.jones 2008-09-22 13:03) - PLID 31476 - added "remember per EMR",
	// which is exclusive from remember for patient, and they should never
	// both be checked at the same time
	// (j.jones 2010-02-26 09:13) - PLID 37231 - if this is a SmartStamp Table
	// loaded from the SmartStamp Image, we may be told to change these settings
	BOOL bRememberForPatient = m_bRememberForPatient;
	BOOL bRememberForEMR = m_bRememberForEMR;

	if(m_bIsSmartStampTable) {
		bRememberForPatient = m_bSmartStampImage_RememberForPatient;
		bRememberForEMR = m_bSmartStampImage_RememberForEMR;
	}

	if(bRememberForPatient) {
		m_checkRememberPerPatient.SetCheck(TRUE);
		m_checkRememberPerEMR.SetCheck(FALSE);

		//just incase we were to have bad data and both were true, make the other false
		bRememberForEMR = FALSE;
	}
	else if(bRememberForEMR) {
		m_checkRememberPerPatient.SetCheck(FALSE);
		m_checkRememberPerEMR.SetCheck(TRUE);

		//just incase we were to have bad data and both were true, make the other false
		bRememberForPatient = FALSE;
	}
	else {
		m_checkRememberPerPatient.SetCheck(FALSE);
		m_checkRememberPerEMR.SetCheck(FALSE);
	}

	// Auto alphabetize list data items
	CheckDlgButton(IDC_AUTO_ALPHABETIZE_LIST_DATA, m_bAutoAlphabetizeListData ? BST_CHECKED : BST_UNCHECKED);

	// (c.haag 2008-10-21 15:45) - PLID 31708 - Table flipping
	CheckDlgButton(IDC_TABLE_ROWS_AS_FIELDS, m_bTableRowsAsFields ? BST_CHECKED : BST_UNCHECKED);
	OnTableRowsAsFields(); // Update the row/column labels

	// Sentence format
	SetDlgItemText(IDC_SENTENCE, m_strLongForm);

	// Data Format
	CheckDlgButton(IDC_DATA_FORMAT_TEXT, m_nDataFormat == 0 ? BST_CHECKED : BST_UNCHECKED);
	CheckDlgButton(IDC_DATA_FORMAT_BULLET, m_nDataFormat == 1 ? BST_CHECKED : BST_UNCHECKED);
	CheckDlgButton(IDC_DATA_FORMAT_NUMBER, m_nDataFormat == 2 ? BST_CHECKED : BST_UNCHECKED);
	CheckDlgButton(IDC_DATA_FORMAT_LIST, m_nDataFormat == 3 ? BST_CHECKED : BST_UNCHECKED);
	OnDataFormatSelected();

	// Data format if text (only applicable if IDC_DATA_FORMAT_TEXT is checked)
	SetDlgItemText(IDC_DATA_FORMAT_SEPARATOR, m_strDataSeparator);
	SetDlgItemText(IDC_DATA_FORMAT_SEPARATOR_FINAL, m_strDataSeparatorFinal);

	// (a.walling 2009-05-28 15:15) - PLID 34389
	m_nxeditDataUnit.SetWindowText(m_strEmrDataCodeUnit);
	m_dlEmrDataCode->WaitForRequery(NXDATALIST2Lib::dlPatienceLevelWaitIndefinitely);
	m_dlEmrDataCode->SetSelByColumn(lcID, m_nEmrDataCodeID);
	NXDATALIST2Lib::IRowSettingsPtr pCurrentDataCodeRow = m_dlEmrDataCode->GetCurSel();
	if (pCurrentDataCodeRow == NULL) {
		_RecordsetPtr prsDataCode = CreateParamRecordset("SELECT * FROM EmrDataCodesT WHERE ID = {INT}", m_nEmrDataCodeID);
		if (!prsDataCode->eof) { 
			pCurrentDataCodeRow = m_dlEmrDataCode->GetNewRow();

			pCurrentDataCodeRow->PutValue(lcID, m_nEmrDataCodeID);
			pCurrentDataCodeRow->PutValue(lcCode, prsDataCode->Fields->Item["Code"]->Value);
			pCurrentDataCodeRow->PutValue(lcDescription, prsDataCode->Fields->Item["Description"]->Value);
			pCurrentDataCodeRow->PutValue(lcDefaultUnit, prsDataCode->Fields->Item["DefaultUnit"]->Value);
			pCurrentDataCodeRow->PutValue(lcVital, prsDataCode->Fields->Item["Vital"]->Value);

			m_dlEmrDataCode->PutCurSel(m_dlEmrDataCode->AddRowSorted(pCurrentDataCodeRow, NULL));
		}
	}

	// (a.walling 2008-06-30 15:32) - PLID 30570 - Update the preview pane flags checkboxes
	// (j.armen 2013-01-02 16:37) - PLID 54412 - Added Hide Item on iPad
	CheckDlgButton(IDC_CHECK_HIDE_TITLE_ON_PREVIEW_PANE, (m_nPreviewFlags & epfHideTitle) ? BST_CHECKED : BST_UNCHECKED);
	CheckDlgButton(IDC_CHECK_HIDE_ITEM_ON_PREVIEW_PANE, (m_nPreviewFlags & epfHideItem) ? BST_CHECKED : BST_UNCHECKED);
	CheckDlgButton(IDC_CHECK_HIDE_IF_INDIRECTLY_ON_NARRATIVE, (m_nPreviewFlags & epfHideIfIndirect) ? BST_CHECKED : BST_UNCHECKED);
	CheckDlgButton(IDC_CHECK_HIDE_ITEM_ON_IPAD, (m_nPreviewFlags & epfHideOnIPad) ? BST_CHECKED : BST_UNCHECKED);

	// List of templates this item is used on; note, this is a load-only item, so no member variable is necessary
	// (c.haag 2007-09-14 17:58) - PLID 27395 - Don't do this for new items
	if (m_nEmrInfoMasterID != -1) {

		CString strTemplateFrom, strTemplateWhere;
		
		// All templates that this is used on, or that have things that spawn this item.

		//TES 12/7/2006 - PLID 23724 - Updated to reflect new data structure, including that DestID now means EmrInfoMasterT.ID for eaoEmrItem

		// (j.jones 2008-06-04 12:22) - PLID 29686 - improved the speed of this query, and also updated the from
		// clause through code so we could still use the EMR action enumerations

		strTemplateFrom.Format("EmrTemplateT WITH(NOLOCK) "
			"LEFT JOIN EmrCollectionT WITH(NOLOCK) ON EmrTemplateT.CollectionID = EmrCollectionT.ID "
			"INNER JOIN EMRTemplateDetailsT WITH(NOLOCK) ON EMRTemplateT.ID = EMRTemplateDetailsT.TemplateID "
			"INNER JOIN EmrInfoMasterT WITH(NOLOCK) ON EMRTemplateDetailsT.EmrInfoMasterID = EmrInfoMasterT.ID "
			"LEFT JOIN (SELECT SourceID, DestID FROM EMRActionsT WITH(NOLOCK) "
			"	WHERE SourceType = %li AND DestType = %li AND Deleted = 0) AS EMRActionsT1 "
			"	ON EmrInfoMasterT.ActiveEmrInfoID = EMRActionsT1.SourceID "
			"LEFT JOIN EMRDataT WITH(NOLOCK) ON EmrInfoMasterT.ActiveEmrInfoID = EMRDataT.EMRInfoID "
			"LEFT JOIN (SELECT SourceID, DestID FROM EMRActionsT WITH(NOLOCK) "
			"	WHERE SourceType = %li AND DestType = %li AND Deleted = 0) AS EMRActionsT2 "
			"	ON EMRDataT.ID = EMRActionsT2.SourceID ",
			eaoEmrItem, eaoEmrItem, eaoEmrDataItem, eaoEmrItem);

		strTemplateWhere.Format("EMRTemplateT.Deleted = 0 "
			"AND ("
			"	EMRActionsT1.DestID = %li "
			"	OR EMRActionsT2.DestID = %li "
			"	OR EMRTemplateDetailsT.EMRInfoMasterID = %li "
			") "
			"AND (EmrCollectionT.ID IS NULL OR EmrCollectionT.Inactive = 0)",
			m_nEmrInfoMasterID, m_nEmrInfoMasterID, m_nEmrInfoMasterID);

		m_pdlUsedOnTemplateList->FromClause = _bstr_t(strTemplateFrom);
		m_pdlUsedOnTemplateList->WhereClause = _bstr_t(strTemplateWhere);
		m_pdlUsedOnTemplateList->GroupByClause = _bstr_t("EmrTemplateT.ID, EmrTemplateT.Name");
		m_pdlUsedOnTemplateList->Requery();
	}

	// Image
	{
		// Store locally in CURRENT member variable since the on-screen control can't store it
		m_strCurImagePath = m_strImagePath;
		CString strFullImagePath = GetSharedPath() ^ "Images" ^ m_strCurImagePath;
		if(m_DataSubType == eist3DImage)
		{
			CheckDlgButton(IDC_USE_SELECTED_3DIMAGE, BST_CHECKED);
			CheckDlgButton(IDC_PROMPT_FOR_IMAGE, BST_UNCHECKED);
			CheckDlgButton(IDC_USE_SELECTED_IMAGE, BST_UNCHECKED);
			
			if(!FileUtils::DoesFileOrDirExist(strFullImagePath)) {
				m_strCurImagePath.Empty();
				MessageBox("The previously selected image (" + strFullImagePath + ") does not exist.", NULL, MB_OK|MB_ICONERROR);
			}
			LoadCurrent3DImage();
		}
		else
		{
			// Set the bitmap in the on-scrren control
			HBITMAP hImage;
			if (!m_strImagePath.IsEmpty() && LoadImageFile(GetSharedPath() ^ "Images" ^ m_strImagePath, hImage, -1)) {
				m_btnEmrImage.m_image = hImage;
				// (a.walling 2008-08-13 16:52) - PLID 30099 - Redraw the image
				RedrawWindow(NULL, NULL, RDW_INVALIDATE | RDW_ERASE | RDW_ALLCHILDREN);
			} else {
				m_btnEmrImage.m_image = NULL;
			}
			// Reflect the radio button state
			CheckDlgButton(IDC_PROMPT_FOR_IMAGE, m_bImageSpecified ? BST_UNCHECKED : BST_CHECKED);
			CheckDlgButton(IDC_USE_SELECTED_IMAGE, m_bImageSpecified ? BST_CHECKED : BST_UNCHECKED);
			CheckDlgButton(IDC_USE_SELECTED_3DIMAGE, BST_UNCHECKED);
		}

		// (z.manning 2010-02-09 14:44) - PLID 37228 - Smart stamps
		m_btnEnableSmartStamps.SetCheck(m_bEnableSmartStamps ? BST_CHECKED : BST_UNCHECKED);
		if(m_varSmartStampTableMasterID.vt == VT_NULL) {
			m_pdlSmartStampTable->PutCurSel(NULL);
		}
		else {
			if(m_pdlSmartStampTable->IsRequerying()) {
				// (z.manning 2010-02-10 14:42) - PLID 37228 - The list is still requerying so we'll
				// set the selection when that finishes.
				m_varSmartStampTableMasterIDForRequeryFinished = m_varSmartStampTableMasterID;
			}
			else {
				m_pdlSmartStampTable->SetSelByColumn(sstcMasterID, m_varSmartStampTableMasterID);
			}
		}
		OnEnableSmartStamps();

		// Show or hide the appropriate controls
		OnImageTypeSelected();
	}
	
	// Default text
	if (m_nDataType == 6) {
		m_RichEditCtrl->RichText = _bstr_t(m_strDefaultText);
	} else {
		SetDlgItemText(IDC_DEFAULT_TEXT, m_strDefaultText);
	}

	// Single- or multi-select list, or a Table
	{
		// Fill the "cur" variables for the data elements
		{
			// Clear the existing arrays (usually there won't be anything in these in the first place)
			m_aryCurDataElements.RemoveAllAndFreeEntries();
			m_aryCurColumnDataElements.RemoveAllAndFreeEntries();
			m_aryCurDeletedDataElements.RemoveAllAndFreeEntries();
			// Then just copy the list from the original (the deleted list obviously doesn't pull from data)
			m_aryCurDataElements.AppendCopy(m_aryDataElements);
			m_aryCurColumnDataElements.AppendCopy(m_aryColumnDataElements);
		}

		{
			// (j.jones 2012-09-19 12:22) - PLID 52316 - If we loaded a ParentLabelID,
			// we now need to fill the object's ParentLabelPtr with the pointer from m_aryCurDataElements.
			// We could not do this earlier because m_aryCurDataElements was just now filled for the first time.
			for(int i=0;i<m_aryCurDataElements.GetSize(); i++) {
				CEmrInfoDataElement *peide = m_aryCurDataElements.GetAt(i);
				if(peide != NULL && peide->m_nParentLabelID != -1) {
					//this row has a parent label ID, now assign its parent
					for(int j=0;j<m_aryCurDataElements.GetSize() && peide->m_peideParentLabelPtr == NULL; j++) {
						CEmrInfoDataElement *peideCheck = m_aryCurDataElements.GetAt(j);
						if(peideCheck != NULL && peideCheck != peide && peideCheck->m_nID == peide->m_nParentLabelID) {
							//found our parent, now assign it
							peide->m_peideParentLabelPtr = peideCheck;
						}
					}

					if(peide->m_peideParentLabelPtr == NULL) {
						//we could not find the parent label, this should be impossible
						ThrowNxException("Could not match up ParentLabelID %li for list item %li.", peide->m_nParentLabelID, peide->m_nID);
					}
				}
			}
		}

		// Reflect the current state on screen
		ReflectDataElementList(sdeidFirstInList);
	}

	// Slider
	{
		// Set the text boxes
		SetDlgItemText(IDC_EMR_MINIMUM, AsStringCleanDouble(m_dblSliderMin));
		SetDlgItemText(IDC_EMR_MAXIMUM, AsStringCleanDouble(m_dblSliderMax));
		SetDlgItemText(IDC_EMR_INCREMENT, AsStringCleanDouble(m_dblSliderInc));

		// Set the slider to use those values
		/*double dblScale = 1.0 / m_dblSliderInc;
		m_Slider.SetRangeMin((int)(m_dblSliderMin * dblScale));
		m_Slider.SetRangeMax((int)(m_dblSliderMax * dblScale));
		m_Slider.SetTicFreq(1);*/

		// (a.walling 2007-02-28 12:32) - PLID 24914 - Several issues with slider values. I've simplified the way
		// we store this data and calculate between values and positions. Now the slider control's minimum value is
		// always zero. This makes all these calculations much easier and avoids rounding errors, not to mention
		// solving the problem with odd increments allowing values below the minimum (and then all the incremented
		// values being off).

		// I don't know why or how this could happen, but might as well check for it.
		if (m_dblSliderInc == 0) {
			ThrowNxException("CEmrItemEntryDlg::ReflectState(): Slider increment value is zero!");
		}

		m_Slider.SetRangeMin(0);
		m_Slider.SetRangeMax((int)floor((m_dblSliderMax - m_dblSliderMin) / m_dblSliderInc));
		m_Slider.SetTicFreq(1);

		m_Slider.RedrawWindow();
	}

	// Disable Table Border
	//m.hancock - 2/28/2006 - PLID 15864 - Allow user to disable border on EMR table items when merging
	{
		CheckDlgButton(IDC_CHECK_DISABLE_TABLE_BORDER, m_bDisableTableBorder == TRUE ? BST_CHECKED : BST_UNCHECKED);
	}

	// (z.manning 2011-11-15 15:49) - PLID 46485 - Optiont to not spawn when loading remembered values
	CheckDlgButton(IDC_DONT_SPAWN_WHEN_REMEMBERING, (m_nInfoFlags & eifDontSpawnFromRememberedValues) == 0 ? BST_UNCHECKED : BST_CHECKED);

	// (b.cardillo 2012-03-06 16:35) - PLID 48669 - UI for the Required checkbox on emr items
	CheckDlgButton(IDC_REQUIRED_CHECKBOX, ((m_nInfoFlags & eifRequired) == eifRequired) ? BST_CHECKED : BST_UNCHECKED);

	// (c.haag 2007-01-29 15:47) - PLID 24423 - Depending on the data subtype, we want to disable
	// certain buttons and change the background color
	// (c.haag 2007-04-03 09:07) - PLID 25468 - Also include the system allergies item
	// (j.jones 2008-09-22 14:51) - PLID 31476 - Remember For EMR is always disabled and unchecked
	// when on the allergy or current medication table, whereas Remember For Patient is always
	// checked, yet still disabled.
	switch (m_DataSubType) {
	case eistCurrentMedicationsTable:
	case eistAllergiesTable:
		GetDlgItem(IDC_REMEMBER_FOR_PATIENT)->EnableWindow(FALSE);
		((CButton*)GetDlgItem(IDC_REMEMBER_FOR_PATIENT))->SetCheck(1);
		GetDlgItem(IDC_REMEMBER_FOR_EMR)->EnableWindow(FALSE);		
		((CButton*)GetDlgItem(IDC_REMEMBER_FOR_EMR))->SetCheck(0);
		GetDlgItem(IDC_TABLE_ROWS_AS_FIELDS)->EnableWindow(FALSE); // (c.haag 2008-10-21 15:44) - PLID 31708 - We don't support flipped system tables
		OnTableRowsAsFields();
		((CButton*)GetDlgItem(IDC_TABLE_ROWS_AS_FIELDS))->SetCheck(0);
		GetDlgItem(IDC_CHECK_ONE_PER_EMN)->EnableWindow(FALSE);
		GetDlgItem(IDC_CHECK_EMRINFO_INACTIVE)->EnableWindow(FALSE);
		GetDlgItem(IDC_ITEM_NAME)->EnableWindow(FALSE);
		GetDlgItem(IDC_RADIO_TEXT_SELECT)->EnableWindow(FALSE);
		GetDlgItem(IDC_RADIO_LIST_SELECT)->EnableWindow(FALSE);
		GetDlgItem(IDC_RADIO_LIST_MULTISELECT)->EnableWindow(FALSE);
		GetDlgItem(IDC_RADIO_IMAGE)->EnableWindow(FALSE);
		GetDlgItem(IDC_RADIO_SLIDER)->EnableWindow(FALSE);
		GetDlgItem(IDC_RADIO_TABLE)->EnableWindow(FALSE);
		GetDlgItem(IDC_RADIO_NARRATIVE)->EnableWindow(FALSE);
		GetDlgItem(IDC_ADD_OTHER_DATA_ITEM)->EnableWindow(FALSE);
		m_nxclrLeft.SetColor(0x00FF8080);
		m_nxclrRightTop.SetColor(0x00FF8080);
		m_nxclrRightBottom.SetColor(0x00FF8080);
		break;
	}

	UpdateDontSpawnRememberedValuesCheck();
}

// (j.gruber 2009-11-18 16:12) - PLID 35945 - copied from below into its own function
void CEmrItemEntryDlg::RevertToSavedDataType() 
{
	try {

		CheckDlgButton(IDC_RADIO_TEXT_SELECT, FALSE);
		CheckDlgButton(IDC_RADIO_LIST_SELECT, FALSE);
		CheckDlgButton(IDC_RADIO_LIST_MULTISELECT, FALSE);
		CheckDlgButton(IDC_RADIO_IMAGE, FALSE);
		CheckDlgButton(IDC_RADIO_SLIDER, FALSE);
		CheckDlgButton(IDC_RADIO_NARRATIVE, FALSE);
		CheckDlgButton(IDC_RADIO_TABLE, FALSE);

		switch(m_nDataType) {
			case 1:
				CheckDlgButton(IDC_RADIO_TEXT_SELECT, TRUE);
				break;
			case 2:
				CheckDlgButton(IDC_RADIO_LIST_SELECT, TRUE);
				break;
			case 3:
				CheckDlgButton(IDC_RADIO_LIST_MULTISELECT, TRUE);
				break;
			case 4:
				CheckDlgButton(IDC_RADIO_IMAGE, TRUE);
				break;
			case 5:
				CheckDlgButton(IDC_RADIO_SLIDER, TRUE);
				break;
			case 6:
				CheckDlgButton(IDC_RADIO_NARRATIVE, TRUE);
				break;
			case 7:
				CheckDlgButton(IDC_RADIO_TABLE, TRUE);
				break;
		}

		// (j.jones 2007-08-14 14:10) - PLID 27053 - will update the E/M Code Type combo appropriately
		ReflectEMCodeInterface();

	}NxCatchAll(__FUNCTION__);
}

#define IDT_HANDLE_DATA_TYPE_SELECTION	1001
void CEmrItemEntryDlg::OnDataTypeSelected() 
{
	try {
		//TES 6/25/2011 - PLID 38230 - Message boxes in radio button handlers cause problems if the radio buttons are changed with the 
		// keyboard, so set a timer and execute all the code there.
		SetTimer(IDT_HANDLE_DATA_TYPE_SELECTION, 0, NULL);

	}NxCatchAll("Error in OnDataTypeSelected");
}

void CEmrItemEntryDlg::OnDataFormatSelected() 
{
	// Decide whether we're enabled or disabled
	BOOL bSepEnabled;
	if (IsDlgButtonChecked(IDC_DATA_FORMAT_TEXT)) {
		bSepEnabled = TRUE;
	} else {
		bSepEnabled = FALSE;
	}

	// Change the enabled state appropriately
	GetDlgItem(IDC_DATA_FORMAT_SEPARATOR_LABEL)->EnableWindow(bSepEnabled ? 1 : 0);
	GetDlgItem(IDC_DATA_FORMAT_SEPARATOR)->EnableWindow(bSepEnabled ? 1 : 0);
	GetDlgItem(IDC_DATA_FORMAT_SEPARATOR_FINAL_LABEL)->EnableWindow(bSepEnabled ? 1 : 0);
	GetDlgItem(IDC_DATA_FORMAT_SEPARATOR_FINAL)->EnableWindow(bSepEnabled ? 1 : 0);
	
	// We're assuming the state changed, so invalidate the control (even if the state didn't 
	// change, it's not killing us to invalidate)
	{
		CRect rc;
		GetDlgItem(IDC_DATA_FORMAT_SEPARATOR_LABEL)->GetWindowRect(&rc);
		ScreenToClient(rc);
		InvalidateRect(rc, FALSE);
		// PLID 15008 - Do the same thing for the "final" field label
		GetDlgItem(IDC_DATA_FORMAT_SEPARATOR_FINAL_LABEL)->GetWindowRect(&rc);
		ScreenToClient(&rc);
		InvalidateRect(rc, FALSE);
	}

	//m.hancock - 2/28/2006 - PLID 15864 - Show / hide option to disable border on EMR table items when merging
	BOOL bTableSelected = (IsDlgButtonChecked(IDC_RADIO_TABLE)) && (IsDlgButtonChecked(IDC_DATA_FORMAT_NUMBER));
	GetDlgItem(IDC_CHECK_DISABLE_TABLE_BORDER)->ShowWindow(bTableSelected);
}

//DRT 2/29/2008 - PLID 28603 - This is slightly confusing in the options:
//	return true:  The caller should continue doing whatever they were doing.  The hotspots may or may not have
//		been erased.  This function is reporting that "the user is OK with the hotspots, either gone or not, 
//		and wishes to continue".
//	return false:  The caller should quit immediately.  This means "the user doesn't want to do anything, 
//		because hotspots exist and their initial choice was a poor one."
bool CEmrItemEntryDlg::CheckForAndPromptToClearHotSpots()
{
	BOOL b3DHotSpots = FALSE;
	if(m_btnEmrImage.m_image == NULL) {
		b3DHotSpots = TRUE;
	}

	//DRT 2/18/2008 - PLID 28602 - If there are hotspots, and they try to change the image, we warn to erase all hotspots.  I was going
	//	to force to delete, but there's really no good reason why, other than it's pretty silly to leave them.  So we'll just warn
	//	and give them an option to do it automatically.
	//The last saved # minus the removed # (because removed can only be in last saved), plus the new ones should be our total
	//	count of hotspots.
	if(m_aryLastSavedHotSpots.GetSize() - m_aryRemovedHotSpots.GetSize() + m_aryNewHotSpots.GetSize() > 0)
	{
		//DRT 2/29/2008 - PLID 28603 - If we are editing on the fly, and they have already checked some hotspots, we can't possibly
		//	let them delete those!
		if(!b3DHotSpots && m_bMaintainCurrentImage) {
			//Now loop through all details of this info ID on the EMN and see if any hotspots are in use.  A single one causes this
			//	function to abort.
			for(int i = 0; i < m_aryCurrentImageDetails.GetSize(); i++) {
				CEMNDetail *pDetail = m_aryCurrentImageDetails.GetAt(i);
				CEMRHotSpotArray *parySpots = pDetail->GetHotSpotArray();
				for(int j = 0; j < parySpots->GetSize(); j++) {
					CEMRHotSpot *pSpot = parySpots->GetAt(j);
					if(pSpot->GetSelected()) {
						AfxMessageBox("You have hotspots tied to the current image, but one or more of those hotspots is selected on the current EMN.  "
							"You may not erase hotspots or change the default background image while hotspots are selected.");
						return false;
					}
				}
			}
		}

		//There are some hotspots around.  They'll be erased if we go forward.
		// (z.manning 2011-09-27 14:31) - PLID 44676 - Do this silently if we were dealing with 3D hot spots
		if(b3DHotSpots || AfxMessageBox("You have hotspots tied to the current image.  If you attempt to change the current image, those existing hotspots will most "
			"likely not be placed appropriately.  It is recommended that you remove all hotspots from the current image before proceeding.\r\n"
			"Would you like to remove all hotspots now?", MB_YESNO) == IDYES)
		{
			//They agreed with our most reasonable suggestion.  Let's erase 'em.
			//1)  Anything in new has to go.  Since they're 'new', we can just drop them altogether, noone else needs to know.
			int i = 0;
			for(i = 0; i < m_aryNewHotSpots.GetSize(); i++) {
				CEMRHotSpot *pSpot = m_aryNewHotSpots.GetAt(i);
				delete pSpot;
			}
			m_aryNewHotSpots.RemoveAll();

			//2)  We want to throw away anything that has changed.  These are in the last saved, so we don't care what the changes are, and
			//	we do not need to deallocate the memory.
			m_aryChangedHotSpots.RemoveAll();

			//3)  Lastly, we need to dump everything that was previously saved.  In order for them to be deleted properly, they need to be moved
			//	to the removed array.  But we need to not re-add ones that are already marked deleted, if the user might have 
			//	done that themselves already.
			for(i = 0; i < m_aryLastSavedHotSpots.GetSize(); i++) {
				CEMRHotSpot *pSpot = m_aryLastSavedHotSpots.GetAt(i);

				//See if it exists in removed
				bool bFound = false;
				for(int j = 0; j < m_aryRemovedHotSpots.GetSize() && !bFound; j++) {
					if(m_aryRemovedHotSpots.GetAt(j)->GetID() == pSpot->GetID()) {
						bFound = true;
					}
				}

				//Only add it if it wasn't already found
				if(!bFound) {
					m_aryRemovedHotSpots.Add(pSpot);
				}
			}
			//Do not clear m_aryLastSavedHotSpots, it is referenced in the saving to determine what to do with hotspots
		}
	}

	return true;
}

void CEmrItemEntryDlg::OnPromptForImage()
{
	try {
		//DRT 2/18/2008 - PLID 28602 - See if there are hotspots and offer to clear them
		if(!CheckForAndPromptToClearHotSpots()) {
			//Revert back to the other checkbox
			CheckDlgButton(IDC_USE_SELECTED_IMAGE, TRUE);
			CheckDlgButton(IDC_PROMPT_FOR_IMAGE, FALSE);
			return;
		}

		//Just call the base functionality to show/hide windows appropriately
		OnImageTypeSelected();
	} NxCatchAll("Error in OnPromptForImage");
}

void CEmrItemEntryDlg::OnImageTypeSelected() 
{
	BOOL bIsImageDataType = IsDlgButtonChecked(IDC_RADIO_IMAGE) ? TRUE : FALSE;
	UINT nShow3D = bIsImageDataType && IsDlgButtonChecked(IDC_USE_SELECTED_3DIMAGE) ? SW_SHOW : SW_HIDE;

	GetDlgItem(IDC_EMR_IMAGE_FRAME)->ShowWindow(bIsImageDataType && IsDlgButtonChecked(IDC_PROMPT_FOR_IMAGE) ? SW_SHOW : SW_HIDE);
	GetDlgItem(IDC_EMR_IMAGE)->ShowWindow(bIsImageDataType && IsDlgButtonChecked(IDC_USE_SELECTED_IMAGE) ? SW_SHOW : SW_HIDE);
	//DRT 2/18/2008 - PLID 28602 - Only show the 'modify hotspots' button if we have an image selected.  It's not valid for 'prompt' types.
	//DRT 3/18/2008 - PLID 28906 - No showing for now, you should be able to just un-comment these next 2 lines when we're ready.
	//DRT 3/27/2008 - plid 29431 - And they're back.
	GetDlgItem(IDC_MODIFY_HOTSPOTS)->ShowWindow(bIsImageDataType && IsDlgButtonChecked(IDC_USE_SELECTED_IMAGE) ? SW_SHOW : SW_HIDE);
	GetDlgItem(IDC_MODIFY_HOTSPOTS)->EnableWindow(bIsImageDataType && IsDlgButtonChecked(IDC_USE_SELECTED_IMAGE));
	GetDlgItem(IDC_EMR_ITEM_ENTRY_3DIMAGE)->ShowWindow(nShow3D);
	
	if (bIsImageDataType && IsDlgButtonChecked(IDC_USE_SELECTED_IMAGE) && m_strCurImagePath.IsEmpty()) {
		OnEmrImage();
	}
}

void CEmrItemEntryDlg::OnInactivate()
{
	// (c.haag 2006-02-24 12:40) - PLID 17195 - Do not let anyone activate an item
	// used exclusively by locked EMN's
	//
	// (c.haag 2006-02-27 10:08) - PLID 17195 - I'm having second thoughts about this.
	// Maybe a user will want to take an item used only in locked EMN's, reactivate it,
	// and then use it in new EMN's
	//
	/*if (-1 != m_nID && !IsDlgButtonChecked(IDC_CHECK_EMRINFO_INACTIVE)) {
		if (ReturnsRecords("SELECT ID FROM EMRInfoT WHERE ID = %d AND ID IN (SELECT EMRInfoID FROM EMRDetailsT WHERE EMRID IN (SELECT ID FROM EMRMasterT WHERE Status = 2)) "
			"AND ID NOT IN (SELECT EMRInfoID FROM EMRDetailsT WHERE EMRID IN (SELECT ID FROM EMRMasterT WHERE Status <> 2))", m_nID))
		{
			((CButton*)GetDlgItem(IDC_CHECK_EMRINFO_INACTIVE))->SetCheck(1);
			MsgBox("You may not reactivate this item because it is used exclusively by locked EMN's");
		}
	}*/

	// (c.haag 2006-02-28 14:49) - PLID 12763 - Warn the user if this item would be
	// spawned from any single or multi-select items
	//
	if (-1 != m_nID && IsDlgButtonChecked(IDC_CHECK_EMRINFO_INACTIVE)) {
		_RecordsetPtr prs = CreateRecordset("SELECT EMRInfoT.Name from emractionst "
			"left join emrdatat on emractionst.sourceid = emrdatat.id "
			"left join emrinfot on emrdatat.emrinfoid = emrinfot.id "
			"where sourcetype = 4 and desttype = 3 and destid = %d "
			"group by emrinfot.name ", m_nID);
		if (!prs->eof) {
			CString strMsg = "This item is configured to spawn from the following EMR items:\n\n";
			while (!prs->eof) {
				strMsg += AdoFldString(prs, "Name", "") + "\n";
				prs->MoveNext();
			}
			strMsg += "\n\nDo you wish to inactivate this item anyway?";
			if (IDNO == MsgBox(MB_YESNO, strMsg))	{
				((CButton*)GetDlgItem(IDC_CHECK_EMRINFO_INACTIVE))->SetCheck(0);
			}
		}
	}
}


/*
void CEmrItemEntryDlg::ClearDataElementsList()
{
	// Our whole goal here is to just clear the datalist, but since the datalist contains some pointers we have to make 
	// sure we're freeing the memory those pointers point to.  But we have to assume an exception could be thrown by any 
	// of these functions, so we hold off on the freeing of the memory until AFTER the datalist is cleared.  This ensures 
	// that the worst case scenario is that the memory is leaked, but considering which parts of this function are even 
	// remotely LIKELY to throw an exception (the VarLong or the datalist Clear), even a memory leak is extremely unlikely 
	// because the pointers will still be in the list.  Anyway a leak is a lot better than deallocating non-allocated 
	// memory, which is our only alternative.

	// Get all the arrays that we're going to delete (don't delete them yet, because what happens if there's an exception?)
	CPtrArray aryaryActionArraysToFree;
	{
		long p = m_pdlDataElementList->GetFirstRowEnum();
		while (p) {
			LPDISPATCH lpDisp;
			m_pdlDataElementList->GetNextRowEnum(&p, &lpDisp);
			if (lpDisp) {
				IRowSettingsPtr pRow(lpDisp);
				lpDisp->Release();
				lpDisp = NULL;
				CEmrActionArray *paryActions = (CEmrActionArray *)VarLong(pRow->GetValue(delcAction));
				if (paryActions) {
					aryaryActionArraysToFree.Add(paryActions);
				}
			}
		}
	}
	
	// Now that we have all the arrays we're going to delete, clear the datalist (this is the point of this function)
	m_pdlDataElementList->Clear();
	
	// Now that we've cleared the datalist, go ahead and free the arrays
	for (long i=0; i<aryaryActionArraysToFree.GetSize(); i++) {
		delete (CEmrActionArray *)aryaryActionArraysToFree.GetAt(i);
	}
}
*/

void CEmrItemEntryDlg::ReflectDataElementSelection()
{
	BOOL bIsTable = IsDlgButtonChecked(IDC_RADIO_TABLE);

	BOOL bEnableDelete = FALSE;

	//TES 3/14/2011 - PLID 42784 - Converted to datalist2
	NXDATALIST2Lib::IRowSettingsPtr pCurSel = m_pdlDataElementList->CurSel;
	if (pCurSel == NULL) {
		GetDlgItem(IDC_DATA_UP)->EnableWindow(FALSE);
		GetDlgItem(IDC_DATA_DOWN)->EnableWindow(FALSE);
	} else {
		bEnableDelete = TRUE;

		if (!IsDlgButtonChecked(IDC_AUTO_ALPHABETIZE_LIST_DATA)) {
			GetDlgItem(IDC_DATA_UP)->EnableWindow(pCurSel->GetPreviousRow() != NULL);
			GetDlgItem(IDC_DATA_DOWN)->EnableWindow(pCurSel->GetNextRow() != NULL);
		}
		else {
			GetDlgItem(IDC_DATA_UP)->EnableWindow(FALSE);
			GetDlgItem(IDC_DATA_DOWN)->EnableWindow(FALSE);
		}
	}

	if(bIsTable) {
		//if a table, also check the column list
		//TES 3/14/2011 - PLID 42784 - Converted to datalist2
		NXDATALIST2Lib::IRowSettingsPtr pColCurSel = m_pdlColumnDataElementList->CurSel;
		if (pColCurSel == NULL) {
			GetDlgItem(IDC_COLUMN_DATA_UP)->EnableWindow(FALSE);
			GetDlgItem(IDC_COLUMN_DATA_DOWN)->EnableWindow(FALSE);
			GetDlgItem(IDC_BTN_EDIT_TABLE_DROPDOWN_DATA)->EnableWindow(FALSE);
			GetDlgItem(IDC_BTN_EDIT_TABLE_AUTOFILL)->EnableWindow(FALSE); // (z.manning 2011-03-18 14:51) - PLID 23662
		} else {
			bEnableDelete = TRUE;

			if (!IsDlgButtonChecked(IDC_AUTO_ALPHABETIZE_LIST_DATA)) {
				GetDlgItem(IDC_COLUMN_DATA_UP)->EnableWindow(pColCurSel->GetPreviousRow() != NULL);
				GetDlgItem(IDC_COLUMN_DATA_DOWN)->EnableWindow(pColCurSel->GetNextRow() != NULL);
			}
			else {
				GetDlgItem(IDC_COLUMN_DATA_UP)->EnableWindow(FALSE);
				GetDlgItem(IDC_COLUMN_DATA_DOWN)->EnableWindow(FALSE);\
			}

			// (z.manning 2011-03-09) - PLID 42722 - Also enable this if it's a text column
			//TES 3/14/2011 - PLID 42784 - Converted to datalist2
			long nColType = VarLong(pColCurSel->GetValue(cdelcType),LIST_TYPE_TEXT);
			BYTE nColSubType = VarByte(pColCurSel->GetValue(cdelcSubType),LIST_TYPE_TEXT);
			GetDlgItem(IDC_BTN_EDIT_TABLE_DROPDOWN_DATA)->EnableWindow(nColType == LIST_TYPE_DROPDOWN || nColType == LIST_TYPE_TEXT);
			
			// (z.manning 2011-03-18 14:51) - PLID 23662
			// (j.jones 2011-05-03 16:08) - PLID 43527 - disallow in current medication built-in columns
			GetDlgItem(IDC_BTN_EDIT_TABLE_AUTOFILL)->EnableWindow(nColType == LIST_TYPE_TEXT
				&& !IsSmartStampListSubType(nColSubType)
				&& !IsCurrentMedicationListSubType(nColSubType));
		}
	}
	else {
		GetDlgItem(IDC_COLUMN_DATA_UP)->EnableWindow(FALSE);
		GetDlgItem(IDC_COLUMN_DATA_DOWN)->EnableWindow(FALSE);
	}

	if(bEnableDelete)
		GetDlgItem(IDC_DELETE_DATA_ITEM)->EnableWindow(TRUE);
	else
		GetDlgItem(IDC_DELETE_DATA_ITEM)->EnableWindow(FALSE);

	if(!bIsTable) {
		if(pCurSel == NULL) {
			GetDlgItem(IDC_DATA_LONGFORM)->EnableWindow(FALSE);
			GetDlgItem(IDC_INSERT_EMR_DATA_FIELD)->EnableWindow(FALSE);
			SetDlgItemText(IDC_DATA_LONGFORM, "");
		}
		else {
			GetDlgItem(IDC_DATA_LONGFORM)->EnableWindow(TRUE);
			GetDlgItem(IDC_INSERT_EMR_DATA_FIELD)->EnableWindow(TRUE);
			
			long nArrayIndex = GetCurDataElementArrayIndex(pCurSel->GetValue(delcSortOrder), FALSE);
			CEmrInfoDataElement *peide = m_aryCurDataElements.GetAt(nArrayIndex);
			SetDlgItemText(IDC_DATA_LONGFORM, peide->m_strLongForm);
		}
	}
}

void CEmrItemEntryDlg::OnEditEmrCategories() 
{
	try {
		// Give the user the list of categories to manipulate
		CEmrCategoriesDlg dlg(this);
		dlg.DoModal();
		
		// Remember the currently selected row
		long nCurrentID = VarLong(m_pdlCategoryCombo->GetValue(m_pdlCategoryCombo->GetCurSel(), 0));
		// Refresh the list
		m_pdlCategoryCombo->Requery();
		{
			IRowSettingsPtr pRow = m_pdlCategoryCombo->GetRow(sriGetNewRow);
			pRow->PutValue(0, (long)clsrvMultiCategory);
			pRow->PutValue(1, " { Multiple Categories... }");
			pRow->PutValue(2, (long)-1);
			m_pdlCategoryCombo->InsertRow(pRow, 0);
		}
		{
			IRowSettingsPtr pRow = m_pdlCategoryCombo->GetRow(sriGetNewRow);
			pRow->PutValue(0, (long)clsrvNoCategory);
			pRow->PutValue(1, " { No Categories }");
			pRow->PutValue(2, (long)-2);
			m_pdlCategoryCombo->InsertRow(pRow, 0);
		}
		// Re-select the row
		long nNewSel = m_pdlCategoryCombo->SetSelByColumn(0, nCurrentID);
		if (nNewSel == sriNoRow) {
			// The row couldn't be selected!
			MessageBox("The previously selected category is no longer available.  Please select a new category or categories for this EMR Item.", NULL, MB_OK|MB_ICONINFORMATION);
			m_pdlCategoryCombo->SetSelByColumn(0, (long)clsrvNoCategory);
			m_arynCurCategoryIDs.RemoveAll();
		} else if (VarLong(m_pdlCategoryCombo->GetValue(nNewSel, 0)) == clsrvMultiCategory) {
			// It was "multiple-select" which means we have to check if ANY element in our current sel array is no longer available
			long nCountOriginalTotal = m_arynCurCategoryIDs.GetSize();
			// Remove the ones that are no longer available, and count how many of those there are
			m_pdlCategoryCombo->WaitForRequery(dlPatienceLevelWaitIndefinitely);
			long nCountUnavail = 0;
			{
				long nLastRowFound = -1;
				for (long i=0; i<m_arynCurCategoryIDs.GetSize(); i++) {
					long nRowIndex = m_pdlCategoryCombo->FindByColumn(0, (long)m_arynCurCategoryIDs.GetAt(i), nLastRowFound+1, VARIANT_FALSE);
					if (nRowIndex != sriNoRow) {
						// Found it, so we're good on this one
						nLastRowFound = nRowIndex;
					} else {
						// Didn't find it, so add one to our failure count
						nCountUnavail++;
						m_arynCurCategoryIDs.RemoveAt(i);
						i--;
					}
				}
			}
			// Give the appropriate message
			if (nCountUnavail > 0) {
				// At least one has disappeared, notify the user (who shouldn't be surprised by this 
				// because it was (probably) his own fault)
				
				// Decide whether it was "all" or not all, which is "some"; also, decide what we're going to 
				// select after we warn the user.  If we removed "all" then obviously we're going to select 
				// the "no categories" row.  But if we removed "some" then there may be either 1 left, or more 
				// than 1 left, so we either select the 1 or select the "multi-select" row.
				long nNewSelCatID;
				CString strMsg;
				if (nCountUnavail == nCountOriginalTotal) {
					// All were removed, so we tell the user "all" and we select the "no category" row
					strMsg = "All of your selected categories have become unavailable.  "
						"Please choose a category or categories, if any apply.";
					nNewSelCatID = (long)clsrvNoCategory;
				} else {
					// Not all were removed, so we tell the user "some" and we select either the 1 remaining 
					// category, or the "multi-category" row.
					strMsg = "Some of your selected categories have become unavailable.  "
						"Please ensure that the remaining selected category or categories are correct "
						"and choose any additional categories that apply.";
					nNewSelCatID = (long)clsrvMultiCategory;
					if (m_arynCurCategoryIDs.GetSize() == 1) {
						nNewSelCatID = m_arynCurCategoryIDs.GetAt(0);
					} else {
						nNewSelCatID = (long)clsrvMultiCategory;
					}
				}
				// Notify the user
				MessageBox(strMsg, NULL, MB_OK|MB_ICONINFORMATION);
				// Select the correct row
				m_pdlCategoryCombo->SetSelByColumn(0, nNewSelCatID);
			} else {
				// None of our currently selected categories have disappeared, so we're good to go
			}
		}
	} NxCatchAll("CEmrItemEntryDlg::OnEditEMRCategories");
}

void CEmrItemEntryDlg::OnSelChangingEmrCategories(long FAR* nNewSel) 
{
	try {
		// If nothing is selected, we force a cleaner inferface by setting it to the "no category" row.
		if (*nNewSel == sriNoRow) {
			*nNewSel = m_pdlCategoryCombo->FindByColumn(0, (long)clsrvNoCategory, 0, false);
		}
	} NxCatchAll("CEmrItemEntryDlg::OnSelChangingEmrCategories");
}

void CEmrItemEntryDlg::OnSelChosenEmrCategories(long nRow) 
{
	try {
		// Determine what category or categories they're now selecting
		CDWordArray arynNewCatIDs;
		{
			// Get the singly selected category, or clsrvMultiCategory if it's the multi-select cat entry
			long nNewSelCatID = VarLong(m_pdlCategoryCombo->GetValue(nRow, 0));

			// If they hit the mult-select option, pop up the dialog
			if (nNewSelCatID == clsrvMultiCategory) {
				// (j.armen 2012-06-20 15:23) - PLID 49607 - Provide MultiSelect Sizing ConfigRT Entry
				CMultiSelectDlg dlg(this, "EMRCategoriesT");
				dlg.PreSelect(m_arynCurCategoryIDs);
				int nResult = dlg.Open("EMRCategoriesT", "", "ID", "Name", "Select categories for this EMR Item:");
				if (nResult == IDOK) {
					// Get the set off the dialog
					arynNewCatIDs.RemoveAll();
					dlg.FillArrayWithIDs(arynNewCatIDs);
				} else {
					if (m_arynCurCategoryIDs.GetSize() > 0) {
						m_pdlCategoryCombo->SetSelByColumn(0, (long)((m_arynCurCategoryIDs.GetSize() > 1) ? clsrvMultiCategory : m_arynCurCategoryIDs.GetAt(0)));
					} else {
						// If nNewSelCatID == clsrvMultiCategory, shouldn't m_arynCurCategoryIDs.GetSize() have had to be > 1, which is implicitly > 0?
						//(e.lally 2012-03-01) This path is hit when the item had "no category" selected previously and the user cancelled the select multiple box.
						//Setting the DL to no selection does not appear to cause any problems so I am removing the assertion.
						m_pdlCategoryCombo->PutCurSel(sriNoRow);
					}
					return;
				}
			} else if (nNewSelCatID == clsrvNoCategory) {
				// None selected
				arynNewCatIDs.RemoveAll();
			} else {
				// Only one selected
				arynNewCatIDs.RemoveAll();
				arynNewCatIDs.Add(nNewSelCatID);
			}
		}

		// Finally write the new selection to our local array
		if (arynNewCatIDs.GetSize() > 0) {
			// Copy the array from the arynNewCatIDs that the user just selected, into our member variable 
			// m_arynCurCategoryIDs.
			m_arynCurCategoryIDs.Copy(arynNewCatIDs);
			// If it's just one, then it's not a true "multi-select" so make sure the currently 
			// selected row is the one that represents that single category.
			if (arynNewCatIDs.GetSize() == 1) {
				m_pdlCategoryCombo->SetSelByColumn(0, (long)arynNewCatIDs.GetAt(0));
			} else {
				// The "multi-select" row is already the cur sel because the only way arynNewCatIDs.GetSize() 
				// could be > 1 is if the user just now selected mutliple cat ids, and the only way the user 
				// can do that is with the CMultiSelectDlg, and the only way for that to pop up is if the row 
				// the user just selected was in fact the multi-select row!
				// So we need do nothing here.
			}
		} else {
			// None selected, so simply clear out the current list
			m_arynCurCategoryIDs.RemoveAll();
			// And make sure the "no categories" row is selected
			m_pdlCategoryCombo->SetSelByColumn(0, (long)clsrvNoCategory);
		}

	} NxCatchAll("CEmrItemEntryDlg::OnSelChosenEmrCategories");
}



void CEmrItemEntryDlg::OnInsertEmrField() 
{
	CMenu mnu;
	mnu.CreatePopupMenu();

	BOOL bIsTable = IsDlgButtonChecked(IDC_RADIO_TABLE);
	BOOL bTableDataFormat = IsDlgButtonChecked(IDC_DATA_FORMAT_NUMBER);
	BOOL bTableFlipped = (IsDlgButtonChecked(IDC_TABLE_ROWS_AS_FIELDS) == BST_CHECKED);

	//TES 2/25/2010 - PLID 37234 - We've got a dynamic list now, so track as we go.
	int nPosition = 1;
	int nFirstDynamicField = 0, nLastDynamicField = 0;
	//TES 2/19/2010 - PLID 37234 - Also, if they're using the "Smart Stamps" format, do NOT show the <Data> option, because we're
	// instead giving them access to parts of the data.
	// (z.manning 2010-07-26 16:21) - PLID 39848 - This is now always available again. The smart stamp specific stuff is now
	// gone as all tables can have alternative sentence formats.
	mnu.AppendMenu(MF_ENABLED|MF_STRING|MF_BYPOSITION, nPosition++, DATA_FIELD);

	mnu.AppendMenu(MF_ENABLED|MF_STRING|MF_BYPOSITION, nPosition++, AGE_FIELD);
	mnu.AppendMenu(MF_ENABLED|MF_STRING|MF_BYPOSITION, nPosition++, GENDER_UPPER_FIELD);
	mnu.AppendMenu(MF_ENABLED|MF_STRING|MF_BYPOSITION, nPosition++, GENDER_LOWER_FIELD);
	mnu.AppendMenu(MF_ENABLED|MF_STRING|MF_BYPOSITION, nPosition++, SUBJ_UPPER_FIELD);
	mnu.AppendMenu(MF_ENABLED|MF_STRING|MF_BYPOSITION, nPosition++, SUBJ_LOWER_FIELD);
	mnu.AppendMenu(MF_ENABLED|MF_STRING|MF_BYPOSITION, nPosition++, OBJ_UPPER_FIELD);
	mnu.AppendMenu(MF_ENABLED|MF_STRING|MF_BYPOSITION, nPosition++, OBJ_LOWER_FIELD);
	mnu.AppendMenu(MF_ENABLED|MF_STRING|MF_BYPOSITION, nPosition++, POSS_UPPER_FIELD);
	mnu.AppendMenu(MF_ENABLED|MF_STRING|MF_BYPOSITION, nPosition++, POSS_LOWER_FIELD);
	mnu.AppendMenu(MF_ENABLED|MF_STRING|MF_BYPOSITION, nPosition++, SPAWNING_FIELD);

	// (z.manning 2010-08-04 10:12) - PLID 39497 - For non-table formatted tables, add options for grouping
	if(bIsTable && !bTableDataFormat) {
		mnu.AppendMenu(MF_ENABLED|MF_STRING|MF_BYPOSITION, nPosition++, GROUP_BEGIN_FIELD);
		mnu.AppendMenu(MF_ENABLED|MF_STRING|MF_BYPOSITION, nPosition++, GROUP_END_FIELD);
	}
	else {
		nPosition += 2;
	}
	
	//TES 2/18/2010 - PLID 37234 - If they're using the "Smart Stamps" format, give them additional, Smart Stamp specific items.
	// (z.manning 2010-07-26 12:26) - PLID 39842 - We now support this on all tables when the data format is something other than table.
	if(bIsTable && !bTableDataFormat)
	{
		mnu.AppendMenu(MF_ENABLED|MF_SEPARATOR|MF_BYPOSITION);

		// (z.manning 2010-09-02 09:52) - PLID 40206 - Also add a field for the row or col name
		if(bTableFlipped) {
			mnu.AppendMenu(MF_ENABLED|MF_STRING|MF_BYPOSITION, nPosition++, COLUMN_NAME_FIELD);
		}
		else {
			mnu.AppendMenu(MF_ENABLED|MF_STRING|MF_BYPOSITION, nPosition++, ROW_NAME_FIELD);
		}

		for(int nCol = 0; nCol < m_aryCurColumnDataElements.GetSize(); nCol++) {
			CEmrInfoDataElement *pCol = m_aryCurColumnDataElements.GetAt(nCol);
			mnu.AppendMenu(MF_ENABLED|MF_STRING|MF_BYPOSITION, nPosition++, "<" + pCol->m_strData + ">");
			//TES 2/25/2010 - PLID 37234 - This is a dynamic field, so if we haven't set one yet, it's our first.
			if(nFirstDynamicField == 0) nFirstDynamicField = nPosition-1;
			nLastDynamicField = nPosition-1;
		}
	}

	//TES 2/25/2010 - PLID 37234 - If we didn't enter any dynamic fields, then the offset to the static fields starts here.
	if(nLastDynamicField == 0) {
		nLastDynamicField = nPosition-1;
	}

	CRect rButton;
	GetDlgItem(IDC_INSERT_EMR_FIELD)->GetWindowRect(rButton);
	int nSelection = mnu.TrackPopupMenu(TPM_LEFTALIGN|TPM_RETURNCMD|TPM_TOPALIGN, rButton.right, rButton.top, this);

	CString strField;
	if(nSelection == 0) {
		return;
	}
	else if(nFirstDynamicField != 0 && nSelection >= nFirstDynamicField && nSelection <= nLastDynamicField) {
		//TES 2/25/2010 - PLID 37234 - This must be one of our Smart Stamps columns.
		// (z.manning 2010-07-26 12:28) - PLID 39842 - This is now supported on all tables so this assertion is no longer valid.
		//ASSERT(IsDlgButtonChecked(IDC_USE_SMART_STAMPS_FORMAT));
		((CNxEdit*)GetDlgItem(IDC_SENTENCE))->ReplaceSel("<" + m_aryCurColumnDataElements.GetAt(nSelection-nFirstDynamicField)->m_strData + ">");
	}
	else {
		//TES 2/25/2010 - PLID 37234 - Calculate these by offsetting against the last dynamic field.
		switch(nSelection) {
		case 1:
			((CNxEdit*)GetDlgItem(IDC_SENTENCE))->ReplaceSel(DATA_FIELD);
			break;
		case 2:
			((CNxEdit*)GetDlgItem(IDC_SENTENCE))->ReplaceSel(AGE_FIELD);
			break;
		case 3:
			((CNxEdit*)GetDlgItem(IDC_SENTENCE))->ReplaceSel(GENDER_UPPER_FIELD);
			break;
		case 4:
			((CNxEdit*)GetDlgItem(IDC_SENTENCE))->ReplaceSel(GENDER_LOWER_FIELD);
			break;
		case 5:
			((CNxEdit*)GetDlgItem(IDC_SENTENCE))->ReplaceSel(SUBJ_UPPER_FIELD);
			break;
		case 6:
			((CNxEdit*)GetDlgItem(IDC_SENTENCE))->ReplaceSel(SUBJ_LOWER_FIELD);
			break;
		case 7:
			((CNxEdit*)GetDlgItem(IDC_SENTENCE))->ReplaceSel(OBJ_UPPER_FIELD);
			break;
		case 8:
			((CNxEdit*)GetDlgItem(IDC_SENTENCE))->ReplaceSel(OBJ_LOWER_FIELD);
			break;
		case 9:
			((CNxEdit*)GetDlgItem(IDC_SENTENCE))->ReplaceSel(POSS_UPPER_FIELD);
			break;
		case 10:
			((CNxEdit*)GetDlgItem(IDC_SENTENCE))->ReplaceSel(POSS_LOWER_FIELD);
			break;
		case 11:
			((CNxEdit*)GetDlgItem(IDC_SENTENCE))->ReplaceSel(SPAWNING_FIELD);
			break;
		case 12: // (z.manning 2010-08-04 11:00) - PLID 39497 - Groups
			((CNxEdit*)GetDlgItem(IDC_SENTENCE))->ReplaceSel(GROUP_BEGIN_FIELD);
			break;
		case 13: // (z.manning 2010-08-04 11:00) - PLID 39497 - Groups
			((CNxEdit*)GetDlgItem(IDC_SENTENCE))->ReplaceSel(GROUP_END_FIELD);
			break;
		case 14: // (z.manning 2010-09-02 10:03) - PLID 40206 - Row or column name
			if(bTableFlipped) {
				((CNxEdit*)GetDlgItem(IDC_SENTENCE))->ReplaceSel(COLUMN_NAME_FIELD);
			}
			else {
				((CNxEdit*)GetDlgItem(IDC_SENTENCE))->ReplaceSel(ROW_NAME_FIELD);
			}
			break;
		}
	}
	if(nSelection != 0) {
		GetDlgItem(IDC_SENTENCE)->SetFocus();
	}
}

void CEmrItemEntryDlg::OnEmrImage() 
{
	try {
		if (IsDlgButtonChecked(IDC_USE_SELECTED_IMAGE)) {
			//DRT 2/18/2008 - PLID 28602 - See if there are hotspots and offer to clear them
			if(!CheckForAndPromptToClearHotSpots())
				return;

			CSelectImageDlg dlg(this);
			dlg.m_nPatientID = -1;
			if (dlg.DoModal() == IDOK) {
				ASSERT(dlg.m_nImageType == itDiagram);
				
				// Remember it as the currently selected image
				m_strCurImagePath = dlg.m_strFileName;

				// Display it
				HBITMAP hImage;
				if (LoadImageFile(GetSharedPath() ^ "Images" ^ dlg.m_strFileName, hImage, -1)) {
					// (c.haag 2009-12-23 16:49) - PLID 31063 - Unload the image if it already exists.
					if (NULL != m_btnEmrImage.m_image) {
						DeleteObject(m_btnEmrImage.m_image);
					}
					m_btnEmrImage.m_image = hImage;
					m_btnEmrImage.ShowWindow(SW_SHOW);
					GetDlgItem(IDC_EMR_IMAGE_FRAME)->ShowWindow(SW_HIDE);
				} else {
					// (c.haag 2009-12-23 16:49) - PLID 31063 - Unload the image if it already exists.
					if (NULL != m_btnEmrImage.m_image) {
						DeleteObject(m_btnEmrImage.m_image);
					}
					m_btnEmrImage.m_image = NULL;
					m_btnEmrImage.ShowWindow(SW_HIDE);
					GetDlgItem(IDC_EMR_IMAGE_FRAME)->ShowWindow(SW_SHOW);
				}
				// (a.walling 2008-08-13 16:51) - PLID 30099 - Redraw the image and container
				RedrawWindow(NULL, NULL, RDW_INVALIDATE | RDW_UPDATENOW | RDW_ERASE | RDW_ERASENOW | RDW_ALLCHILDREN);
			}
		}
	} NxCatchAll("CEmrItemEntryDlg::OnEmrImage");
}

void CEmrItemEntryDlg::OnItemAction() 
{
	CEmrActionDlg dlg(this);
	if(m_pCurrentEMN) {
		dlg.SetCurrentEMN(m_pCurrentEMN);
	}
	dlg.m_SourceType = eaoEmrItem;
	dlg.m_nSourceID = CEmrActionDlg::bisidNotBoundToData;
	dlg.m_nOriginatingID = m_nID;
	GetDlgItemText(IDC_ITEM_NAME, dlg.m_strSourceObjectName);
	// (a.walling 2007-11-05 16:08) - PLID 27980 - VS2008 - for() loops
	int i = 0;
	for(i = 0; i < m_arCurActions.GetSize(); i++) dlg.m_arActions.Add(m_arCurActions[i]);
	if (dlg.DoModal() == IDOK) {
		m_arCurActions.RemoveAll();
		for(i=0; i < dlg.m_arActions.GetSize(); i++) m_arCurActions.Add(dlg.m_arActions[i]);
	}
}

//TES 3/14/2011 - PLID 42784 - Converted to datalist2
NXDATALIST2Lib::IRowSettingsPtr CEmrItemEntryDlg::CreateDatalistRowFromDataElement(const CEmrInfoDataElement *peide)
{
	NXDATALIST2Lib::IRowSettingsPtr pRow;
	
	//m_nListType of 1 is a normal list
	//m_nListType of 2 is a table row
	//m_nListType of 3 is a table column text
	//m_nListType of 4 is a table column dropdown
	//m_nListType of 5 is a table column checkbox
	//m_nListType of 6 is a table column linked detail
	if(peide->m_nListType < 3) {
		pRow = m_pdlDataElementList->GetNewRow();
		pRow->PutValue(delcID, peide->m_nID);
		pRow->PutValue(delcData, (LPCTSTR)peide->m_strData);		
		if(peide->m_bIsLabel) {
			_variant_t varNull;
			varNull.vt = VT_NULL;
			// (j.gruber 2010-04-26 12:58) - PLID 38336 - Bold Code
			pRow->PutValue(delcBOLDCode, varNull);
			pRow->PutValue(delcDefault, varNull);
			pRow->PutValue(delcAction, varNull);
			// (j.gruber 2014-07-17 13:30) - PLID 62621 - When editing multi & single select lists, table row sand columns,  add a new checkbox column labeled Keyword to the right of the action column - Loading
			pRow->PutValue(delcUseKeyWord, varNull);
			pRow->PutCellLinkStyle(delcAction, NXDATALIST2Lib::dlLinkStyleFalse);
			//TES 3/16/2011 - PLID 42757 - Disable the Glasses Order columns for Labels.
			pRow->PutCellBackColor(delcGlassesOrderDataType, DISABLED_COLOR);
			pRow->PutCellBackColorSel(delcGlassesOrderDataType, DISABLED_COLOR);
			pRow->PutCellBackColor(delcGlassesOrderDataID, DISABLED_COLOR);
			pRow->PutCellBackColorSel(delcGlassesOrderDataID, DISABLED_COLOR);
			// (j.gruber 2013-10-02 11:36) - PLID 58674 - EMR Codes
			pRow->PutValue(delcCodes, varNull);
			pRow->PutCellLinkStyle(delcCodes, NXDATALIST2Lib::dlLinkStyleFalse);
			
		}
		else {
			// (j.gruber 2010-04-26 12:58) - PLID 38336 - Bold Code
			pRow->PutValue(delcBOLDCode, (LPCTSTR)peide->m_strBoldCode);
			pRow->PutValue(delcDefault, _variant_t(peide->m_bDefault ? VARIANT_TRUE : VARIANT_FALSE, VT_BOOL));
			pRow->PutValue(delcAction, (LPCTSTR)("<" + AsString((long)peide->m_arActions.GetSize()) + " action(s)>"));
			// (j.gruber 2014-07-17 13:30) - PLID 62621 - When editing multi & single select lists, table row sand columns,  add a new checkbox column labeled Keyword to the right of the action column - Loading
			pRow->PutValue(delcUseKeyWord, _variant_t(peide->m_bUseKeyword ? VARIANT_TRUE: VARIANT_FALSE, VT_BOOL));
			// (j.gruber 2014-07-28 11:11) - PLID 62630 - When editing multi-select lists, single-select lists, tables, and table dropdowns, change the background of the Keyword checkbox cell to yellow for a visual indicator that an override is set.
			if (peide->m_bUseKeyword && (!peide->m_strKeywordOverride.IsEmpty()))
			{
				pRow->PutCellBackColor(delcUseKeyWord, HAS_KEYWORD_OVERRIDE_COLOR);
			}
			
			pRow->PutCellLinkStyle(delcAction, NXDATALIST2Lib::dlLinkStyleTrue);
			// (j.gruber 2013-10-02 11:37) - PLID 58674
			pRow->PutValue(delcCodes, (LPCTSTR)("<" + AsString((long)peide->m_aryCodes.GetSize()) + " code(s)>"));
		}
		pRow->PutValue(delcSortOrder, peide->m_nSortOrder);
		pRow->PutValue(delcInactive, _variant_t(peide->m_bInactive ? VARIANT_TRUE : VARIANT_FALSE, VT_BOOL));
		pRow->PutValue(delcIsLabel, _variant_t(peide->m_bIsLabel ? VARIANT_TRUE : VARIANT_FALSE, VT_BOOL));
		// (j.jones 2012-09-18 16:33) - PLID 52316 - added ParentLabelID
		pRow->PutValue(delcParentLabelID, peide->m_peideParentLabelPtr == NULL ? 0 : (long)(peide->m_peideParentLabelPtr));
		// (j.jones 2007-08-15 11:50) - PLID 27053 - added UseEMCoding
		pRow->PutValue(delcUseEMCoding, _variant_t(peide->m_bUseEMCoding ? VARIANT_TRUE : VARIANT_FALSE, VT_BOOL));
		// (j.jones 2011-03-08 12:25) - PLID 42282 - added EMCodeCategoryID, can be -1
		pRow->PutValue(delcEMCodeCategoryID, (long)peide->m_nEMCodeCategoryID);
		//TES 3/11/2011 - PLID 42757 - Added Glasses Order data
		pRow->PutValue(delcGlassesOrderDataType, peide->m_GlassesOrderDataType == godtInvalid?g_cvarNull:(long)peide->m_GlassesOrderDataType);
		pRow->PutValue(delcGlassesOrderDataID, peide->m_nGlassesOrderDataID == -1 ? g_cvarNull : peide->m_nGlassesOrderDataID);
		//TES 3/14/2011 - PLID 42757 - Make sure the GlassesOrderDataID field matches the selected GlassesOrderDataType
		ReflectGlassesOrderDataType(pRow, FALSE);
	}
	else {
		//TES 3/14/2011 - PLID 42784 - Converted to datalist2
		pRow = m_pdlColumnDataElementList->GetNewRow();
		pRow->PutValue(cdelcID, peide->m_nID);
		pRow->PutValue(cdelcData, (LPCTSTR)peide->m_strData);
		pRow->PutValue(cdelcType, peide->m_nListType);
		// (j.gruber 2014-07-17 13:30) - PLID 62621 - When editing multi & single select lists, table row sand columns,  add a new checkbox column labeled Keyword to the right of the action column - Loading
		// (j.gruber 2014-08-04 16:51) - PLID 62621 - this should actually be just linked details that we are hiding it for
		if (peide->m_nListType != LIST_TYPE_LINKED) {
			pRow->PutValue(cdelcUseKeyword, _variant_t(peide->m_bUseKeyword ? VARIANT_TRUE : VARIANT_FALSE, VT_BOOL));
		}
		else {
			pRow->PutValue(cdelcUseKeyword, g_cvarNull);
		}
		pRow->PutValue(cdelcSortOrder, peide->m_nSortOrder);
		pRow->PutValue(cdelcIsGrouped, _variant_t(peide->m_bIsGrouped ? VARIANT_TRUE : VARIANT_FALSE, VT_BOOL));		
		pRow->PutValue(cdelcInactive, _variant_t(peide->m_bInactive ? VARIANT_TRUE : VARIANT_FALSE, VT_BOOL));
		// (j.jones 2007-08-15 11:50) - PLID 27053 - added UseEMCoding
		pRow->PutValue(cdelcUseEMCoding, _variant_t(peide->m_bUseEMCoding ? VARIANT_TRUE : VARIANT_FALSE, VT_BOOL));
		// (z.manning 2010-02-11 17:10) - PLID 37324
		pRow->PutValue(cdelcSubType, peide->m_nListSubType);
		// (z.manning 2010-04-13 10:12) - PLID 29301 - Support is label option in table columns
		pRow->PutValue(cdelcIsLabel, peide->m_bIsLabel ? g_cvarTrue : g_cvarFalse);
		// (j.jones 2011-03-08 12:25) - PLID 42282 - added EMCodeCategoryID, can be -1
		pRow->PutValue(cdelcEMCodeCategoryID, (long)peide->m_nEMCodeCategoryID);
		//TES 3/11/2011 - PLID 42757 - Added Glasses Order data
		pRow->PutValue(cdelcGlassesOrderDataType, peide->m_GlassesOrderDataType == godtInvalid?g_cvarNull:(long)peide->m_GlassesOrderDataType);
		pRow->PutValue(cdelcGlassesOrderDataID, peide->m_nGlassesOrderDataID == -1 ? g_cvarNull : peide->m_nGlassesOrderDataID);
		// (r.gonet 08/03/2012) - PLID 51735 - Added Wound Care Data Type
		pRow->PutValue(cdelcWoundCareDataType, peide->m_ewccWoundCareDataType == wcdtNone?g_cvarNull:(long)peide->m_ewccWoundCareDataType);
		// (j.gruber 2013-10-21 09:11) - PLID 59101 - codes for columns
		pRow->PutValue(cdelcCodes, (LPCTSTR)("<" + AsString((long)peide->m_aryCodes.GetSize()) + " code(s)>"));

		// (j.gruber 2014-07-28 11:11) - PLID 62630 - When editing multi-select lists, single-select lists, tables, and table dropdowns, change the background of the Keyword checkbox cell to yellow for a visual indicator that an override is set.
		if (peide->m_bUseKeyword && (!peide->m_strKeywordOverride.IsEmpty()))
		{
			pRow->PutCellBackColor(cdelcUseKeyword, HAS_KEYWORD_OVERRIDE_COLOR);
		}
		//TES 3/16/2011 - PLID 42757 - Disable the Glasses Order columns for Labels.
		if(peide->m_bIsLabel) {
			pRow->PutCellBackColor(cdelcGlassesOrderDataType, DISABLED_COLOR);
			pRow->PutCellBackColorSel(cdelcGlassesOrderDataType, DISABLED_COLOR_SEL);
			pRow->PutCellBackColor(cdelcGlassesOrderDataID, DISABLED_COLOR);
			pRow->PutCellBackColorSel(cdelcGlassesOrderDataID, DISABLED_COLOR_SEL);
			// (r.gonet 08/03/2012) - PLID 51735 - Added Wound Care Data Type
			pRow->PutCellBackColor(cdelcWoundCareDataType, DISABLED_COLOR);
			pRow->PutCellBackColorSel(cdelcWoundCareDataType, DISABLED_COLOR_SEL);
			// (j.gruber 2013-10-21 09:11) - PLID 59101 - no codes for labels
			_variant_t varNull;
			varNull.vt = VT_NULL;
			pRow->PutValue(cdelcCodes, varNull);
			pRow->PutCellLinkStyle(cdelcCodes, NXDATALIST2Lib::dlLinkStyleFalse);

			// (j.gruber 2014-07-17 13:30) - PLID 62621 - When editing multi & single select lists, table row sand columns,  add a new checkbox column labeled Keyword to the right of the action column - Loading
			pRow->PutValue(cdelcUseKeyword, g_cvarNull);
		}

		//TES 3/14/2011 - PLID 42757 - Make sure the GlassesOrderDataType field matches the selected column type
		ReflectColumnType(pRow);
		//TES 3/14/2011 - PLID 42757 - Make sure the GlassesOrderDataID field matches the selected GlassesOrderDataType
		ReflectGlassesOrderDataType(pRow, TRUE);
	}
	return pRow;
}

void CEmrItemEntryDlg::ReflectDataElementList(long nSetSelDataElementID)
{
	//TES 3/14/2011 - PLID 42784 - If a spell check is going on, don't touch the datalist, but remember that we need to update it
	// after the spell check is done.
	if(m_bSpellCheckInProgress) {
		m_bSpellCheckMadeChange = true;
		return;
	}

	long nNewSelect = CalcDataTypeByCurSelection();

	// We may need to remember what our selection was previously
	long nPriorSelectedSortOrderNumber, nPriorSelectedSortOrderNumberColumn;
	if (nSetSelDataElementID == sdeidPriorSelection) {
		//TES 3/14/2011 - PLID 42784 - Converted to datalist2
		NXDATALIST2Lib::IRowSettingsPtr pCurSel = m_pdlDataElementList->CurSel;
		if (pCurSel != NULL) {
			nPriorSelectedSortOrderNumber = pCurSel->GetValue(delcSortOrder);
		} else {
			nPriorSelectedSortOrderNumber = sdeidClearSelection;
		}
		//TES 3/14/2011 - PLID 42784 - Converted to datalist2
		pCurSel = m_pdlColumnDataElementList->CurSel;
		if (pCurSel != NULL) {
			nPriorSelectedSortOrderNumberColumn = pCurSel->GetValue(cdelcSortOrder);
		} else {
			nPriorSelectedSortOrderNumberColumn = sdeidClearSelection;
		}
	}

	// Clear the existing list
	m_pdlDataElementList->Clear();
	m_pdlColumnDataElementList->Clear();

	// Show or hide the 'inactive' column apporpriately
	NXDATALIST2Lib::IColumnSettingsPtr pCol = m_pdlDataElementList->GetColumn(delcInactive);
	if (IsDlgButtonChecked(IDC_SHOW_INACTIVE_ELEMENTS)) {
		pCol->PutColumnStyle(NXDATALIST2Lib::csVisible|NXDATALIST2Lib::csFixedWidth|NXDATALIST2Lib::csEditable);
		pCol->PutStoredWidth(50);
	} else {
		pCol->PutColumnStyle(NXDATALIST2Lib::csVisible|NXDATALIST2Lib::csFixedWidth|NXDATALIST2Lib::csEditable);
		pCol->PutStoredWidth(0);
	}

	// (j.jones 2007-08-15 11:50) - PLID 27053 - show or hide the UseEMCoding columns
	BOOL bUseEMCodingRow = NeedTableRowEMColumn();
	BOOL bUseEMCodingColumn = NeedTableColumnEMColumn();
	// (j.jones 2011-03-08 12:25) - PLID 42282 - supported E/M categories per item
	BOOL bUseEMCodeCategoryIDPerRow = NeedTableRowEMCodeCategoryColumn();
	BOOL bUseEMCodeCategoryIDPerColumn = NeedTableColumnEMCodeCategoryColumn();

	//show/hide the UseEMCoding column in the Row list
	pCol = m_pdlDataElementList->GetColumn(delcUseEMCoding);
	if (bUseEMCodingRow) {
		pCol->PutColumnStyle(NXDATALIST2Lib::csVisible|NXDATALIST2Lib::csFixedWidth|NXDATALIST2Lib::csEditable);
		pCol->PutStoredWidth(35);
	} else {
		pCol->PutColumnStyle(NXDATALIST2Lib::csVisible|NXDATALIST2Lib::csFixedWidth|NXDATALIST2Lib::csEditable);
		pCol->PutStoredWidth(0);
	}

	//show/hide the UseEMCoding column in the Column list
	pCol = m_pdlColumnDataElementList->GetColumn(cdelcUseEMCoding);
	if (bUseEMCodingColumn) {
		pCol->PutColumnStyle(NXDATALIST2Lib::csVisible|NXDATALIST2Lib::csFixedWidth|NXDATALIST2Lib::csEditable);
		pCol->PutStoredWidth(35);
	} else {
		pCol->PutColumnStyle(NXDATALIST2Lib::csVisible|NXDATALIST2Lib::csFixedWidth|NXDATALIST2Lib::csEditable);
		pCol->PutStoredWidth(0);
	}

	// (j.jones 2011-03-08 12:25) - PLID 42282 - added EMCodeCategoryID
	//show/hide the EMCodeCategory column in the Row list
	pCol = m_pdlDataElementList->GetColumn(delcEMCodeCategoryID);
	if (bUseEMCodeCategoryIDPerRow) {
		pCol->PutColumnStyle(NXDATALIST2Lib::csVisible|NXDATALIST2Lib::csEditable);
		pCol->PutStoredWidth(100);
	} else {
		pCol->PutColumnStyle(NXDATALIST2Lib::csVisible|NXDATALIST2Lib::csFixedWidth|NXDATALIST2Lib::csEditable);
		pCol->PutStoredWidth(0);
	}

	//show/hide the EMCodeCategory column in the Column list
	pCol = m_pdlColumnDataElementList->GetColumn(cdelcEMCodeCategoryID);
	if (bUseEMCodeCategoryIDPerColumn) {
		pCol->PutColumnStyle(NXDATALIST2Lib::csVisible|NXDATALIST2Lib::csEditable);
		pCol->PutStoredWidth(100);
	} else {
		pCol->PutColumnStyle(NXDATALIST2Lib::csVisible|NXDATALIST2Lib::csFixedWidth|NXDATALIST2Lib::csEditable);
		pCol->PutStoredWidth(0);
	}

	// (z.manning, 9/16/05, PLID 17249)
	// If maintaining the current list and we're in the current list's tab, then hide the default column
	// as there's no reason to have a default option for just the current list.  If the user wants it to be
	// checked, they can just check it!  Also hide the inactive column.
	// (c.haag 2006-07-05 16:51) - PLID 19862 - This is obselete since we no longer have a current list
	//if(m_bMaintainCurrentList && m_pSelectListTab->GetCurSel() == sltCurrentList) {
	//	m_pdlDataElementList->GetColumn(delcDefault)->PutStoredWidth(0);
	//	pCol->PutStoredWidth(0);
	//}

	pCol = m_pdlColumnDataElementList->GetColumn(cdelcInactive);
	if (IsDlgButtonChecked(IDC_SHOW_INACTIVE_ELEMENTS)) {
		pCol->PutColumnStyle(NXDATALIST2Lib::csVisible|NXDATALIST2Lib::csFixedWidth|NXDATALIST2Lib::csEditable);
		pCol->PutStoredWidth(50);
	} else {
		pCol->PutColumnStyle(NXDATALIST2Lib::csVisible|NXDATALIST2Lib::csFixedWidth|NXDATALIST2Lib::csEditable);
		pCol->PutStoredWidth(0);
	}

	//TES 3/11/2011 - PLID 42757 - Added Glasses Order data
	long nColumnWidth = 0;
	long nVisible = 0;
	//TES 4/6/2012 - PLID 49367 - There's a different checkbox for tables now
	if(((IsDlgButtonChecked(IDC_RADIO_LIST_SELECT) || IsDlgButtonChecked(IDC_RADIO_LIST_MULTISELECT)) && IsDlgButtonChecked(IDC_ASSOCIATE_WITH_GLASSES_ORDER))
		|| (IsDlgButtonChecked(IDC_RADIO_TABLE) && IsDlgButtonChecked(IDC_ASSOCIATE_WITH_GLASSES_ORDER_OR_CL))) {
		nColumnWidth = 35;
		nVisible = NXDATALIST2Lib::csVisible;
	}
	pCol = m_pdlDataElementList->GetColumn(delcGlassesOrderDataType);
	pCol->PutColumnStyle(nVisible|NXDATALIST2Lib::csEditable);
	pCol->PutStoredWidth(nColumnWidth);
	//TES 3/11/2011 - PLID 42757 - Now, what Glasses Order fields are available?
	if(IsDlgButtonChecked(IDC_RADIO_TABLE)) {
		//TES 3/11/2011 - PLID 42757 - This is a table row, the only option is to be a Lens.
		pCol->PutComboSource(_bstr_t(FormatString("-1; ;%i;%s;",godtLens,GetGlassesOrderDataTypeDescription(godtLens))));
	}
	else {
		//TES 3/11/2011 - PLID 42757 - This is a list item, it can be a design, treatment, or material
		pCol->PutComboSource(_bstr_t(FormatString("-1; ;%i;%s;%i;%s;%i;%s;",
			godtDesign,GetGlassesOrderDataTypeDescription(godtDesign),
			godtMaterial,GetGlassesOrderDataTypeDescription(godtMaterial),
			godtTreatment,GetGlassesOrderDataTypeDescription(godtTreatment))));
	}
	pCol = m_pdlDataElementList->GetColumn(delcGlassesOrderDataID);
	pCol->PutColumnStyle(nVisible|NXDATALIST2Lib::csEditable);
	pCol->PutStoredWidth(nColumnWidth);
	//TES 3/11/2011 - PLID 42757 - Table columns are based on the column type, so they'll be set up when the rows are filled
	pCol = m_pdlColumnDataElementList->GetColumn(cdelcGlassesOrderDataType);
	pCol->PutColumnStyle(nVisible|NXDATALIST2Lib::csEditable);
	pCol->PutStoredWidth(nColumnWidth);
	pCol = m_pdlColumnDataElementList->GetColumn(cdelcGlassesOrderDataID);
	pCol->PutColumnStyle(nVisible|NXDATALIST2Lib::csEditable);
	pCol->PutStoredWidth(nColumnWidth);

	{
		// (r.gonet 08/03/2012) - PLID 51735 - Fill the Wound Care Data Type column with every possible data type
		nColumnWidth = 0;
		nVisible = 0;
		if(IsDlgButtonChecked(IDC_RADIO_TABLE) && IsDlgButtonChecked(IDC_USE_WITH_WOUND_CARE_CALC)) {
			nColumnWidth = 70;
			nVisible = NXDATALIST2Lib::csVisible;
		}
		NXDATALIST2Lib::IColumnSettingsPtr pColumnDlColumn = m_pdlColumnDataElementList->GetColumn(cdelcWoundCareDataType);
		pColumnDlColumn->PutColumnStyle(nVisible|NXDATALIST2Lib::csEditable);
		pColumnDlColumn->PutStoredWidth(nColumnWidth);

		//TES 3/11/2011 - PLID 42757 - Now, what Glasses Order fields are available?
		if(IsDlgButtonChecked(IDC_RADIO_TABLE)) {
			CString strWoundCareComboSource = FormatString(
				"%li;%s;"
				"%li;%s;"
				"%li;%s;"
				"%li;%s;"
				"%li;%s;"
				"%li;%s;"
				"%li;%s;",
				(long)wcdtNone, " ",
				(long)wcdtWoundSurfaceArea, GetWoundCareDataTypeDescription(wcdtWoundSurfaceArea),
				(long)wcdtSkinDebridement, GetWoundCareDataTypeDescription(wcdtSkinDebridement),
				(long)wcdtSubQDebridement, GetWoundCareDataTypeDescription(wcdtSubQDebridement),
				(long)wcdtMuscleDebridement, GetWoundCareDataTypeDescription(wcdtMuscleDebridement),
				(long)wcdtBoneDebridement, GetWoundCareDataTypeDescription(wcdtBoneDebridement),
				(long)wcdtNoDebridement, GetWoundCareDataTypeDescription(wcdtNoDebridement));
			pColumnDlColumn->PutComboSource(_bstr_t(strWoundCareComboSource));
		} else {
			pColumnDlColumn->PutComboSource(_bstr_t(""));
		}
	}
	
	// Refill the list
	BOOL bShowInactiveDataElements = IsDlgButtonChecked(IDC_SHOW_INACTIVE_ELEMENTS);
	// (a.walling 2007-11-05 16:08) - PLID 27980 - VS2008 - for() loops
	long i = 0;
	// (c.haag 2011-10-28) - PLID 46164 - We used to call AddRowSorted in a loop. We should only be sorting 
	// at the end because it's faster.
	if (m_aryCurDataElements.GetSize() > 0)
	{
		for (i=0; i<m_aryCurDataElements.GetSize(); i++) {
			CEmrInfoDataElement *peide = m_aryCurDataElements.GetAt(i);
			if (!peide->m_bInactive || bShowInactiveDataElements) {
				if(peide->m_nListType < 3) {
					// (z.manning, 08/31/05, PLID 17249)
					// If the current list tab is selected, make sure the data element is in the current list before showing it
					// (c.haag 2006-07-05 16:51) - PLID 19862 - This is obselete since we no longer have a current list
					//if(m_bMaintainCurrentList && (m_pSelectListTab->GetCurSel() == sltCurrentList) && nNewSelect == m_nDataType && (FindInCurrentList(peide->m_strData) == -1)) {
					//	continue;
					//}
					//TES 3/14/2011 - PLID 42784 - Converted to datalist2
					m_pdlDataElementList->AddRowAtEnd(CreateDatalistRowFromDataElement(peide), NULL);
				}
				else {
					m_pdlColumnDataElementList->AddRowAtEnd(CreateDatalistRowFromDataElement(peide), NULL);
				}
			}
			// (c.haag 2006-07-05 16:51) - PLID 19862 - This is obselete since we no longer have a current list
			//else if(m_bMaintainCurrentList && m_pSelectListTab->GetCurSel() == sltCurrentList && nNewSelect == m_nDataType && FindInCurrentList(peide->m_strData) != -1) {
				// It's ok for the current list to contain inactive elements
				//m_pdlDataElementList->AddRow(CreateDatalistRowFromDataElement(peide));
			//}
		}

		// (j.jones 2012-09-20 12:58) - PLID 52316 - will update the ParentLabelID column's
		// dropdown list with all current labels
		RecalculateAndApplyParentLabelComboSql();

		m_pdlDataElementList->Sort();
		m_pdlColumnDataElementList->Sort();
	}

	// Set the appropriate selection
	if (i > 0) {
		if (nSetSelDataElementID == sdeidFirstInList) {
			// Just set it to the first element in the list whatever it is
			m_pdlDataElementList->CurSel = m_pdlDataElementList->GetFirstRow();
		} else if (nSetSelDataElementID == sdeidClearSelection) {
			// Easy, clear the selection
			//TES 3/14/2011 - PLID 42784 - Converted to datalist2
			m_pdlDataElementList->CurSel = NULL;
		} else if (nSetSelDataElementID == sdeidPriorSelection) {
			// Set it to the prior selected id if there was one
			if (nPriorSelectedSortOrderNumber != sdeidClearSelection) {
				//TES 3/14/2011 - PLID 42784 - Converted to datalist2
				long nResult = m_pdlDataElementList->TrySetSelByColumn_Deprecated(delcSortOrder, nPriorSelectedSortOrderNumber);
				if (nResult == NXDATALIST2Lib::sriNoRow) {
					// We had a selection before, but we can't find it now because it's not there.  We have to 
					// default to the next spot in the sort order.
					BOOL bFoundRow = FALSE;
					//TES 3/14/2011 - PLID 42784 - Converted to datalist2
					NXDATALIST2Lib::IRowSettingsPtr pRow = m_pdlDataElementList->GetFirstRow();
					while (pRow) {
						if (AsLong(pRow->GetValue(delcSortOrder)) >= nPriorSelectedSortOrderNumber) {
							// Found it
							m_pdlDataElementList->TrySetSelByColumn_Deprecated(delcSortOrder, pRow->GetValue(delcSortOrder));
							bFoundRow = TRUE;
							break;
						}
						pRow = pRow->GetNextRow();
					}
					// If we still didn't find it, just set to the last row
					if (!bFoundRow) {
						if (m_pdlDataElementList->GetRowCount() > 0) {
							//TES 3/14/2011 - PLID 42784 - Converted to datalist2
							m_pdlDataElementList->TrySetSelByColumn_Deprecated(delcSortOrder, m_pdlDataElementList->GetLastRow()->GetValue(delcSortOrder));		
						} else {
							m_pdlDataElementList->CurSel = NULL;
						}
					}
				} 
			} else {
				// There was no prior selection so make sure there still isn't one
				//TES 3/14/2011 - PLID 42784 - Converted to datalist2
				m_pdlDataElementList->CurSel = NULL;
			}
		} else {
			// Set it to the specified id because it's a real id (not a "special id")
			NXDATALIST2Lib::IRowSettingsPtr pResult = m_pdlDataElementList->SetSelByColumn(delcID, nSetSelDataElementID);
			if (pResult == NULL) {
				m_pdlDataElementList->CurSel = m_pdlDataElementList->GetFirstRow();
			}
		}
	} else {
		// There aren't any rows so set it to no selection (that's our only choice)
		//TES 3/14/2011 - PLID 42784 - Converted to datalist2
		m_pdlDataElementList->CurSel = NULL;
	}

	//now repeat for columns
	for (i=0; i<m_aryCurColumnDataElements.GetSize(); i++) {
		CEmrInfoDataElement *peide = m_aryCurColumnDataElements.GetAt(i);
		if (!peide->m_bInactive || bShowInactiveDataElements) {
			//TES 3/14/2011 - PLID 42784 - Converted to datalist2
			if(peide->m_nListType < 3)
				m_pdlDataElementList->AddRowSorted(CreateDatalistRowFromDataElement(peide), NULL);
			else
				m_pdlColumnDataElementList->AddRowSorted(CreateDatalistRowFromDataElement(peide), NULL);
		}
	}

	// Set the appropriate selection
	if (i > 0) {
		if (nSetSelDataElementID == sdeidFirstInList) {
			// Just set it to the first element in the list whatever it is
			m_pdlColumnDataElementList->CurSel = m_pdlColumnDataElementList->GetFirstRow();
		} else if (nSetSelDataElementID == sdeidClearSelection) {
			// Easy, clear the selection
			m_pdlColumnDataElementList->CurSel = NULL;
		} else if (nSetSelDataElementID == sdeidPriorSelection) {
			// Set it to the prior selected id if there was one
			if (nPriorSelectedSortOrderNumberColumn != sdeidClearSelection) {
				NXDATALIST2Lib::IRowSettingsPtr pResult = m_pdlColumnDataElementList->SetSelByColumn(cdelcSortOrder, nPriorSelectedSortOrderNumberColumn);
				if (pResult == NULL) {
					// We had a selection before, but we can't find it now because it's not there.  We have to 
					// default to the next spot in the sort order.
					BOOL bFoundRow = FALSE;
					//TES 3/14/2011 - PLID 42784 - Converted to datalist2
					NXDATALIST2Lib::IRowSettingsPtr pRow = m_pdlColumnDataElementList->GetFirstRow();
					while(pRow && !bFoundRow) {
						if (AsLong(pRow->GetValue(cdelcSortOrder)) >= nPriorSelectedSortOrderNumberColumn) {
							// Found it
							m_pdlColumnDataElementList->TrySetSelByColumn_Deprecated(cdelcSortOrder, pRow->GetValue(delcSortOrder));
							bFoundRow = TRUE;
						}
						pRow = pRow->GetNextRow();
					}
					// If we still didn't find it, just set to the last row
					if (!bFoundRow) {
						if (m_pdlColumnDataElementList->GetRowCount() > 0) {
							m_pdlColumnDataElementList->TrySetSelByColumn_Deprecated(cdelcSortOrder, m_pdlColumnDataElementList->GetLastRow()->GetValue(cdelcSortOrder));

						} else {
							m_pdlColumnDataElementList->CurSel = NULL;
						}
					}
				} 
			} else {
				// There was no prior selection so make sure there still isn't one
				m_pdlColumnDataElementList->CurSel = NULL;
			}
		} else {
			// Set it to the specified id because it's a real id (not a "special id")
			NXDATALIST2Lib::IRowSettingsPtr pResult = m_pdlColumnDataElementList->SetSelByColumn(cdelcID, nSetSelDataElementID);
			if (pResult == NULL) {
				m_pdlColumnDataElementList->CurSel = m_pdlColumnDataElementList->GetFirstRow();
			}
		}
	} else {
		// There aren't any rows so set it to no selection (that's our only choice)
		m_pdlColumnDataElementList->CurSel = NULL;
	}

	// Show/hide and enable/disable surrounding controls appropriately
	ReflectDataElementSelection();
	
	UpdateVisibleIndices();

	
	// (b.spivey, August 05, 2013) - PLID 40227 - Make sure that the row is visible. 
	if (m_pdlDataElementList->CurSel) {
		m_pdlDataElementList->EnsureRowInView(m_pdlDataElementList->CurSel);
	}
	if(m_pdlColumnDataElementList->CurSel) { 
		m_pdlColumnDataElementList->EnsureRowInView(m_pdlColumnDataElementList->CurSel);
	}

}

void CEmrItemEntryDlg::OnShowInactiveElements() 
{
	try {
		// Refresh the list (the refresh will automatically show or hide the column)
		ReflectDataElementList(sdeidPriorSelection);
		// Remember this user preference
		SetRemotePropertyInt("EMRShowInactiveElements", IsDlgButtonChecked(IDC_SHOW_INACTIVE_ELEMENTS), 0, GetCurrentUserName());
	} NxCatchAll("CEmrItemEntryDlg::OnShowInactiveElements");
}

// (z.manning 2010-02-11 16:10) - PLID 37320 - Same as above but returns the actual data element
CEmrInfoDataElement* CEmrItemEntryDlg::GetCurDataElementBySortOrder(long nSortOrder, BOOL bUseColumnList)
{
	if(bUseColumnList) {
		return m_aryCurColumnDataElements.GetAt(GetCurDataElementArrayIndex(nSortOrder, bUseColumnList));
	}
	else {
		return m_aryCurDataElements.GetAt(GetCurDataElementArrayIndex(nSortOrder, bUseColumnList));
	}
}

long CEmrItemEntryDlg::GetCurDataElementArrayIndex(long nSortOrderNumber, BOOL bUseColumnList)
{
	if(bUseColumnList) {

		// Have to iterate to find mapping
		for (long i = 0; i<m_aryCurColumnDataElements.GetSize(); i++) {
			if (m_aryCurColumnDataElements.GetAt(i)->m_nSortOrder == nSortOrderNumber) {
				return i;
			}
		}
	}
	else {

		// Have to iterate to find mapping
		for (long i = 0; i<m_aryCurDataElements.GetSize(); i++) {
			if (m_aryCurDataElements.GetAt(i)->m_nSortOrder == nSortOrderNumber) {
				return i;
			}
		}
	}
	// If we made it here we couldn't find it!  This represents a flaw somewhere in our synchronization 
	// between the on-screen datalist and the in-memory array of data elements
	ASSERT(FALSE);
	ThrowNxException("Could not find array index for sort order number %li!", nSortOrderNumber);
}

//TES 3/14/2011 - PLID 42784 - Converted to datalist2
void CEmrItemEntryDlg::DoActivateDataElement(NXDATALIST2Lib::IRowSettingsPtr pRow)
{
	// (a.walling 2007-04-04 15:19) - PLID 25459 - Check for Medication permission
	// (will prompt for passwords)
	if (IsSystemCurrentMedicationsItem()) {
		if(!CheckCurrentUserPermissions(bioPatientMedication, sptDynamic0)) {
			return;
		}
	}
	// (z.manning, 08/07/2007) - PLID 25741 - If it's the built-in allergies item, make sure the user has the permission to edit it.
	if(IsSystemAllergiesItem()) {
		if(!CheckCurrentUserPermissions(bioPatientAllergies, sptDynamic0)) {
			return;
		}
	}

	// Get the index in the current array
	//TES 3/14/2011 - PLID 42784 - Converted to datalist2
	long nIndex = GetCurDataElementArrayIndex(VarLong(pRow->GetValue(delcSortOrder)), FALSE);
	// Update the entry both on screen and in memory
	{
		// Update the datalist on screen
		pRow->PutValue(delcInactive, _variant_t(VARIANT_FALSE, VT_BOOL));
		// Update the array in memory
		m_aryCurDataElements.GetAt(nIndex)->m_bInactive = FALSE;

		//find in the current list, if it doesn't exist then add it
		long nCurIndex = FindInCurrentList(m_aryCurDataElements.GetAt(nIndex)->m_strData);
		if(nCurIndex == -1) {
			//add it
			CurrentListItem cli;
			cli.strData = m_aryCurDataElements.GetAt(nIndex)->m_strData;
			cli.bSelected = false;
			cli.bSelectedOnTopic = cli.bSelected; // (a.walling 2008-02-07 11:01) - PLID 14982 - If this is new, there is no way it would be selected, of course
			m_aryCurrentList.Add(cli);
		}
	}

	// (j.jones 2012-09-21 11:59) - PLID 52316 - if a label, update the ParentLabelID column's
	// dropdown list with all current labels
	if(m_aryCurDataElements.GetAt(nIndex)->m_bIsLabel) {
		RecalculateAndApplyParentLabelComboSql();
	}

	// No need to see if we're hiding inactive elements because if we were then the user wouldn't have been able to right-click on this one
	
	// (z.manning, 05/30/2008) - PLID 16443 - This may have caused the visible order of the rows to 
	// change so we need to update references to rows in any calculated field formulas.
	UpdateFormulaReferences(m_aryCurDataElements.GetAt(nIndex));
}

//TES 3/14/2011 - PLID 42784 - Converted to datalist2
void CEmrItemEntryDlg::DoInactivateDataElement(NXDATALIST2Lib::IRowSettingsPtr pRow)
{
	// Get the index in the current array
	//TES 3/14/2011 - PLID 42784 - Converted to datalist2
	long nIndex = GetCurDataElementArrayIndex(VarLong(pRow->GetValue(delcSortOrder)), FALSE);
	CEmrInfoDataElement *peide = m_aryCurDataElements.GetAt(nIndex);

	// (a.walling 2007-04-04 15:19) - PLID 25459 - Check for Medication permission
	// (will prompt for passwords)
	if (IsSystemCurrentMedicationsItem()) {
		if(!CheckCurrentUserPermissions(bioPatientMedication, sptDynamic0)) {
			return;
		}
	}
	// (z.manning, 08/07/2007) - PLID 25741 - If it's the built-in allergies item, make sure the user has the permission to edit it.
	if(IsSystemAllergiesItem()) {
		if(!CheckCurrentUserPermissions(bioPatientAllergies, sptDynamic0)) {
			return;
		}
	}

	// (z.manning, 05/30/2008) - PLID 16443 - Do not let them inactivate a row that is referenced
	// in a formula.
	CString strReferencingRow;
	if(IsDataElementReferencedInAnyFormula(peide, m_aryCurDataElements, m_aryCurColumnDataElements, strReferencingRow)) {
		MessageBox(FormatString("This item is referenced in the formula for item '%s.'\r\n\r\n"
			"You may not inactivate an item that is referenced in a formula.", strReferencingRow));
		//TES 3/14/2011 - PLID 42784 - Converted to datalist2
		pRow->PutValue(delcInactive, _variant_t(false));
		return;
	}

	// (a.wilson 2012-07-02 15:54) - PLID 51306
	CString strGraphData = IsDataIDAssignedInGraphing(VarLong(pRow->GetValue(delcID)));
	if (!strGraphData.IsEmpty()) {
		MsgBox("The following item is assigned in graphing.\r\n\r\nAreas Assigned:\r\n%s\r\n"
			"You may not inactivate an item that is assigned in graphing.", strGraphData);
		pRow->PutValue(delcInactive, _variant_t(false));
		return;
	}

	// (z.manning, 05/30/2008) - PLID 16443 - We clear out the formula when inactivating a calculated field
	// so that the inactive field no longer references any columns. Let's warn about that.
	if(!peide->m_strFormula.IsEmpty()) {
		if(IDYES != MessageBox("Inactivating this item will delete its formula. Are you sure you want to inactivate it?", NULL, MB_YESNO)) {
			//TES 3/14/2011 - PLID 42784 - Converted to datalist2
			pRow->PutValue(delcInactive, _variant_t(false));
			return;
		}
	}

	// (c.haag 2011-04-07) - PLID 42814 - Warn the users about common lists using the item
	{
		CStringArray astrInUseCommonLists; // Names of common lists that use this item
		int i;
		for (i=0; i < m_CommonListCollection.GetListCount(); i++)
		{
			CEmrInfoCommonList list = m_CommonListCollection.GetListByIndex(i);
			if (list.DoesExist(peide)) {
				// If we get here, this list is using the item. Add it to astrInUseCommonLists
				astrInUseCommonLists.Add(list.GetName());
			}
		}
		if (astrInUseCommonLists.GetSize() > 0)
		{
			CString strWarning = "This item is in use by the following common lists:\r\n\r\n";
			for (i=0; i < astrInUseCommonLists.GetSize(); i++)
			{
				if (i >= 20) {
					strWarning += "<more...>\r\n";
					break;
				}
				else {
					strWarning += astrInUseCommonLists[i] + "\r\n";
				}
			}
			strWarning += "\r\nThe item will still be assigned to those lists, but will not appear in them on patient charts. Are you sure you wish to inactivate it?";
			if (IDNO == MessageBox(strWarning, NULL, MB_YESNO | MB_ICONQUESTION)) {
				pRow->PutValue(delcInactive, _variant_t(false));
				return;
			}
		}
	}

	// (j.jones 2012-09-21 13:18) - PLID 52316 - if a label, see if any row is using this label as a parent
	if(peide->m_bIsLabel && (IsDlgButtonChecked(IDC_RADIO_LIST_SELECT) || IsDlgButtonChecked(IDC_RADIO_LIST_MULTISELECT))) {
		BOOL bInUse = FALSE;
		for(int i=0;i<m_aryCurDataElements.GetSize() && !bInUse; i++) {
			CEmrInfoDataElement *peideCheck = m_aryCurDataElements.GetAt(i);
			if(peideCheck != NULL && peideCheck->m_peideParentLabelPtr == peide) {
				//flag that it is in use
				bInUse = TRUE;
			}
		}

		if(bInUse && IDYES != MessageBox("Inactivating this label will clear the parent selection from all list items referencing this label.\n\n"
			"Are you sure you want to inactivate it?", "Practice", MB_ICONEXCLAMATION|MB_YESNO)) {
			pRow->PutValue(delcInactive, _variant_t(false));
			return;
		}
	}

	// Update the entry both on screen and in memory
	{
		// Update the datalist on screen
		//TES 3/14/2011 - PLID 42784 - Converted to datalist2
		pRow->PutValue(delcInactive, _variant_t(VARIANT_TRUE, VT_BOOL));
		// If we're hiding inactive elements we need to remove the row from the on-screen datalist
		if (!IsDlgButtonChecked(IDC_SHOW_INACTIVE_ELEMENTS)) {
			m_pdlDataElementList->RemoveRow(pRow);
		}
		// Update the array in memory
		m_aryCurDataElements.GetAt(nIndex)->m_bInactive = TRUE;
		peide->m_strFormula.Empty();
	}

	// (j.jones 2012-09-21 11:59) - PLID 52316 - if a label, update the ParentLabelID column's
	// dropdown list with all current labels, and also remove any references to this now-inactive label
	if(peide->m_bIsLabel) {
		TryRemoveParentLabelReferences(peide);

		RecalculateAndApplyParentLabelComboSql();
	}
	
	// (z.manning, 05/30/2008) - PLID 16443 - This may have caused the visible order of the rows to 
	// change so we need to update references to rows in any calculated field formulas.
	UpdateFormulaReferences();
}

//TES 3/14/2011 - PLID 42784 - Converted to datalist2
void CEmrItemEntryDlg::DoActivateColumnDataElement(NXDATALIST2Lib::IRowSettingsPtr pRow)
{
	// Get the index in the current array
	long nIndex = GetCurDataElementArrayIndex(VarLong(pRow->GetValue(cdelcSortOrder)), TRUE);
	// Update the entry both on screen and in memory
	{
		// Update the datalist on screen
		pRow->PutValue(cdelcInactive, _variant_t(VARIANT_FALSE, VT_BOOL));
		// Update the array in memory
		m_aryCurColumnDataElements.GetAt(nIndex)->m_bInactive = FALSE;
	}
	// No need to see if we're hiding inactive elements because if we were then the user wouldn't have been able to right-click on this one

	// (z.manning, 05/30/2008) - PLID 16443 - This may have caused the visible order of the columns to 
	// change so we need to update references to columns in any calculated field formulas.
	UpdateFormulaReferences(m_aryCurColumnDataElements.GetAt(nIndex));

	// (j.gruber 2013-10-21 09:11) - PLID 59101 - no codes for inactive columns
	_variant_t varNull;
	varNull.vt = VT_NULL;
	pRow->PutValue(cdelcCodes, varNull);
}

//TES 3/14/2011 - PLID 42784 - Converted to datalist2
void CEmrItemEntryDlg::DoInactivateColumnDataElement(NXDATALIST2Lib::IRowSettingsPtr pRow)
{
	// Get the index in the current array
	long nIndex = GetCurDataElementArrayIndex(VarLong(pRow->GetValue(cdelcSortOrder)), TRUE);
	CEmrInfoDataElement *peide = m_aryCurColumnDataElements.GetAt(nIndex);

	// (c.haag 2007-01-29 16:08) - PLID 24423 - If the following is true, then this is
	// the Rx column of the internal Current Medications item. Do not allow the user to
	// inactivate it
	if (IsSystemCurrentMedicationsItem() && 0 == nIndex) {
		MsgBox("You may not inactivate the Rx column of the system Current Medications item");
		// Make sure the datalist element is checked
		pRow->PutValue(cdelcInactive, _variant_t(VARIANT_FALSE, VT_BOOL));
		return;
	}
	// (c.haag 2007-04-05 11:53) - PLID 25468 - Do not allow users to inactive the Yes column
	// of the official Allergies table
	if (IsSystemAllergiesItem() && 0 == nIndex) {
		MsgBox("You may not inactivate the Yes column of the system Allergies item");
		// Make sure the datalist element is checked
		pRow->PutValue(cdelcInactive, _variant_t(VARIANT_FALSE, VT_BOOL));
		return;
	}

	// (z.manning 2010-02-12 14:02) - PLID 37320 - Do not allow inactivation of built-in smart stamp table columns
	// (z.manning 2010-04-09 10:48) - PLID 37937 - We allow this now
	/*if(IsSmartStampListSubType(peide->m_nListSubType)) {
		MessageBox("You may not inactivate this because it is needed by Smart Stamps.");
		m_pdlColumnDataElementList->PutValue(nDatalistSelIndex, cdelcInactive, _variant_t(VARIANT_FALSE, VT_BOOL));
		return;
	}*/

	// (z.manning, 05/30/2008) - PLID 16443 - Do not let them inactivate a column that is referenced
	// in a formula.
	CString strReferencingColumn;
	if(IsDataElementReferencedInAnyFormula(peide, m_aryCurDataElements, m_aryCurColumnDataElements, strReferencingColumn)) {
		MessageBox(FormatString("This item is referenced in the formula for item '%s.'\r\n\r\n"
			"You may not inactivate an item that is referenced in a formula.", strReferencingColumn));
		pRow->PutValue(cdelcInactive, _variant_t(false));
		return;
	}

	// (a.wilson 2012-07-02 16:12) - PLID 51306
	CString strGraphData = IsDataIDAssignedInGraphing(VarLong(pRow->GetValue(cdelcID)));
	if (!strGraphData.IsEmpty()) {
		MsgBox("The following item is assigned in graphing.\r\n\r\nAreas Assigned:\r\n%s\r\n"
			"You may not inactivate an item that is assigned in graphing.", strGraphData);
		pRow->PutValue(cdelcInactive, _variant_t(false));
		return;
	}

	// (z.manning, 05/30/2008) - PLID 16443 - We clear out the formula when inactivating a calculated field
	// so that the inactive field no longer references any columns. Let's warn about that.
	if(!peide->m_strFormula.IsEmpty()) {
		if(IDYES != MessageBox("Inactivating this item will delete its formula. Are you sure you want to inactivate it?", NULL, MB_YESNO)) {
			pRow->PutValue(cdelcInactive, _variant_t(false));
			return;
		}
	}

	// (r.gonet 08/03/2012) - PLID 51735 - When the user inactivates a column, then make sure to remove the association
	//  between it and a wound care data type. This is because there can only be one column per table with a particular wound care data type
	//  and there must be one of each data type. What sense would it make to have 1 active with type A and 15 inactive with type A?
	if((EWoundCareDataType)VarLong(pRow->GetValue(cdelcWoundCareDataType), wcdtNone) != wcdtNone) {
		if(IDYES != MessageBox("Inactivating this item will disassociate it from Wound Care Coding. Are you sure you want to inactivate it?", NULL, MB_YESNO)) {
			pRow->PutValue(cdelcInactive, _variant_t(false));
			return;
		} else {
			pRow->PutValue(cdelcWoundCareDataType, g_cvarNull);
		}
	}

	// Update the entry both on screen and in memory
	{
		// Update the datalist on screen
		pRow->PutValue(cdelcInactive, _variant_t(VARIANT_TRUE, VT_BOOL));
		// If we're hiding inactive elements we need to remove the row from the on-screen datalist
		if (!IsDlgButtonChecked(IDC_SHOW_INACTIVE_ELEMENTS)) {
			m_pdlColumnDataElementList->RemoveRow(pRow);
		}
		// Update the array in memory
		peide->m_bInactive = TRUE;
		peide->m_strFormula.Empty();
	}

	// (j.gruber 2013-10-21 09:11) - PLID 59101 - put the codes back
	CString strCodes;
	strCodes.Format("<%li Codes(s)>", peide->m_aryCodes.GetSize());
	pRow->PutValue(cdelcCodes, _bstr_t(strCodes));

	// (z.manning, 05/30/2008) - PLID 16443 - This may have caused the visible order of the columns to 
	// change so we need to update references to columns in any calculated field formulas.
	UpdateFormulaReferences();
}

void CEmrItemEntryDlg::OnContextMenu(CWnd* pWnd, CPoint point) 
{
	try {
		// Handle the context menu
		if (pWnd->GetSafeHwnd() && pWnd->GetSafeHwnd() == GetDlgItem(IDC_EMR_DATA_LIST)->GetSafeHwnd())
		{
			// The context menu for the data element list is based on the current selection
			//TES 3/14/2011 - PLID 42784 - Converted to datalist2
			NXDATALIST2Lib::IRowSettingsPtr pCurSel = m_pdlDataElementList->CurSel;
			if (pCurSel != NULL)
			{
				// Build the menu for the current row

				enum eRowListMenuItem {
					rlmiDelete = 1,
					rlmiActivate,
					rlmiInactivate,
					rlmiEditFormula,
					rlmiAddNewBefore,
					rlmiAddNewMultiBefore,
					rlmiAddNewAfter,
					rlmiAddNewMultiAfter,
					rlmiEditSentenceFormat,
					rlmiOverrideKeyword,   // (j.gruber 2014-07-21 14:26) - PLID 62625
					rlmiCheckAllKeywords, // (j.gruber 2014-07-25 13:20) - PLID 62629 - When editing multi-select lists, single-select lists, tables, and table dropdowns , add a right click and Check All and Uncheck All for the Keyword column to quickly check or uncheck all options.
					rlmiUncheckAllKeywords, // (j.gruber 2014-07-25 13:20) - PLID 62629 - When editing multi-select lists, single-select lists, tables, and table dropdowns , add a right click and Check All and Uncheck All for the Keyword column to quickly check or uncheck all options.					
				};

				CEmrInfoDataElement *peide = m_aryCurDataElements.GetAt(GetCurDataElementArrayIndex(VarLong(pCurSel->GetValue(delcSortOrder)), FALSE));

				CMenu mnu;
				mnu.CreatePopupMenu();
				mnu.AppendMenu(MF_ENABLED|MF_STRING|MF_BYPOSITION, rlmiDelete, "&Delete");
				//TES 3/14/2011 - PLID 42784 - Converted to datalist2
				if (VarBool(pCurSel->GetValue(delcInactive))) {
					mnu.AppendMenu(MF_ENABLED|MF_STRING|MF_BYPOSITION, rlmiActivate, "A&ctivate");
				} else {
					mnu.AppendMenu(MF_ENABLED|MF_STRING|MF_BYPOSITION, rlmiInactivate, "&Inactivate");
				}

				// (z.manning 2008-06-06 08:38) - PLID 16643 - Added option to edit formula
				if(IsDlgButtonChecked(IDC_RADIO_TABLE) == BST_CHECKED)
				{
					BOOL bInactive = VarBool(pCurSel->GetValue(delcInactive));
					if(!bInactive) {
						mnu.AppendMenu(MF_ENABLED|MF_SEPARATOR|MF_BYPOSITION);
						mnu.AppendMenu(MF_ENABLED|MF_STRING|MF_BYPOSITION, rlmiEditFormula, "&Edit Formula");
					}
				}
				else
				{
					mnu.AppendMenu(MF_ENABLED|MF_SEPARATOR|MF_BYPOSITION);
					// (z.manning 2011-11-07 11:24) - PLID 46309 - Added a right click option to edit the sentence format of list elements.
					mnu.AppendMenu(MF_ENABLED|MF_STRING|MF_BYPOSITION, rlmiEditSentenceFormat, "Edit &Sentence Format");
				}

				// (j.jones 2009-08-13 09:32) - PLID 31730 - allow a right-click menu to insert above,
				// or insert below the active row
				long nSortOrder = -1;
				if (!IsDlgButtonChecked(IDC_AUTO_ALPHABETIZE_LIST_DATA)) {
					nSortOrder = VarLong(pCurSel->GetValue(delcSortOrder));
					CString strAddNewBefore, strAddNewAfter;
					CString strAddNewMultiBefore, strAddNewMultiAfter;
					if (!IsDlgButtonChecked(IDC_TABLE_ROWS_AS_FIELDS) || !IsDlgButtonChecked(IDC_RADIO_TABLE)) {
						strAddNewBefore = "Add New Row &Before This Row...";
						strAddNewAfter = "Add New Row &After This Row...";
						strAddNewMultiBefore = "Add Multiple Rows Be&fore This Row...";
						strAddNewMultiAfter = "Add Multiple Rows Af&ter This Row...";
					}
					else {
						strAddNewBefore = "Add New Column &Before This Column...";
						strAddNewAfter = "Add New Column &After This Column...";
						strAddNewMultiBefore = "Add Multiple Columns Be&fore This Column...";
						strAddNewMultiAfter = "Add Multiple Columns Af&ter This Column...";
					}

					mnu.AppendMenu(MF_SEPARATOR | MF_BYPOSITION);
					mnu.AppendMenu(MF_ENABLED | MF_STRING | MF_BYPOSITION, rlmiAddNewBefore, strAddNewBefore);
					mnu.AppendMenu(MF_ENABLED | MF_STRING | MF_BYPOSITION, rlmiAddNewMultiBefore, strAddNewMultiBefore);
					mnu.AppendMenu(MF_ENABLED | MF_STRING | MF_BYPOSITION, rlmiAddNewAfter, strAddNewAfter);
					mnu.AppendMenu(MF_ENABLED | MF_STRING | MF_BYPOSITION, rlmiAddNewMultiAfter, strAddNewMultiAfter);			
					
				}

				// (j.gruber 2014-07-21 14:26) - PLID 62625 - add an option to the right click menu below edit sentence format for Edit Search Keywords. This will give the user the ability to manually override search keywords. 				
				mnu.AppendMenu(MF_SEPARATOR | MF_BYPOSITION);
				if (peide->m_bUseKeyword)
				{
					mnu.AppendMenu(MF_ENABLED | MF_STRING | MF_BYPOSITION, rlmiOverrideKeyword, "Edit Search Keywords");
				}
				else {
					mnu.AppendMenu(MF_DISABLED | MF_STRING | MF_BYPOSITION, rlmiOverrideKeyword, "Edit Search Keywords");
				}

				// (j.gruber 2014-07-25 13:20) - PLID 62629 - When editing multi-select lists, single-select lists, tables, and table dropdowns , add a right click and Check All and Uncheck All for the Keyword column to quickly check or uncheck all options.
				mnu.AppendMenu(MF_ENABLED | MF_STRING | MF_BYPOSITION, rlmiCheckAllKeywords, "Check All Keywords");
				mnu.AppendMenu(MF_ENABLED | MF_STRING | MF_BYPOSITION, rlmiUncheckAllKeywords, "Uncheck All Keywords");


				// Pop up the menu and gather the immediate response
				CPoint pt = CalcContextMenuPos(pWnd, point);
				long nMenuResult = mnu.TrackPopupMenu(TPM_LEFTALIGN|TPM_RETURNCMD|TPM_TOPALIGN|TPM_LEFTBUTTON|TPM_RIGHTBUTTON, pt.x, pt.y, this);
				switch (nMenuResult) {
				case rlmiDelete: // delete
					OnDeleteDataItem(FALSE);
					break;
				case rlmiActivate: // activate
					m_pdlCurrentDataElementList = m_pdlDataElementList;
					DoActivateDataElement(pCurSel);
					break;
				case rlmiInactivate: // inactivate
					m_pdlCurrentDataElementList = m_pdlDataElementList;
					DoInactivateDataElement(pCurSel);
					break;
				case rlmiEditFormula:
					m_pdlCurrentDataElementList = m_pdlDataElementList;
					OpenCalculatedFieldEditor(m_aryCurDataElements.GetAt(GetCurDataElementArrayIndex(VarLong(pCurSel->GetValue(delcSortOrder)), FALSE)));
					break;
				// (j.jones 2009-08-13 09:32) - PLID 31730 - allow a right-click menu to insert above,
				// or insert below the active row
				case rlmiAddNewBefore:
					//add before
					if(!IsDlgButtonChecked(IDC_AUTO_ALPHABETIZE_LIST_DATA)) {
						OnAddDataItem(FALSE, nSortOrder);
					}
					break;
				case rlmiAddNewMultiBefore:
					//add multiple before
					if(!IsDlgButtonChecked(IDC_AUTO_ALPHABETIZE_LIST_DATA)) {
						OnAddMultipleDataItem(FALSE, nSortOrder);
					}
					break;
				case rlmiAddNewAfter:
					//add after
					if(!IsDlgButtonChecked(IDC_AUTO_ALPHABETIZE_LIST_DATA)) {
						OnAddDataItem(FALSE, nSortOrder+1);
					}
					break;
				case rlmiAddNewMultiAfter:
					//add multiple after
					if(!IsDlgButtonChecked(IDC_AUTO_ALPHABETIZE_LIST_DATA)) {
						OnAddMultipleDataItem(FALSE, nSortOrder+1);
					}
					break;
				case rlmiEditSentenceFormat:
					EditDataElementSentenceFormat(peide, FALSE);
					break;
				// (j.gruber 2014-07-21 14:26) - PLID 62625 - add an option to the right click menu below edit sentence format for Edit Search Keywords. This will give the user the ability to manually override search keywords. 
				case rlmiOverrideKeyword:
					OnKeywordOverride(pCurSel, FALSE);
					break;
				// (j.gruber 2014-07-25 13:41) - PLID 62629 - When editing multi-select lists, single-select lists, tables, and table dropdowns , add a right click and Check All and Uncheck All for the Keyword column to quickly check or uncheck all options.
				case rlmiCheckAllKeywords:				
					Check_UncheckAllKeywords(TRUE, FALSE);
					break;
				// (j.gruber 2014-07-25 13:41) - PLID 62629 - When editing multi-select lists, single-select lists, tables, and table dropdowns , add a right click and Check All and Uncheck All for the Keyword column to quickly check or uncheck all options.
				case rlmiUncheckAllKeywords:
					Check_UncheckAllKeywords(FALSE, FALSE);
					break;				
				case 0:
					// The user canceled, do nothing
					break;
				default:
					// Unexpected response!
					ASSERT(FALSE);
					ThrowNxException("Unexpected return value %li from context menu!", nMenuResult);
				}
			}
		}
		else if (pWnd->GetSafeHwnd() && pWnd->GetSafeHwnd() == GetDlgItem(IDC_EMR_COLUMN_LIST)->GetSafeHwnd())
		{
			// The context menu for the data element list is based on the current selection
			//TES 3/14/2011 - PLID 42784 - Converted to datalist2
			NXDATALIST2Lib::IRowSettingsPtr pCurSel = m_pdlColumnDataElementList->CurSel;
			if (pCurSel != NULL)
			{
				CEmrInfoDataElement *peide = m_aryCurColumnDataElements.GetAt(GetCurDataElementArrayIndex(VarLong(pCurSel->GetValue(cdelcSortOrder)), TRUE));
				// Build the menu for the current row
				enum eColumnListMenuItem {
					clmiDelete = 1,
					clmiActivate,
					clmiInactivate,
					clmiEditDropdownList,
					clmiEditFormula,
					clmiEditInputMask,
					clmiAddNewBefore,
					clmiAddNewMultiBefore,
					clmiAddNewAfter,
					clmiAddNewMultiAfter,
					clmiEditSentenceFormat, // (z.manning 2010-07-29 09:33) - PLID 36150
					clmiEditAutoNumber, // (z.manning 2010-08-11 11:58) - PLID 40074
					clmiEditAutofillSettings, // (z.manning 2011-03-18 16:50) - PLID 23662
					clmiOverrideKeyword, // (j.gruber 2014-07-21 14:52) - PLID 62626 - When editing tables, add the same keywords override option as in breakdown 3.3 for the bottom section data element when the type is a checkbox.
					clmiCheckAllKeywords,// (j.gruber 2014-07-25 13:45) - PLID 62629 - When editing multi-select lists, single-select lists, tables, and table dropdowns , add a right click and Check All and Uncheck All for the Keyword column to quickly check or uncheck all options.
					clmiUncheckAllKeywords,// (j.gruber 2014-07-25 13:45) - PLID 62629 - When editing multi-select lists, single-select lists, tables, and table dropdowns , add a right click and Check All and Uncheck All for the Keyword column to quickly check or uncheck all options.
					clmiIncludeNameForKeyword, // (j.gruber 2014-12-05 13:00) - PLID 64266 - Add drop down menu for "Add column as keyword"  if reveresed use "Add row as keyword" When right clicking on the "Keyword" option in the emr item entry dlg.  
				};

				CMenu mnu;
				mnu.CreatePopupMenu();
				mnu.AppendMenu(MF_ENABLED|MF_STRING|MF_BYPOSITION, clmiDelete, "&Delete");
				if (VarBool(pCurSel->GetValue(cdelcInactive))) {
					mnu.AppendMenu(MF_ENABLED|MF_STRING|MF_BYPOSITION, clmiActivate, "A&ctivate");
				} else {
					mnu.AppendMenu(MF_ENABLED|MF_STRING|MF_BYPOSITION, clmiInactivate, "&Inactivate");
				}

				BOOL bInactive = VarBool(pCurSel->GetValue(cdelcInactive));
				long nColumnType = VarLong(pCurSel->GetValue(cdelcType),LIST_TYPE_TEXT);
				BYTE nListSubType = VarByte(pCurSel->GetValue(cdelcSubType),LIST_TYPE_TEXT);
				// (z.manning 2011-03-09) - PLID 42722 - Also allow this for text columns
				if(nColumnType == LIST_TYPE_DROPDOWN || nColumnType == LIST_TYPE_TEXT) {
					mnu.AppendMenu(MF_ENABLED|MF_SEPARATOR|MF_BYPOSITION);
					mnu.AppendMenu(MF_ENABLED|MF_STRING|MF_BYPOSITION, clmiEditDropdownList, "Edit Dro&pdown List Contents");
				}
				// (z.manning 2008-06-06 08:37) - PLID 16643 - Added option to edit field's formula.
				// (z.manning 2010-02-12 14:17) - PLID 37320 - No input masks or formulas for smart stamp table columns
				// (j.jones 2011-05-03 16:08) - PLID 43527 - disallow in current medication built-in columns
				if(nColumnType == LIST_TYPE_TEXT && !bInactive
					&& !IsSmartStampListSubType(nListSubType) && !IsCurrentMedicationListSubType(nListSubType)) {
					mnu.AppendMenu(MF_ENABLED|MF_SEPARATOR|MF_BYPOSITION);
					mnu.AppendMenu(MF_ENABLED|MF_STRING|MF_BYPOSITION, clmiEditFormula, "&Edit Formula");
					// (z.manning 2009-01-13 14:58) - PLID 32719 - We can now set an input mask for text columns
					mnu.AppendMenu(MF_ENABLED|MF_STRING|MF_BYPOSITION, clmiEditInputMask, "Edit Input &Mask");
					// (z.manning 2011-03-18 16:49) - PLID 23662 - Option to edit autofill settings
					mnu.AppendMenu(MF_ENABLED|MF_STRING|MF_BYPOSITION, clmiEditAutofillSettings, "Edit Aut&o-fill Settings");
				}

				// (z.manning 2010-08-11 12:02) - PLID 40074
				if(nListSubType == lstSmartStampAutoNumber) {
					mnu.AppendMenu(MF_ENABLED|MF_STRING|MF_BYPOSITION, clmiEditAutoNumber, "Edit A&uto-Number Settings");
				}

				// (z.manning 2010-07-29 09:41) - PLID 36150
				mnu.AppendMenu(MF_ENABLED|MF_STRING|MF_BYPOSITION, clmiEditSentenceFormat, "Edit &Sentence Format");

				// (j.jones 2009-08-13 09:32) - PLID 31730 - allow a right-click menu to insert above,
				// or insert below the active row
				long nSortOrder = -1;
				if(!IsDlgButtonChecked(IDC_AUTO_ALPHABETIZE_LIST_DATA)) {
					nSortOrder = VarLong(pCurSel->GetValue(cdelcSortOrder));
					CString strAddNewBefore, strAddNewAfter;				
					CString strAddNewMultiBefore, strAddNewMultiAfter;	
					if(IsDlgButtonChecked(IDC_TABLE_ROWS_AS_FIELDS) && IsDlgButtonChecked(IDC_RADIO_TABLE)) {
						strAddNewBefore = "Add New Row &Before This Row...";
						strAddNewAfter = "Add New Row &After This Row...";
						strAddNewMultiBefore = "Add Multiple Rows Be&fore This Row...";
						strAddNewMultiAfter = "Add Multiple Rows Af&ter This Row...";
					}
					else {
						strAddNewBefore = "Add New Column &Before This Column...";
						strAddNewAfter = "Add New Column &After This Column...";
						strAddNewMultiBefore = "Add Multiple Columns Be&fore This Column...";
						strAddNewMultiAfter = "Add Multiple Columns Af&ter This Column...";
					}

					mnu.AppendMenu(MF_SEPARATOR|MF_BYPOSITION);
					mnu.AppendMenu(MF_ENABLED|MF_STRING|MF_BYPOSITION, clmiAddNewBefore, strAddNewBefore);
					mnu.AppendMenu(MF_ENABLED|MF_STRING|MF_BYPOSITION, clmiAddNewMultiBefore, strAddNewMultiBefore);
					mnu.AppendMenu(MF_ENABLED|MF_STRING|MF_BYPOSITION, clmiAddNewAfter, strAddNewAfter);
					mnu.AppendMenu(MF_ENABLED|MF_STRING|MF_BYPOSITION, clmiAddNewMultiAfter, strAddNewMultiAfter);
				}

				// (j.gruber 2014-07-21 14:54) - PLID 62626 - When editing tables, add the same keywords override option as in breakdown 3.3 for the bottom section data element when the type is a checkbox.
				//make sure we ahve a separator for our keyword stuff
				BOOL bSeparator = FALSE;
				if (nColumnType == LIST_TYPE_CHECKBOX)
				{
					bSeparator = TRUE;
					mnu.AppendMenu(MF_SEPARATOR | MF_BYPOSITION);
					if (peide->m_bUseKeyword)
					{
						mnu.AppendMenu(MF_ENABLED | MF_STRING | MF_BYPOSITION, clmiOverrideKeyword, "Edit Search Keywords");
					}
					else {
						mnu.AppendMenu(MF_DISABLED | MF_STRING | MF_BYPOSITION, clmiOverrideKeyword, "Edit Search Keywords");
					}
				}

				// (j.gruber 2014-07-25 13:45) - PLID 62629 - When editing multi-select lists, single-select lists, tables, and table dropdowns , add a right click and Check All and Uncheck All for the Keyword column to quickly check or uncheck all options.
				//check to see if we have any checkbox types
				if (HasCheckAllType())
				{
					if (!bSeparator)
					{
						mnu.AppendMenu(MF_SEPARATOR | MF_BYPOSITION);
					}
					mnu.AppendMenu(MF_ENABLED | MF_STRING | MF_BYPOSITION, clmiCheckAllKeywords, "Check All Keywords");
					mnu.AppendMenu(MF_ENABLED | MF_STRING | MF_BYPOSITION, clmiUncheckAllKeywords, "Uncheck All Keywords");

				}

				// (j.gruber 2014-12-05 13:04) - PLID 64266 - Add drop down menu for "Add column as keyword"  if reveresed use "Add row as keyword" When right clicking on the "Keyword" option in the emr item entry dlg.  Should only be for table text boxes and table drop downs.
				if (nColumnType == LIST_TYPE_TEXT || nColumnType == LIST_TYPE_DROPDOWN)
				{
					CString strFieldName;
					BOOL bTableRowsAsFields = IsDlgButtonChecked(IDC_TABLE_ROWS_AS_FIELDS) ? TRUE : FALSE;
					if (bTableRowsAsFields)
					{					
						strFieldName = "Row";
					}
					else {
						strFieldName = "Column";
					}

					//rows are on the bottom
					mnu.AppendMenu(MF_ENABLED | MF_STRING | MF_BYPOSITION | ((peide->m_bUseNameForKeyword) ? MF_CHECKED : MF_UNCHECKED), clmiIncludeNameForKeyword, "Include " + strFieldName + " Name As Keyword");

				}
				

				// Pop up the menu and gather the immediate response
				CPoint pt = CalcContextMenuPos(pWnd, point);
				long nMenuResult = mnu.TrackPopupMenu(TPM_LEFTALIGN|TPM_RETURNCMD|TPM_TOPALIGN|TPM_LEFTBUTTON|TPM_RIGHTBUTTON, pt.x, pt.y, this);
				switch (nMenuResult) {
				case clmiDelete: // delete
					OnDeleteDataItem(TRUE);
					break;
				case clmiActivate: // activate
					m_pdlCurrentDataElementList = m_pdlColumnDataElementList;
					DoActivateColumnDataElement(pCurSel);
					break;
				case clmiInactivate: // inactivate
					m_pdlCurrentDataElementList = m_pdlColumnDataElementList;
					DoInactivateColumnDataElement(pCurSel);
					break;
				case clmiEditDropdownList: // edit dropdown data
					OnBtnEditTableDropdownData();
					break;
				case clmiEditFormula:
					m_pdlCurrentDataElementList = m_pdlColumnDataElementList;
					OpenCalculatedFieldEditor(peide);
					break;
				case clmiEditInputMask:
					// (z.manning 2009-01-13 14:59) - PLID 32719 - Open the input mask editor dialog
					m_pdlCurrentDataElementList = m_pdlColumnDataElementList;
					OpenInputMaskEditor(peide);
					break;
				// (j.jones 2009-08-13 09:32) - PLID 31730 - allow a right-click menu to insert above,
				// or insert below the active row
				case clmiAddNewBefore:
					//add before
					if(!IsDlgButtonChecked(IDC_AUTO_ALPHABETIZE_LIST_DATA)) {
						OnAddDataItem(TRUE, nSortOrder);
					}
					break;
				case clmiAddNewMultiBefore:
					//add multiple before
					if(!IsDlgButtonChecked(IDC_AUTO_ALPHABETIZE_LIST_DATA)) {
						OnAddMultipleDataItem(TRUE, nSortOrder);
					}
					break;
				case clmiAddNewAfter:
					//add after
					if(!IsDlgButtonChecked(IDC_AUTO_ALPHABETIZE_LIST_DATA)) {
						OnAddDataItem(TRUE, nSortOrder+1);
					}
					break;
				case clmiAddNewMultiAfter:
					
					if(!IsDlgButtonChecked(IDC_AUTO_ALPHABETIZE_LIST_DATA)) {//add multiple after
						OnAddMultipleDataItem(TRUE, nSortOrder+1);
					}
					break;
				case clmiEditSentenceFormat:
					// (z.manning 2010-07-29 09:43) - PLID 36150
					EditDataElementSentenceFormat(peide, TRUE);
					break;
				case clmiEditAutoNumber:
					// (z.manning 2010-08-11 12:06) - PLID 40074
					EditAutoNumberSettings(peide);
					break;
				case clmiEditAutofillSettings: // (z.manning 2011-03-18 16:51) - PLID 23662
					EditTableAutofillSettings();
					break;				
				case clmiOverrideKeyword: // (j.gruber 2014-07-21 14:54) - PLID 62626 - When editing tables, add the same keywords override option as in breakdown 3.3 for the bottom section data element when the type is a checkbox.
					OnKeywordOverride(pCurSel, TRUE);
					break;
					// (j.gruber 2014-07-25 13:41) - PLID 62629 - When editing multi-select lists, single-select lists, tables, and table dropdowns , add a right click and Check All and Uncheck All for the Keyword column to quickly check or uncheck all options.
				case clmiCheckAllKeywords:				
					Check_UncheckAllKeywords(TRUE, TRUE);
					break;
					// (j.gruber 2014-07-25 13:41) - PLID 62629 - When editing multi-select lists, single-select lists, tables, and table dropdowns , add a right click and Check All and Uncheck All for the Keyword column to quickly check or uncheck all options.
				case clmiUncheckAllKeywords:
					Check_UncheckAllKeywords(FALSE, TRUE);
					break;
				// (j.gruber 2014-12-05 15:59) - PLID 64266 - Add drop down menu for "Add column as keyword"  if reveresed use "Add row as keyword" When right clicking on the "Keyword" option in the emr item entry dlg.  Should only be for table text boxes and table drop downs.
				case clmiIncludeNameForKeyword:
					peide->m_bUseNameForKeyword = !peide->m_bUseNameForKeyword;
				break;
				case 0:
					// The user canceled, do nothing
					break;
					
				default:
					// Unexpected response!
					ASSERT(FALSE);
					ThrowNxException("Unexpected return value %li from context menu!", nMenuResult);
				}
			}
		}
		//TES 3/9/2012 - PLID 48779 - The 3D control doesn't fire HotspotRightClicked events any more.  Instead, we check here whether
		// or not they right-clicked on a hotspot.
		else if (pWnd->GetSafeHwnd() && pWnd->GetSafeHwnd() == GetDlgItem(IDC_EMR_ITEM_ENTRY_3DIMAGE)->GetSafeHwnd())
		{
			if(m_p3DImage == NULL) {
				return;
			}
			GetDlgItem(IDC_EMR_ITEM_ENTRY_3DIMAGE)->ScreenToClient(&point);
			short nHotspotID = -1;
			//TES 3/9/2012 - PLID 48779 - Added this method to calculate the hotspot ID at a given (client) point.
			m_p3DImage->GetHotSpotFromPoint(point.x, point.y, &nHotspotID);
			if(nHotspotID == -1) {
				return;
			}

			//TES 3/9/2012 - PLID 48779 - The rest of this code was moved here from the old event handler.
			CEMRHotSpot *pHotSpot = GetHotSpotFrom3DHotSpotID(nHotspotID);
			if(pHotSpot == NULL) {
				return;
			}

			CMenu mnu;
			mnu.CreatePopupMenu();
			enum MenuItems {
				miEditAnatomicLocation = 1,
				miEditActions,
			};

			mnu.AppendMenu(MF_ENABLED, miEditAnatomicLocation, "Edit Anatomic &Location");
			mnu.AppendMenu(MF_ENABLED, miEditActions, "Edit &Actions");

			CPoint pt;
			GetCursorPos(&pt);
			int nMenuResult = mnu.TrackPopupMenu(TPM_LEFTALIGN|TPM_RETURNCMD|TPM_TOPALIGN|TPM_LEFTBUTTON|TPM_RIGHTBUTTON, pt.x, pt.y, this);

			switch(nMenuResult)
			{
				case miEditAnatomicLocation:
					OpenAnatomicLocationEditorForHotSpot(pHotSpot);
					break;

				case miEditActions:
					// (a.walling 2012-04-02 08:32) - PLID 46648 - Dialogs must set a parent!
					OpenHotSpotActionEditor(this, pHotSpot, m_nID, m_strName, m_pCurrentEMN, &m_aryChangedHotSpots);
					break;
			}
		}
	} NxCatchAll("CEmrItemEntryDlg::OnContextMenu");
}

//TES 3/14/2011 - PLID 42784 - Converted to datalist2
void CEmrItemEntryDlg::SwapDataElements(NXDATALIST2Lib::IRowSettingsPtr pRow1, NXDATALIST2Lib::IRowSettingsPtr pRow2)
{
	if(m_pdlCurrentDataElementList == m_pdlColumnDataElementList) {
		long nSortOrder1 = pRow1->GetValue(cdelcSortOrder);
		long nSortOrder2 = pRow2->GetValue(cdelcSortOrder);
		long nArrayIndex1 = GetCurDataElementArrayIndex(nSortOrder1, TRUE);
		long nArrayIndex2 = GetCurDataElementArrayIndex(nSortOrder2, TRUE);
		// Swap the sort orders in the array, and in the datalist
		{
			// Swap the sort orders in the array
			{
				// Get the pointers
				CEmrInfoDataElement *pEntry1 = m_aryCurColumnDataElements.GetAt(nArrayIndex1);
				CEmrInfoDataElement *pEntry2 = m_aryCurColumnDataElements.GetAt(nArrayIndex2);
				// Swap the sort order values themselves
				pEntry1->m_nSortOrder = nSortOrder2;
				pEntry2->m_nSortOrder = nSortOrder1;
				// Swap the order of the elements in the array
				m_aryCurColumnDataElements.SetAt(nArrayIndex1, pEntry2);
				m_aryCurColumnDataElements.SetAt(nArrayIndex2, pEntry1);
			}
			// Swap the sort orders in the on-screen datalist
			{
				// Swap the sort order values themselves
				pRow1->PutValue(cdelcSortOrder, nSortOrder2);
				pRow2->PutValue(cdelcSortOrder, nSortOrder1);
				// And re-sort
				m_pdlCurrentDataElementList->Sort();
			}

			// Now that we've changed the order of things, refresh the buttons
			ReflectDataElementSelection();
		}
	}
	else {
		long nSortOrder1 = pRow1->GetValue(delcSortOrder);
		long nSortOrder2 = pRow2->GetValue(delcSortOrder);
		long nArrayIndex1 = GetCurDataElementArrayIndex(nSortOrder1, FALSE);
		long nArrayIndex2 = GetCurDataElementArrayIndex(nSortOrder2, FALSE);
		// Swap the sort orders in the array, and in the datalist
		{
			// Swap the sort orders in the array
			{
				// Get the pointers
				CEmrInfoDataElement *pEntry1 = m_aryCurDataElements.GetAt(nArrayIndex1);
				CEmrInfoDataElement *pEntry2 = m_aryCurDataElements.GetAt(nArrayIndex2);
				// Swap the sort order values themselves
				pEntry1->m_nSortOrder = nSortOrder2;
				pEntry2->m_nSortOrder = nSortOrder1;
				// Swap the order of the elements in the array
				m_aryCurDataElements.SetAt(nArrayIndex1, pEntry2);
				m_aryCurDataElements.SetAt(nArrayIndex2, pEntry1);
			}
			// Swap the sort orders in the on-screen datalist
			{
				// Swap the sort order values themselves
				pRow1->PutValue(delcSortOrder, nSortOrder2);
				pRow2->PutValue(delcSortOrder, nSortOrder1);
				// And re-sort
				m_pdlCurrentDataElementList->Sort();
			}

			// Now that we've changed the order of things, refresh the buttons
			ReflectDataElementSelection();
		}
	}

	// (z.manning, 05/30/2008) - PLID 16443 - This may have caused the visible order of the items to 
	// change so we need to update references to rows & columns in any calculated field formulas.
	UpdateFormulaReferences();
}

void CEmrItemEntryDlg::OnDataUp() 
{
	try {
		// Get the current selection
		//TES 3/14/2011 - PLID 42784 - Converted to datalist2
		NXDATALIST2Lib::IRowSettingsPtr pCurSel = m_pdlDataElementList->CurSel;
		// Make sure there IS a selection
		if (pCurSel == NULL ) {
			return;
		}

		// If we're at the first row we can't shift HIGHER, so we have to be BEYOND the first row
		if (pCurSel != m_pdlDataElementList->GetFirstRow()) {
			m_pdlCurrentDataElementList = m_pdlDataElementList;
			SwapDataElements(pCurSel->GetPreviousRow(), pCurSel);
		}
	} NxCatchAll("CEmrItemEntryDlg::OnDataUp");
}

void CEmrItemEntryDlg::OnDataDown() 
{
	try {
		// Get the current selection
		//TES 3/14/2011 - PLID 42784 - Converted to datalist2
		NXDATALIST2Lib::IRowSettingsPtr pCurSel = m_pdlDataElementList->CurSel;
		// Make sure there IS a selection
		if (pCurSel == NULL) {
			return;
		}

		// If we're at the last row we can't shift LOWER, so we have to be BEFORE the last row
		if (pCurSel != m_pdlDataElementList->GetLastRow()) {
			m_pdlCurrentDataElementList = m_pdlDataElementList;
			SwapDataElements(pCurSel, pCurSel->GetNextRow());
		}
	} NxCatchAll("CEmrItemEntryDlg::OnDataDown");
}

void CEmrItemEntryDlg::OnColumnDataUp() 
{
	try {
		// Get the current selection
		//TES 3/14/2011 - PLID 42784 - Converted to datalist2
		NXDATALIST2Lib::IRowSettingsPtr pCurSel = m_pdlColumnDataElementList->GetCurSel();
		// Make sure there IS a selection
		if (pCurSel == NULL) {
			return;
		}

		// (c.haag 2007-01-29 16:33) - PLID 24423 - We forbid sorting of the Rx column
		// in the system Current Medications item
		if (pCurSel == m_pdlColumnDataElementList->GetFirstRow()->GetNextRow() && IsSystemCurrentMedicationsItem()) {
			MsgBox("You may not change the position of the Rx column of the system Current Medications item");			
			return;
		}

		// (c.haag 2007-04-05 11:54) - PLID 25468 - We forbid sorting of the Yes column
		// in the system Allergies item
		if (pCurSel == m_pdlColumnDataElementList->GetFirstRow()->GetNextRow() && IsSystemAllergiesItem()) {
			MsgBox("You may not change the position of the Yes column of the system Allergies item");
			return;
		}

		// If we're at the first row we can't shift HIGHER, so we have to be BEYOND the first row
		if (pCurSel != m_pdlColumnDataElementList->GetFirstRow()) {
			m_pdlCurrentDataElementList = m_pdlColumnDataElementList;
			SwapDataElements(pCurSel->GetPreviousRow(), pCurSel);
		}
	} NxCatchAll("CEmrItemEntryDlg::OnDataUp");
}

void CEmrItemEntryDlg::OnColumnDataDown() 
{
	try {
		// Get the current selection
		//TES 3/14/2011 - PLID 42784 - Converted to datalist2
		NXDATALIST2Lib::IRowSettingsPtr pCurSel = m_pdlColumnDataElementList->GetCurSel();
		// Make sure there IS a selection
		if (pCurSel == NULL) {
			return;
		}

		// (c.haag 2007-01-29 16:33) - PLID 24423 - We forbid sorting of the Rx column
		// in the system Current Medications item
		if (pCurSel == m_pdlColumnDataElementList->GetFirstRow() && IsSystemCurrentMedicationsItem()) {
			MsgBox("You may not change the position of the Rx column of the system Current Medications item");			
			return;
		}

		// (c.haag 2007-04-05 11:55) - PLID 25468 - We forbid sorting of the Yes column
		// in the system Allergies item
		if (pCurSel == m_pdlColumnDataElementList->GetFirstRow() && IsSystemAllergiesItem()) {
			MsgBox("You may not change the position of the Yes column of the system Allergies item");			
			return;
		}

		// If we're at the last row we can't shift LOWER, so we have to be BEFORE the last row
		if (pCurSel != m_pdlColumnDataElementList->GetLastRow()) {
			m_pdlCurrentDataElementList = m_pdlColumnDataElementList;
			SwapDataElements(pCurSel, pCurSel->GetNextRow());
		}
	} NxCatchAll("CEmrItemEntryDlg::OnDataDown");
}

void CEmrItemEntryDlg::OnBtnDeleteDataItem() 
{
	if(!IsDlgButtonChecked(IDC_RADIO_TABLE)) {
		//normal list, so don't bother with a menu
		OnDeleteDataItem(FALSE);
		return;
	}

	CMenu mnu;
	mnu.m_hMenu = CreatePopupMenu();
	long nIndex = 0;
	// (c.haag 2008-10-23 12:01) - PLID 31708 - Change verbage for flipped tables
	if (IsDlgButtonChecked(IDC_TABLE_ROWS_AS_FIELDS)) {
		//TES 3/14/2011 - PLID 42784 - Converted to datalist2
		mnu.InsertMenu(nIndex++, MF_BYPOSITION|(m_pdlDataElementList->CurSel == NULL ? MF_DISABLED|MF_GRAYED : 0), 1, "Delete Column");
		mnu.InsertMenu(nIndex++, MF_BYPOSITION|(m_pdlColumnDataElementList->CurSel == NULL ? MF_DISABLED|MF_GRAYED : 0), 2, "Delete Row");
	} else {
		//TES 3/14/2011 - PLID 42784 - Converted to datalist2
		mnu.InsertMenu(nIndex++, MF_BYPOSITION|(m_pdlDataElementList->CurSel == NULL ? MF_DISABLED|MF_GRAYED : 0), 1, "Delete Row");
		mnu.InsertMenu(nIndex++, MF_BYPOSITION|(m_pdlColumnDataElementList->CurSel == NULL ? MF_DISABLED|MF_GRAYED : 0), 2, "Delete Column");
	}

	CRect rc;
	CWnd *pWnd = GetDlgItem(IDC_DELETE_DATA_ITEM);
	if (pWnd) {
		pWnd->GetWindowRect(&rc);
		switch(mnu.TrackPopupMenu(TPM_LEFTALIGN|TPM_RETURNCMD, rc.right, rc.top, this, NULL)) {
			case 1:
				OnDeleteDataItem(FALSE);
				break;
			case 2:
				OnDeleteDataItem(TRUE);
				break;			
		}
	}
}

void CEmrItemEntryDlg::CheckDataItemUse(long nDataElementID, BOOL bIsColumn, OUT BOOL &bInUseByCurrent, OUT BOOL &bInUseByTopic)
{
	long nEMNCount = 0, nEMNMintCount = 0;
	CString strDetailsUsed, strDetailsFilled;
	//TES 4/30/2008 - PLID 29748 - Pass in some placeholder variables to our main overload.
	CheckDataItemUse(nDataElementID, bIsColumn, bInUseByCurrent, bInUseByTopic, nEMNCount, nEMNMintCount, strDetailsUsed, strDetailsFilled);
}

void CEmrItemEntryDlg::CheckDataItemUse(long nDataElementID, BOOL bIsColumn, OUT BOOL &bInUseByCurrent, OUT BOOL &bInUseByTopic, 
										OUT long &nEMNCount, OUT long &nEMNMintCount, OUT CString &strDetailsUsed, OUT CString &strDetailsFilled)
{
	//TES 4/30/2008 - PLID 29748 - This is all copied from the OnDeleteDataItem() handler, this functionality needed
	// to also be available for when they mark an item as a label.
	//TES 3/14/2011 - PLID 42784 - Converted to datalist2
	NXDATALIST2Lib::IRowSettingsPtr pRow = NULL;
	if(bIsColumn)
		pRow = m_pdlColumnDataElementList->FindByColumn(cdelcID, nDataElementID, 0, VARIANT_FALSE);
	else
		pRow = m_pdlDataElementList->FindByColumn(delcID, nDataElementID, 0, VARIANT_FALSE);

	// (z.manning 2009-04-08 17:26) - PLID 33926 - We used to only do this for columns but that's no
	// longer true as we now check rows too.
	if (m_bMaintainCurrentTable) {
		//
		// (c.haag 2006-03-06 16:54) - PLID 19730 - Check the open EMN to see if the item
		// is used
		//

		if (m_bIsCurrentDetailTemplate) nEMNMintCount++;
		else nEMNCount++;

		// m_astrCurrentTableState is an array of strings that represent the state of each
		// detail that has our EmrInfoID. Each string is in the form "data_row,data_column,data_value,...".
		// If there is no data for a column element, data_value is empty. Lets scan all the strings for
		// any data where data_column = nDataElementID.
		//
		int nDetails = m_apCurrentTableDetails.GetSize();
		for (int iDetail=0; iDetail < nDetails; iDetail++) {
			CString str = VarString(m_apCurrentTableDetails[iDetail]->GetState(), "");
			CString strDetailID;
			CEMNDetail *pDetail = m_apCurrentTableDetails[iDetail];
			strDetailID.Format("%d,", (m_bIsCurrentDetailTemplate) ? pDetail->m_nEMRTemplateDetailID : pDetail->m_nEMRDetailID);
			BOOL bColumnInUse = FALSE;

			// (c.haag 2007-08-25 11:39) - PLID 27112 - Use the table state iterator class
			CEmrTableStateIterator etsi(str);
			long X,Y,nEmrDetailImageStampID,nEmrDetailImageStampPointer,nStampID;
			CString strData;
			// (z.manning 2010-02-18 09:23) - PLID 37427 - Added nEmrDetailImageStampID
			// (z.manning 2011-03-02 15:05) - PLID 42335 - Added nStampID
			while(etsi.ReadNextElement(X,Y,strData,nEmrDetailImageStampID,nEmrDetailImageStampPointer,nStampID) && !bColumnInUse)
			{
				// (z.manning 2009-04-08 17:50) - PLID 33926 - We now handle rows here in addition to columns.
				BOOL bInDataItem = (bIsColumn && Y == nDataElementID) || (!bIsColumn && X == nDataElementID);
				TableColumn *ptc = pDetail->GetColumnByID(Y);
				if(ptc != NULL && ptc->nType == LIST_TYPE_TEXT) {
					// If this was a textbox, only check for an empty string
					if(!strData.IsEmpty() && bInDataItem) {
						bInUseByCurrent = TRUE;
					}
				} 
				else {
					if(!strData.IsEmpty() &&
						strData != "-1" && // Usually means user explicitly selected nothing
						strData != "0" && // Usually means user never selected anything
						bInDataItem) {
						bInUseByCurrent = TRUE;
					}
				}
			}
			if (bInUseByCurrent) {
				strDetailsFilled += strDetailID;
			}
			strDetailsUsed += strDetailID;
		}
		strDetailsFilled.TrimRight(",");
		strDetailsUsed.TrimRight(",");
	}
	if (strDetailsFilled.IsEmpty()) strDetailsFilled = "-1";
	if (strDetailsUsed.IsEmpty()) strDetailsUsed = "-1";
	// Make sure we're allowed to delete
	if (nDataElementID != -1) {
		
		if(!bInUseByCurrent && m_bMaintainCurrentList) {
			//TES 2/13/2006 - If we have a current list, it may be in use on screen but not in the data.
			ASSERT(!bIsColumn);
			CString strData = VarString(pRow->GetValue(delcData));
			int nCurListItem = FindInCurrentList(strData);
			if(nCurListItem > -1 && m_aryCurrentList.GetAt(nCurListItem).bSelected) {
				bInUseByCurrent = true;
			}
			// (a.walling 2008-02-07 11:08) - PLID 14982 - Flag if this item is selected on the topic (not necessarily on the popped-up item being edited)
			if(nCurListItem > -1 && m_aryCurrentList.GetAt(nCurListItem).bSelectedOnTopic) {
				bInUseByTopic = true;
			}
		}

		
	}
}

void CEmrItemEntryDlg::OnDeleteDataItem(BOOL bColumnList) 
{
	try {
		//TES 3/14/2011 - PLID 42784 - Convertd to datalist2
		NXDATALIST2Lib::IRowSettingsPtr pCurSel = NULL;
		
		if(bColumnList)
			pCurSel = m_pdlColumnDataElementList->CurSel;
		else
			pCurSel = m_pdlDataElementList->CurSel;

		if (pCurSel != NULL) {
			// (a.walling 2007-04-04 15:19) - PLID 25459 - Check for Medication permission
			// (will prompt for passwords)
			if (IsSystemCurrentMedicationsItem() && !bColumnList) {
				if(!CheckCurrentUserPermissions(bioPatientMedication, sptDynamic0)) {
					return;
				}
			}
			// (z.manning, 08/07/2007) - PLID 25741 - If it's the built-in allergies item, make sure the user has the permission to edit it.
			if(IsSystemAllergiesItem() && !bColumnList) {
				if(!CheckCurrentUserPermissions(bioPatientAllergies, sptDynamic0)) {
					return;
				}
			}

			// Get the index in the current array
			long nIndex = -1;
			long nSortOrder = -1;
			if(bColumnList)
				nSortOrder = VarLong(pCurSel->GetValue(cdelcSortOrder));
			else
				nSortOrder = VarLong(pCurSel->GetValue(delcSortOrder));

			// (c.haag 2007-01-29 15:50) - PLID 24423 - If this is from the column list, and the
			// element is first in the sort order, then this data item is by definition the Rx
			// column and cannot be deleted
			if (IsSystemCurrentMedicationsItem() && bColumnList && 1 == nSortOrder) {
				MsgBox("You may not delete the Rx column of the system Current Medications item");
				return;
			}

			// (c.haag 2007-04-05 11:56) - PLID 25468 - If this is from the column list, and the
			// element is first in the sort order, then this data item is by definition the Yes
			// column and cannot be deleted
			if (IsSystemAllergiesItem() && bColumnList && 1 == nSortOrder) {
				MsgBox("You may not delete the Yes column of the system Allergies item");
				return;
			}

			// (z.manning 2010-02-12 14:02) - PLID 37320 - Do not allow deletion of built-in smart stamp table columns
			if(bColumnList && IsSmartStampListSubType(VarByte(pCurSel->GetValue(cdelcSubType)))) {
				MessageBox("You may not delete this because it is needed by Smart Stamps.");
				return;
			}

			// (j.jones 2011-05-03 16:08) - PLID 43527 - disallow in current medication built-in columns
			if(bColumnList && IsCurrentMedicationListSubType(VarByte(pCurSel->GetValue(cdelcSubType)))) {
				MessageBox("You may not delete this because it is needed by Current Medications.");
				return;
			}

			nIndex = GetCurDataElementArrayIndex(nSortOrder, bColumnList);

			// (z.manning, 05/30/2008) - PLID 16443 - Do not let them delete a column that is referenced
			// in a formula.
			CString strReferencingItem;
			if(IsDataElementReferencedInAnyFormula(bColumnList ? m_aryCurColumnDataElements.GetAt(nIndex) : m_aryCurDataElements.GetAt(nIndex), m_aryCurDataElements, m_aryCurColumnDataElements, strReferencingItem)) {
				// (c.haag 2008-10-27 09:13) - PLID 31708 - Reverse the display text if the table is flipped
				BOOL bDisplayText = bColumnList;
				if (IsDlgButtonChecked(IDC_TABLE_ROWS_AS_FIELDS)) { 
					bDisplayText = (bDisplayText) ? FALSE : TRUE;
				}
				CString strDataType = bDisplayText ? "column" : "row";
				MessageBox(FormatString("This %s is referenced in the formula for %s '%s.'\r\n\r\n"
					"You may not delete a %s that is referenced in a formula."
					, strDataType, strDataType, strReferencingItem, strDataType));
				return;
			}

			// (j.gruber 2013-09-27 12:28) - PLID 58676 - check if it has codes associated with it
			if (bColumnList)
			{
				CString strColName = m_aryCurColumnDataElements.GetAt(nIndex)->m_strData;
				if (m_TableCellCodes.DoesColumnHaveCodes(strColName)) {
					if (IDNO == MsgBox(MB_YESNO, "This column has codes associated with it.  If you remove this column, the associated codes will be removed from this and all previous versions of this column.  Are you sure you wish to continue?"))
					{
						return;
					}
					else {
						//remove the column
						m_TableCellCodes.RemoveColumn(strColName);
					}
				}

				// (j.gruber 2013-10-21 09:11) - PLID 59101 - check for columns also
				if (m_aryCurColumnDataElements.GetAt(nIndex)->m_aryCodes.GetSize() > 0) {
					
					if (IDNO == MsgBox(MB_YESNO, "This detail has codes associated with it.  If you remove this detail, the associated codes will be removed from this and all previous versions of this detail.  Are you sure you wish to continue?"))
					{
						return;
					}
					else {
						m_aryCurColumnDataElements.GetAt(nIndex)->m_aryCodes.RemoveAll();
					}
				}
			}
			else {
				CString strRowName = m_aryCurDataElements.GetAt(nIndex)->m_strData;
				if (m_TableCellCodes.DoesRowHaveCodes(strRowName))
				{
					if (IDNO == MsgBox(MB_YESNO, "This row has codes associated with it.  If you remove this row, the associated codes will be removed from this and all previous versions of the row.  Are you sure you wish to continue?"))
					{
						return;
					}
					else {
						m_TableCellCodes.RemoveRow(strRowName);
					}
				}

				// (j.gruber 2013-10-02 12:43) - PLID 58674 - also check for multi and single selects
				if (m_aryCurDataElements.GetAt(nIndex)->m_aryCodes.GetSize() > 0) {
					
					if (IDNO == MsgBox(MB_YESNO, "This detail has codes associated with it.  If you remove this detail, the associated codes will be removed from this and all previous versions of this detail.  Are you sure you wish to continue?"))
					{
						return;
					}
					else {
						m_aryCurDataElements.GetAt(nIndex)->m_aryCodes.RemoveAll();
					}
				}

				

			}


			// (a.wilson 6/29/2012) PLID 51306 - find out if the current row or column is contained within the graphing setup. if so warn them.
			CString strGraphData = IsDataIDAssignedInGraphing(VarLong(pCurSel->GetValue(cdelcID)));
			if (!strGraphData.IsEmpty()) {
				BOOL bDisplayText = bColumnList;
				if (IsDlgButtonChecked(IDC_TABLE_ROWS_AS_FIELDS)) { 
					bDisplayText = (bDisplayText) ? FALSE : TRUE;
				}
				CString strDataType = bDisplayText ? "column" : "row";

				MsgBox("The following %s is assigned in graphing.\r\n\r\nAreas Assigned:\r\n%s\r\nYou may not delete a %s that is assigned in graphing.", 
					strDataType, strGraphData, strDataType);
				return;
			}

			// (j.jones 2012-09-21 13:18) - PLID 52316 - if a label, see if any row is using this label as a parent
			if(!bColumnList && m_aryCurDataElements.GetAt(nIndex)->m_bIsLabel && (IsDlgButtonChecked(IDC_RADIO_LIST_SELECT) || IsDlgButtonChecked(IDC_RADIO_LIST_MULTISELECT))) {
				BOOL bInUse = FALSE;
				for(int i=0;i<m_aryCurDataElements.GetSize() && !bInUse; i++) {
					CEmrInfoDataElement *peideCheck = m_aryCurDataElements.GetAt(i);
					if(peideCheck != NULL && peideCheck->m_peideParentLabelPtr == m_aryCurDataElements.GetAt(nIndex)) {
						//flag that it is in use
						bInUse = TRUE;
					}
				}

				if(bInUse && IDYES != MessageBox("Deleting this label will clear the parent selection from all list items referencing this label.\n\n"
					"Are you sure you want to delete it?", "Practice", MB_ICONEXCLAMATION|MB_YESNO)) {
					return;
				}
			}

			// (c.haag 2011-03-16) - PLID 42814 - Moved outside of validation block
			// We use this id in a few places
			long nDataElementID = -1; 
			if(bColumnList)
				nDataElementID = VarLong(pCurSel->GetValue(cdelcID));
			else
				nDataElementID = VarLong(pCurSel->GetValue(delcID));

			// Remove the entry at that index (i.e. move it to the "deleted" array)
			{
				// Validate the deletion
				{
					BOOL bInUseByCurrent = FALSE;
					BOOL bInUseByTopic = FALSE; // (a.walling 2008-02-07 11:07) - PLID 14982 - if the data item is selected on the
								// detail on the topic (only applicable for editing popped up details)	
					long nEMNCount = 0, nEMNMintCount = 0;
					CString strDetailsUsed;
					CString strDetailsFilled;
					
					if(IsDataIDUsedBySpawnedObject(AsString(nDataElementID))) {
						MessageBox("This item is referenced by spawned objects on patient EMNs.  It cannot be deleted.");
						return;
					}

					// (b.cardillo 2009-07-22 12:07) - PLID 34844 - As a convenience we detect here whether the data element is in 
					// use by any wellness template criteria.
					if (nDataElementID != -1) {
						CDWordArray arydwDataIDs;
						arydwDataIDs.Add(nDataElementID);
						_RecordsetPtr prs = GetWellnessTemplatesThatReferenceEMRInfoDataElements(GetRemoteData(), m_nEmrInfoMasterID, arydwDataIDs);
						CString strReferences = GenerateDelimitedListFromRecordsetColumn(prs, "Name", " - ", "\r\n");
						if (!strReferences.IsEmpty()) {
							// There are some, so warn the user and fail
							CString strMsg;
							strMsg.Format(
								"You may not delete this list element because it is referenced in the criteria of the following Wellness Template(s): \r\n"
								"\r\n%s\r\n\r\n"
								"Please remove this list element from all Wellness Criteria before attempting to delete it."
								,
								strReferences);
							MessageBox(strMsg, NULL, MB_ICONEXCLAMATION|MB_OK);
							return;
						}
					}

					//TES 4/30/2008 - PLID 29748 - This function has the code that used to be here, split out so that
					// we can also call it when they change an item to a label.
					CheckDataItemUse(nDataElementID, bColumnList, bInUseByCurrent, bInUseByTopic, nEMNCount, nEMNMintCount, strDetailsUsed, strDetailsFilled);

					// (a.walling 2008-02-07 11:12) - PLID 14982 - Now give a more informative message
					// (z.manning 2009-04-08 17:50) - PLID 33926 - We also need to handle this logic for tables.
					if (m_bMaintainCurrentList || m_bMaintainCurrentTable) {
						CString strItemSpecific;
						if(m_bMaintainCurrentTable) {
							strItemSpecific = FormatString("This %s has data", bColumnList ? "column" : "row");
						}
						else {
							strItemSpecific = "This data item has been selected";
						}

						if (bInUseByCurrent) {
							if (bInUseByTopic) {
								MessageBox(strItemSpecific + " on the currently edited item. Additionally, it has been selected on the topic, and its actions will not be revoked when it is deleted. Please change your selection on the current item before attempting to delete.", NULL, MB_ICONEXCLAMATION|MB_OK);
							} 
							else {
								MessageBox(strItemSpecific + " on the currently edited item. Please change your selection on the current item before attempting to delete.", NULL, MB_ICONEXCLAMATION|MB_OK);
							}
							return;
						}

						if (bInUseByTopic) {
							if (IDNO == MessageBox(strItemSpecific + " on the topic. Deleting this item will not revoke any actions associated with it. Do you want to continue?", NULL, MB_ICONEXCLAMATION|MB_YESNO)) {
								return;
							}
						}
					}


					// We're allowed to delete, so confirm it with the user
					{
						long nOrderSetTmplCount =0;
						long nOMRFormsCount = 0;
						// See how many places it's used
						if (nDataElementID != -1) {
							// See how much it's in use
							_RecordsetPtr prs = CreateRecordset("SELECT "
								"(SELECT COUNT(DISTINCT EMRID) FROM EMRDetailsT "
								" WHERE Deleted = 0 AND EmrInfoID = (SELECT EmrInfoID FROM EmrDataT WHERE ID = %li %s)) AS EMNCount, "
								"(SELECT COUNT(DISTINCT TemplateID) FROM EMRTemplateDetailsT INNER JOIN EmrInfoMasterT ON EmrTemplateDetailsT.EmrInfoMasterID = EmrInfoMasterT.ID "
								" WHERE EmrInfoMasterT.ActiveEmrInfoID = (SELECT EmrInfoID FROM EmrDataT WHERE ID = %li %s)) AS EMNMintCount, "
								//(e.lally 2009-05-11) PLID 28553 - Get the Order Set Template count for the warning
								"(SELECT COUNT(DISTINCT OrderSetTemplateID) "
								" FROM OrderSetTemplateMedicationsT "
								" WHERE MedicationID IN(SELECT ID FROM DrugList WHERE EmrDataID = %li)) as OrderSetTmplCount, "
								// (j.gruber 2012-08-31 13:51) - PLID 52285 - OMR Mappings
								" (SELECT Count(DISTINCT OMRFormID) FROM OMRFormDetailT "
								" WHERE EMRDataGroupID = (SELECT EMRDataGroupID FROM EMRDataT WHERE ID = %li)) as CountOMRForms ",
								nDataElementID, (m_bIsCurrentDetailTemplate) ? "" : (CString("AND EmrDetailsT.ID NOT IN (") + strDetailsUsed + ")"),
								nDataElementID, (m_bIsCurrentDetailTemplate) ? (CString("AND EmrTemplateDetailsT.ID NOT IN (") + strDetailsUsed + ")") : "",
								nDataElementID, nDataElementID);
							if (!prs->eof) {
								FieldsPtr pflds = prs->GetFields();
								nEMNCount += AdoFldLong(pflds, "EMNCount");
								nEMNMintCount += AdoFldLong(pflds, "EMNMintCount");
								nOrderSetTmplCount = AdoFldLong(pflds, "OrderSetTmplCount");
								nOMRFormsCount = AdoFldLong(pflds, "CountOMRForms");
							} else {
								// This should be impossible
								ASSERT(FALSE);
								//nEMNCount = nEMNMintCount = -1;
							}
						} else {
							// It's not even saved to data, so it can't possibly be in use
							//nEMNCount = nEMNMintCount = 0;
						}
						// Give the appropriate warning
						CString strPrelimWarning;
						if (nEMNCount == 0 && nEMNMintCount != 0) {
							//(e.lally 2009-05-11) PLID 28553 - Add the Order Set Template count to the warning
							// (j.gruber 2012-08-31 14:02) - PLID 52285 - add OMR Forms
							strPrelimWarning.Format(
								"This data element is available for selection on 0 EMNs and %s EMN Templates. %s%s%s"
								"%sDeleting this element will remove it from all EMN Templates%s. This CANNOT be undone.\n\n",
								nEMNMintCount == -1 ? "an unknown number" : AsString(nEMNMintCount), 
								nOrderSetTmplCount > 0 || nOMRFormsCount > 0 ? "It is also associated with:\r\n" : "",
								nOrderSetTmplCount > 0 ? FormatString("\r\n%li Order Set Template(s)", nOrderSetTmplCount) : "",
								nOMRFormsCount > 0 ? FormatString("\r\n%li OMR Form(s)", nOMRFormsCount) : "",
								nOrderSetTmplCount > 0 || nOMRFormsCount > 0 ? "\r\n\r\n" : "",
								nOrderSetTmplCount > 0 ? " and Order Set Templates" : "");
						}
						else if (nEMNCount != 0 || nEMNMintCount != 0){
							//(e.lally 2009-05-11) PLID 28553 - Add the Order Set Template count to the warning
							// (j.gruber 2012-08-31 14:02) - PLID 52285 - add OMR Forms
							strPrelimWarning.Format(
								"This data element is available for selection on %s EMNs and %s EMN Templates. %s%s%s"
								"%sDeleting this element will cause a new copy of the item to be made, which will "
								"not affect any existing EMNs%s, but it will remove it from all EMN Templates%s. %s"
								"This CANNOT be undone.\n\n",
								nEMNCount == -1 ? "an unknown number" : AsString(nEMNCount), 
								nEMNMintCount == -1 ? "an unknown number" : AsString(nEMNMintCount),
								nOrderSetTmplCount > 0 || nOMRFormsCount > 0 ? "It is also associated with:\r\n" : "",
								nOMRFormsCount > 0 ? FormatString("\r\n%li OMR Form(s)", nOMRFormsCount) : "",
								nOrderSetTmplCount > 0 ? FormatString("%li Order Set Template(s). ", nOrderSetTmplCount) : "",
								nOrderSetTmplCount > 0 || nOMRFormsCount > 0 ? "\r\n\r\n" : "",
								GetCalledFromDetailID() == -1 ? "" : " other than the detail you are editing",
								GetCalledFromDetailID() == -1 ? "" : " as well as the detail you are editing",
								nOrderSetTmplCount > 0 ? "It will also be removed from all Order Set Templates. " : "");
						} else {
							// It's not in use so give no preliminary warning
							strPrelimWarning.Empty();
						}
						
						CString strMsg, strName;
						
						if(bColumnList)
							strName = VarString(pCurSel->GetValue(cdelcData));
						else
							strName = VarString(pCurSel->GetValue(delcData));

						// (c.haag 2007-01-30 10:37) - PLID 24423 - If this is a Current Medication, then we need to first
						// make sure it's not in use by any patient or patient EMN. Then we give the user another message.
						// I referred to EditMedicationListDlg for what tables to check.
						//
						if (!bColumnList && IsSystemCurrentMedicationsItem()) 
						{
							// (c.haag 2011-03-18) - PLID 42873 - Don't run queries if it's -1. This can happen for new rows.
							if (-1 != nDataElementID)
							{
								// (a.walling 2010-10-19 09:45) - PLID 40965 - Use ReturnsRecordsParam
								if (ReturnsRecordsParam("SELECT ID FROM PatientMedications WHERE MedicationID IN (SELECT ID FROM DrugList WHERE EMRDataID = {INT}) AND Deleted = 0", nDataElementID)) {
									MsgBox("You may not delete this medication because it is in use by patients.");
									return;
								}
								// (a.walling 2010-10-19 09:45) - PLID 40965 - Use ReturnsRecordsParam
								// (c.haag 2011-03-18) - PLID 42873 - Added missing parenthesis
								if (ReturnsRecordsParam("SELECT MedicationID FROM CurrentPatientMedsT WHERE MedicationID IN (SELECT ID FROM DrugList WHERE EMRDataID = {INT})", nDataElementID)) {
									MsgBox("You may not delete this medication because it is in use by patients.");
									return;
								}
								// (a.walling 2010-10-19 09:45) - PLID 40965 - Use ReturnsRecordsParam
								if (ReturnsRecordsParam("SELECT MedicationID FROM MedSchedDetailsT WHERE MedicationID IN (SELECT ID FROM DrugList WHERE EMRDataID = {INT})", nDataElementID)) {
									MsgBox("You may not delete this medication because it is in use by medication schedules.");
									return;
								}
								// (a.walling 2010-10-19 09:45) - PLID 40965 - Use ReturnsRecordsParam
								if (ReturnsRecordsParam("SELECT DISTINCT EMRTemplateID FROM EMRTemplatePrescriptionsT WHERE MedicationID IN (SELECT ID FROM DrugList WHERE EMRDataID = {INT})", nDataElementID)) {
									MsgBox("You may not delete this medication because it is in use by patient medical records.");
									return;
								}
								// (a.walling 2010-10-19 09:45) - PLID 40965 - Use ReturnsRecordsParam
								if (ReturnsRecordsParam("SELECT ID FROM PatientMedications WHERE MedicationID IN (SELECT ID FROM DrugList WHERE EMRDataID = {INT}) AND ID IN (SELECT MedicationID FROM EMRMedicationsT)", nDataElementID)) {
									MsgBox("You cannot delete this medication because it is currently used by EMN prescriptions (They may be marked as deleted)");
									return;
								}
							}

							strMsg.Format(
								"%s"
								"Are you sure you want to completely delete the '%s' data element? This will also delete the corresponding medication "
								"from NexTech Practice!\n\n"
								"NOTE: If you do not want to completely remove this data element but would like to make it unavailable "
								"for future EMNs and EMN Templates, you may make it inactive.  To do so, click 'No' and then right-click "
								"on the data element and choose the 'Inactivate' option.", 
								strPrelimWarning, strName);


						} 
						// (c.haag 2007-04-03 09:08) - PLID 25468 - Special checking for allergies
						else if (!bColumnList && IsSystemAllergiesItem()) {
							// (a.walling 2010-10-19 09:45) - PLID 40965 - Use ReturnsRecordsParam
							if (ReturnsRecordsParam("SELECT ID FROM PatientAllergyT WHERE AllergyID IN (SELECT ID FROM AllergyT WHERE EmrDataID = {INT}) ", nDataElementID)) {
								MsgBox("You may not delete this allergy because it is in use by patients.");
								return;
							}

							strMsg.Format(
								"%s"
								"Are you sure you want to completely delete the '%s' data element? This will also delete the corresponding allergy "
								"from NexTech Practice!\n\n"
								"NOTE: If you do not want to completely remove this data element but would like to make it unavailable "
								"for future EMNs and EMN Templates, you may make it inactive.  To do so, click 'No' and then right-click "
								"on the data element and choose the 'Inactivate' option.", 
								strPrelimWarning, strName);
						}
						else {
							strMsg.Format(
								"%s"
								"Are you sure you want to completely delete the '%s' data element?\n\n"
								"NOTE: If you do not want to completely remove this data element but would like to make it unavailable "
								"for future EMNs and EMN Templates, you may make it inactive.  To do so, click 'No' and then right-click "
								"on the data element and choose the 'Inactivate' option.", 
								strPrelimWarning, strName);
						}

						if (MessageBox(strMsg, NULL, (strPrelimWarning.IsEmpty() ? MB_ICONQUESTION : MB_ICONWARNING)|MB_YESNO) != IDYES) {
							return;
						}
					}

					// (c.haag 2011-03-16) - PLID 42814 - Warn the user if the EMR Data ID shows up in our current common lists collection
					{
						CStringArray astrInUseCommonLists; // Names of common lists that use this item
						CArray<long,long> anDoomedCommonLists; // Indexes of common lists that use -only- this item

						int i;
						for (i=0; i < m_CommonListCollection.GetListCount(); i++)
						{
							CEmrInfoCommonList list = m_CommonListCollection.GetListByIndex(i);
							if (list.DoesExist(nDataElementID)) {
								// If we get here, this list is using the item. Add it to astrInUseCommonLists
								astrInUseCommonLists.Add(list.GetName());
								// If this item is the only item in the list, then the list needs to be deleted too
								if (1 == list.GetItemCount())
								{
									anDoomedCommonLists.Add(astrInUseCommonLists.GetSize() - 1);
								}
							}
						}

						// Warn the users about common lists using the item
						if (astrInUseCommonLists.GetSize() > 0)
						{
							CString strWarning = "This item is in use by the following common lists:\r\n\r\n";
							for (i=0; i < astrInUseCommonLists.GetSize(); i++)
							{
								if (i >= 20) {
									strWarning += "<more...>\r\n";
									break;
								}
								else {
									strWarning += astrInUseCommonLists[i] + "\r\n";
								}
							}
							strWarning += "\r\nAre you sure you wish to delete it?";
							if (IDNO == MessageBox(strWarning, NULL, MB_YESNO | MB_ICONQUESTION)) {
								return;
							}
						}

						// Warn the users about common lists using only the item
						if (anDoomedCommonLists.GetSize() > 0)
						{
							CString strWarning = "A common list must have at least one item in it. The following lists "
								"are using only this item, and will also be deleted if you continue:\r\n\r\n";
							for (i=0; i < anDoomedCommonLists.GetSize(); i++)
							{
								if (i >= 20) {
									strWarning += "<more...>\r\n";
									break;
								}
								else {
									strWarning += astrInUseCommonLists[ anDoomedCommonLists[i] ] + "\r\n";
								}									
							}
							strWarning += "\r\nAre you sure you wish to continue?";
							if (IDNO == MessageBox(strWarning, NULL, MB_YESNO | MB_ICONQUESTION)) {
								return;
							}
						}

					}
				}
				// Delete the row from the datalist
				if(bColumnList) {
					m_pdlColumnDataElementList->RemoveRow(pCurSel);
					// Move this element from one array to the other
					CEmrInfoDataElement *pMove = m_aryCurColumnDataElements.GetAt(nIndex);
					m_aryCurColumnDataElements.RemoveAt(nIndex, 1);
					m_aryCurDeletedDataElements.Add(pMove);
					// Update the sort orders of all subsequent elements in the cur list
					for (long i=0; i<m_aryCurColumnDataElements.GetSize(); i++) {
						if(m_aryCurColumnDataElements.GetAt(i)->m_nSortOrder > nSortOrder)
							m_aryCurColumnDataElements.GetAt(i)->m_nSortOrder--;
					}
					// Update the sort orders of all subsequent rows in the on-screen datalist
					{
						// (b.cardillo 2006-01-30 17:36) - PLID 19025 - We used to go from the 
						// selected row forward, because we knew for 100% that the row order on 
						// was the same as the user's intended order.  But now that we have the 
						// checkbox that can designate an item as "sorted by name", the order 
						// is an independent property that doesn't imply an actual on-screen 
						// row order.  So now we loop through EVERY row, and only increment the 
						// order number of rows whose existing order number is higher than the 
						// incoming order.
						NXDATALIST2Lib::IRowSettingsPtr pRow = m_pdlColumnDataElementList->GetFirstRow();
						while(pRow) {
							long nPriorSortOrder = VarLong(pRow->GetValue(cdelcSortOrder));
							if (nPriorSortOrder > nSortOrder) {
								pRow->PutValue(cdelcSortOrder, (long)(nPriorSortOrder - 1));
							}
							pRow = pRow->GetNextRow();
						}
					}
					// (c.haag 2007-04-12 12:07) - PLID 16050 - Reset the row selection
					m_pdlColumnDataElementList->CurSel = NULL;

					//TES 2/25/2010 - PLID 37234 - If this is a Smart Stamp table, we need to take this column out of the special sentence format
					// (z.manning 2010-07-26 15:50) - PLID 39848 - This now applies to all tables
					//if(m_bIsSmartStampTable) {
						CString strSentence;
						GetDlgItemText(IDC_SENTENCE, strSentence);
						strSentence.Replace("<" + pMove->m_strData + ">", "");
						SetDlgItemText(IDC_SENTENCE, strSentence);
					//}
				}
				else {
					m_pdlDataElementList->RemoveRow(pCurSel);
					// Move this element from one array to the other
					CEmrInfoDataElement *pMove = m_aryCurDataElements.GetAt(nIndex);
					m_aryCurDataElements.RemoveAt(nIndex, 1);
					m_aryCurDeletedDataElements.Add(pMove);
					// (c.haag 2011-03-16) - PLID 42814 - Delete this row from all common lists
					m_CommonListCollection.DeleteItems(pMove);

					// (j.jones 2012-09-21 13:42) - PLID 52316 - update any rows using this label as a parent
					if(pMove->m_bIsLabel) {
						TryRemoveParentLabelReferences(pMove);

						RecalculateAndApplyParentLabelComboSql();
					}

					// Update the sort orders of all subsequent elements in the cur list
					for (long i=0; i<m_aryCurDataElements.GetSize(); i++) {
						if(m_aryCurDataElements.GetAt(i)->m_nSortOrder > nSortOrder)
							m_aryCurDataElements.GetAt(i)->m_nSortOrder--;
					}
					// Update the sort orders of all subsequent rows in the on-screen datalist
					{
						// (b.cardillo 2006-01-30 17:36) - PLID 19025 - We used to go from the 
						// selected row forward, because we knew for 100% that the row order on 
						// was the same as the user's intended order.  But now that we have the 
						// checkbox that can designate an item as "sorted by name", the order 
						// is an independent property that doesn't imply an actual on-screen 
						// row order.  So now we loop through EVERY row, and only increment the 
						// order number of rows whose existing order number is higher than the 
						// incoming order.
						NXDATALIST2Lib::IRowSettingsPtr pRow = m_pdlDataElementList->GetFirstRow();
						while(pRow) {
							long nPriorSortOrder = VarLong(pRow->GetValue(delcSortOrder));
							if (nPriorSortOrder > nSortOrder) {
								pRow->PutValue(delcSortOrder, (long)(nPriorSortOrder - 1));
							}
							pRow = pRow->GetNextRow();
						}
					}
					// (c.haag 2007-04-12 12:07) - PLID 16050 - Reset the row selection
					m_pdlDataElementList->CurSel = NULL;
				}
				// (c.haag 2007-04-12 12:07) - PLID 16050 - Disable the sort buttons
				ReflectDataElementSelection();

				UpdateFormulaReferences();
			}
		}
	} NxCatchAll("CEmrItemEntryDlg::OnDeleteDataItem");
}

void CEmrItemEntryDlg::OnBtnAddDataItem() 
{
	if(!IsDlgButtonChecked(IDC_RADIO_TABLE)) {
		//normal list, so don't bother with a menu
		OnAddDataItem(FALSE);
		return;
	}

	CMenu mnu;
	mnu.m_hMenu = CreatePopupMenu();
	long nIndex = 0;
	// (c.haag 2008-10-23 12:01) - PLID 31708 - Change verbage for flipped tables
	if (IsDlgButtonChecked(IDC_TABLE_ROWS_AS_FIELDS)) {
		// (z.manning 2010-02-10 14:16) - PLID 37228 - No columns on flipped smart stamp tables
		// (j.jones 2010-02-25 11:02) - PLID 37538 - we decided that this was allowed
		mnu.InsertMenu(nIndex++, MF_BYPOSITION, 1, "Add New Column...");
		mnu.InsertMenu(nIndex++, MF_BYPOSITION, 2, "Add New Row...");
	} else {
		// (z.manning 2010-02-10 14:16) - PLID 37228 - No rows on smart stamp tables
		// (j.jones 2010-02-25 11:02) - PLID 37538 - we decided that this was allowed
		mnu.InsertMenu(nIndex++, MF_BYPOSITION, 1, "Add New Row...");
		mnu.InsertMenu(nIndex++, MF_BYPOSITION, 2, "Add New Column...");
	}

	CRect rc;
	CWnd *pWnd = GetDlgItem(IDC_ADD_DATA_ITEM);
	if (pWnd) {
		pWnd->GetWindowRect(&rc);
		switch(mnu.TrackPopupMenu(TPM_LEFTALIGN|TPM_RETURNCMD, rc.right, rc.top, this, NULL)) {
			case 1:
				OnAddDataItem(FALSE);
				break;
			case 2:
				OnAddDataItem(TRUE);
				break;			
		}
	}
}

// (j.jones 2009-08-13 09:52) - PLID 31730 - added ability to insert at a certain list position
void CEmrItemEntryDlg::OnAddDataItem(BOOL bColumnList, long nInsertWithSortOrder /*= -1*/)
{
	try {

		// (j.jones 2009-08-13 09:54) - PLID 31730 - if the sort order is higher than we have rows,
		// just append to the end
		if(bColumnList && m_aryCurColumnDataElements.GetSize() < nInsertWithSortOrder) {
			nInsertWithSortOrder = -1;
		}
		else if(!bColumnList && m_aryCurDataElements.GetSize() < nInsertWithSortOrder) {
			nInsertWithSortOrder = -1;
		}

		// (a.walling 2007-04-04 15:19) - PLID 25459 - Check for Medication permission
		// (will prompt for passwords)
		if (IsSystemCurrentMedicationsItem() && !bColumnList) {
			if(!CheckCurrentUserPermissions(bioPatientMedication, sptDynamic0)) {
				m_bAddingMultipleDataElements = FALSE;
				// (j.jones 2009-08-13 15:48) - PLID 31730 - reset the sort order of the last multiply-added row
				m_nLastMultiplyAddedItemSortOrder = -1;
				return;
			}
		}
		// (z.manning, 08/07/2007) - PLID 25741 - If it's the built-in allergies item, make sure the user has the permission to edit it.
		if(IsSystemAllergiesItem() && !bColumnList) {
			if(!CheckCurrentUserPermissions(bioPatientAllergies, sptDynamic0)) {
				m_bAddingMultipleDataElements = FALSE;
				// (j.jones 2009-08-13 15:48) - PLID 31730 - reset the sort order of the last multiply-added row
				m_nLastMultiplyAddedItemSortOrder = -1;
				return;
			}
		}

		// Create the row in the datalist and the array
		{
			// Decide the sort order number of the new data element

			// (j.jones 2009-08-13 10:02) - PLID 31730 - nInsertWithSortOrder already tells us
			// the sort order to use
			long nSortOrder = nInsertWithSortOrder;
			if(nSortOrder == -1) {
				if(bColumnList) {
					long nCount = m_aryCurColumnDataElements.GetSize();
					if (nCount != 0) {
						nSortOrder = m_aryCurColumnDataElements.GetAt(nCount - 1)->m_nSortOrder + 1;
					} else {
						nSortOrder = 1;
					}
				}
				else {
					long nCount = m_aryCurDataElements.GetSize();
					if (nCount != 0) {
						nSortOrder = m_aryCurDataElements.GetAt(nCount - 1)->m_nSortOrder + 1;
					} else {
						nSortOrder = 1;
					}
				}
			}

			// (z.manning 2010-02-12 12:41) - PLID 37320 - Moved this logic to its own function
			IncrementSortOrderGreaterThanOrEqualTo(nSortOrder, bColumnList);			

			long nListType = 1;
			if(IsDlgButtonChecked(IDC_RADIO_TABLE)) {
				if(bColumnList)
					nListType = 3;
				else
					nListType = 2;
			}

			// Create the new element in the array
			// (z.manning 2009-01-15 15:19) - PLID 32724 - Default InputMask to empty string
			// (j.jones 2011-03-08 12:25) - PLID 42282 - added EMCodeCategoryID, defaults to -1
			//TES 3/11/2011 - PLID 42757 - Added Glasses Order data
			// (r.gonet 08/03/2012) - PLID 51735 - Added Wound Care Data Type
			// (j.jones 2012-09-19 12:22) - PLID 52316 - added ParentLabelID, always defaults to -1
			// (j.gruber 2013-09-26 09:14) - PLID 58754 - added datagroupID, defaults to -1
			// (j.gruber 2014-07-17 13:39) - PLID 62621 - keyword fields, default to "" and false
			// (j.gruber 2014-12-05 15:37) - PLID 64361 - Load the new values for UseNameForKeyword
			CEmrInfoDataElement *pNewDataElement = new CEmrInfoDataElement(-2, "[New Data]", nSortOrder, FALSE, FALSE, nListType, FALSE, "", FALSE, -1, "", NULL, FALSE, -1, "", 2, "", 0, FALSE, "", etantInvalid, "", godtInvalid, -1, etatNone, 0, ", ", ", ", ", ", wcdtNone, -1, "", FALSE, FALSE);
			if(bColumnList) {
				// (j.jones 2009-08-13 15:20) - PLID 31730 - insert sorted
				BOOL bFound = FALSE;
				for(int i=0; i<m_aryCurColumnDataElements.GetSize() && !bFound; i++) {
					if(m_aryCurColumnDataElements.GetAt(i)->m_nSortOrder > nSortOrder) {
						//insert here
						bFound = TRUE;
						m_aryCurColumnDataElements.InsertAt(i, pNewDataElement);
					}
				}
				if(!bFound) {
					//add to the end
					m_aryCurColumnDataElements.Add(pNewDataElement);
				}
			}
			else {
				// (j.jones 2009-08-13 15:20) - PLID 31730 - insert sorted
				BOOL bFound = FALSE;
				for(int i=0; i<m_aryCurDataElements.GetSize() && !bFound; i++) {
					if(m_aryCurDataElements.GetAt(i)->m_nSortOrder > nSortOrder) {
						//insert here
						bFound = TRUE;
						m_aryCurDataElements.InsertAt(i, pNewDataElement);
					}
				}
				if(!bFound) {
					//add to the end
					m_aryCurDataElements.Add(pNewDataElement);
				}
			}

			// Create the row in the datalist
			NXDATALIST2Lib::IRowSettingsPtr pRow = CreateDatalistRowFromDataElement(pNewDataElement);
			if(!bColumnList) {

				// (j.jones 2012-09-20 12:58) - PLID 52316 - if a label, update the ParentLabelID column's
				// dropdown list with all current labels
				if(pNewDataElement->m_bIsLabel) {
					RecalculateAndApplyParentLabelComboSql();
				}

				NXDATALIST2Lib::IRowSettingsPtr pTmp = m_pdlDataElementList->AddRowSorted(pRow, NULL);
				if (pTmp != NULL) {
					// Addition was successful, make it the current selection
					m_pdlDataElementList->CurSel = pTmp;
					// Make sure the surrounding controls look right now that we've changed the selection
					ReflectDataElementSelection();
					// And start editing it (since the user probably doesn't want the name to be "New")
					m_pdlDataElementList->StartEditing(pTmp, delcData);
				}
			}
			else {
				NXDATALIST2Lib::IRowSettingsPtr pTmp = m_pdlColumnDataElementList->AddRowSorted(pRow, NULL);
				if (pTmp != NULL) {
					// Addition was successful, make it the current selection
					m_pdlColumnDataElementList->CurSel = pTmp;
					// Make sure the surrounding controls look right now that we've changed the selection
					ReflectDataElementSelection();
					// And start editing it (since the user probably doesn't want the name to be "New")
					m_pdlColumnDataElementList->StartEditing(pTmp, cdelcData);
				}
			}

			UpdateVisibleIndices();
			UpdateFormulaReferences();
		}
	} NxCatchAll("CEmrItemEntryDlg::OnAddDataItem");
}

void CEmrItemEntryDlg::OnBtnAddMultipleDataItem() 
{
	if(!IsDlgButtonChecked(IDC_RADIO_TABLE)) {
		//normal list, so don't bother with a menu
		OnAddMultipleDataItem(FALSE);
		return;
	}

	CMenu mnu;
	mnu.m_hMenu = CreatePopupMenu();
	long nIndex = 0;
	// (c.haag 2008-10-23 12:01) - PLID 31708 - Change verbage for flipped tables
	if (IsDlgButtonChecked(IDC_TABLE_ROWS_AS_FIELDS)) {
		// (z.manning 2010-02-10 14:17) - PLID 37228 - No columns on flipped smart stamp tables
		// (j.jones 2010-02-25 11:02) - PLID 37538 - we decided that this was allowed
		mnu.InsertMenu(nIndex++, MF_BYPOSITION, 1, "Add New Columns...");
		mnu.InsertMenu(nIndex++, MF_BYPOSITION, 2, "Add New Rows...");
	} else {
		// (z.manning 2010-02-10 14:17) - PLID 37228 - No rows on smart stamp tables
		// (j.jones 2010-02-25 11:02) - PLID 37538 - we decided that this was allowed
		mnu.InsertMenu(nIndex++, MF_BYPOSITION, 1, "Add New Rows...");
		mnu.InsertMenu(nIndex++, MF_BYPOSITION, 2, "Add New Columns...");
	}

	CRect rc;
	CWnd *pWnd = GetDlgItem(IDC_ADD_MULTIPLE_DATA_ITEM);
	if (pWnd) {
		pWnd->GetWindowRect(&rc);
		switch(mnu.TrackPopupMenu(TPM_LEFTALIGN|TPM_RETURNCMD, rc.right, rc.top, this, NULL)) {
			case 1:
				OnAddMultipleDataItem(FALSE);
				break;
			case 2:
				OnAddMultipleDataItem(TRUE);
				break;			
		}
	}
}

// (j.jones 2009-08-13 15:50) - PLID 31730 - added ability to insert at a certain list position
void CEmrItemEntryDlg::OnAddMultipleDataItem(BOOL bColumnList, long nInsertWithSortOrder /*= -1*/) 
{
	m_bAddingMultipleDataElements = TRUE;
	// (j.jones 2009-08-13 15:48) - PLID 31730 - reset the sort order of the last multiply-added row
	m_nLastMultiplyAddedItemSortOrder = -1;
	OnAddDataItem(bColumnList, nInsertWithSortOrder);
}

// (j.jones 2013-01-29 08:51) - PLID 54731 - Added bSilent to not warn about duplicate names.
// This now returns true if it succeeded, false if it didn't add due to being a duplicate name.
BOOL CEmrItemEntryDlg::AddDataElement(const CString &strDataText, BOOL bColumnList, BOOL bAddAction /*= FALSE*/, EmrActionObject eaoDestType /*= eaoCpt*/, long nDestID /*= -1*/, BOOL bSilent /*= FALSE*/)
{
	//double check to make sure it doesn't already exist
	if(bColumnList) {
		for(int i=0; i<m_aryCurColumnDataElements.GetSize(); i++) {
			if(CString(strDataText).CompareNoCase(m_aryCurColumnDataElements.GetAt(i)->m_strData) == 0) {
				if(!bSilent) {
					/**** (j.gruber 2013-09-30 10:48) - PLID 58676 - THE TABLE CELL CODES WORK ON THE FACT THAT NO ROWS/COLUMNS HAVE THE SAME NAME
					IF THIS EVER CHANGES IN THE FUTURE, YOU'LL NEED TO CHANGE THAT FUNCTIONALITY ALSO*/

					CString strWarning;
					if(m_aryCurColumnDataElements.GetAt(i)->m_bInactive) {
						strWarning.Format("This table already has an inactive column with the name '%s'.\n"
							"A table cannot have two columns with the same name. You may, however, reactivate the existing column.",_Q(strDataText));
					}
					else {
						strWarning.Format("This table already has an column with the name '%s'.\n"
							"A table cannot have two columns with the same name.",_Q(strDataText));
					}
					AfxMessageBox(strWarning);
				}
				return FALSE;
			}
		}
	}
	else {
		for(int i=0; i<m_aryCurDataElements.GetSize(); i++) {
			if(CString(strDataText).CompareNoCase(m_aryCurDataElements.GetAt(i)->m_strData) == 0) {
				if(!bSilent) {
					CString strWarning;
					if(IsDlgButtonChecked(IDC_RADIO_TABLE)) {
						/**** (j.gruber 2013-09-30 10:48) - PLID 58676 - THE TABLE CELL CODES WORK ON THE FACT THAT NO ROWS/COLUMNS HAVE THE SAME NAME
						IF THIS EVER CHANGES IN THE FUTURE, YOU'LL NEED TO CHANGE THAT FUNCTIONALITY ALSO*/
						if(m_aryCurDataElements.GetAt(i)->m_bInactive) {
							strWarning.Format("This table already has an inactive row with the name '%s'.\n"
								"A table cannot have two rows with the same name. You may, however, reactivate the existing row.", strDataText);
						}
						else {
							strWarning.Format("This table already has a row with the name '%s'.\n"
								"A table cannot have two rows with the same name.", strDataText);
						}
					}
					else {
						BOOL bIsInactive = m_aryCurDataElements.GetAt(i)->m_bInactive;
						if(bIsInactive) {
							strWarning.Format("This list already has an item with the name '%s'.\n"
								"A list cannot have two items with the same name. You may, however, reactivate the existing item.", strDataText);
						}
						else {
							strWarning.Format("This list already has an item with the name '%s'.\n"
								"A list cannot have two items with the same name.", strDataText);
						}
					}
					AfxMessageBox(strWarning);
				}
				return FALSE;
			}
		}
	}

	// Decide the sort order number of the new data element
	long nSortOrder;
	{
		if(bColumnList) {
			long nCount = m_aryCurColumnDataElements.GetSize();
			if (nCount != 0) {
				nSortOrder = m_aryCurColumnDataElements.GetAt(nCount - 1)->m_nSortOrder + 1;
			} else {
				nSortOrder = 1;
			}
		}
		else {
			long nCount = m_aryCurDataElements.GetSize();
			if (nCount != 0) {
				nSortOrder = m_aryCurDataElements.GetAt(nCount - 1)->m_nSortOrder + 1;
			} else {
				nSortOrder = 1;
			}
		}
	}

	long nListType = 1;
	if(IsDlgButtonChecked(IDC_RADIO_TABLE)) {
		if(bColumnList)
			nListType = 3;
		else
			nListType = 2;
	}

	// Create the new element
	// (z.manning 2009-01-15 15:19) - PLID 32724 - Default InputMask to empty string
	// (j.jones 2011-03-08 12:25) - PLID 42282 - added EMCodeCategoryID, defaults to -1
	//TES 3/11/2011 - PLID 42757 - Added Glasses Order data
	// (r.gonet 08/03/2012) - PLID 51735 - Added Wound Care Data Type
	// (j.jones 2012-09-19 12:22) - PLID 52316 - added ParentLabelID, always defaults to -1
	// (j.gruber 2013-09-26 09:14) - PLID 58754 - added datagroupID, defaults to -1
	// (j.gruber 2014-07-17 13:39) - PLID 62621 - keyword fields, default to "" and false
	// (j.gruber 2014-12-05 15:37) - PLID 64361 - Load the new values for UseNameForKeyword
	CEmrInfoDataElement *pNewDataElement = new CEmrInfoDataElement(-1, strDataText, nSortOrder, FALSE, FALSE, nListType, FALSE, "", FALSE, -1, "", NULL, FALSE, -1, "", 2, "", 0, FALSE, "", etantInvalid, "", godtInvalid, -1, etatNone, 0, ", ", ", ", ", ", wcdtNone, -1, "", FALSE, FALSE);
	if (bAddAction) {
		EmrAction ea;
		ea.nID = -1;
		ea.eaoSourceType = eaoEmrDataItem;
		ea.nSourceID = -1;
		ea.eaoDestType = eaoDestType;
		ea.nDestID = nDestID;
		ea.nSortOrder = 1;
		ea.bPopup = false;
		ea.bSpawnAsChild = false;
		//DRT 1/10/2007 - If we're spawning a new item, the EmrAction will default the
		//	cpt specific data for us, we don't have any sensible defaults at this point in time.
		
		// (j.jones 2007-07-16 16:16) - PLID 26694 - bOnePerEmn is a value of EmrAction for the
		// purposes of efficiency, but is not a property of the action, and isn't needed here
		// for future saving purposes.

		pNewDataElement->m_arActions.Add(ea);
	}

	// Put the new element in the array
	if(!bColumnList)
		m_aryCurDataElements.Add(pNewDataElement);
	else
		m_aryCurColumnDataElements.Add(pNewDataElement);

	// Create the row in the datalist
	//TES 3/14/2011 - PLID 42784 - Converted to datalist2
	if(!bColumnList) {
		m_pdlDataElementList->AddRowSorted(CreateDatalistRowFromDataElement(pNewDataElement), NULL);

		// (j.jones 2012-09-20 12:58) - PLID 52316 - if a label, update the ParentLabelID column's
		// dropdown list with all current labels
		if(pNewDataElement->m_bIsLabel) {
			RecalculateAndApplyParentLabelComboSql();
		}
	}
	else
		m_pdlColumnDataElementList->AddRowSorted(CreateDatalistRowFromDataElement(pNewDataElement), NULL);

	UpdateVisibleIndices();
	UpdateFormulaReferences();

	return TRUE;
}

// (z.manning 2010-02-12 12:40) - PLID 37320
void CEmrItemEntryDlg::AddDataElement(CEmrInfoDataElement *peide, BOOL bColumnList)
{
	IncrementSortOrderGreaterThanOrEqualTo(peide->m_nSortOrder, bColumnList);

	if(bColumnList) {
		BOOL bFound = FALSE;
		for(int i=0; i<m_aryCurColumnDataElements.GetSize() && !bFound; i++) {
			if(m_aryCurColumnDataElements.GetAt(i)->m_nSortOrder > peide->m_nSortOrder) {
				bFound = TRUE;
				m_aryCurColumnDataElements.InsertAt(i, peide);
			}
		}
		if(!bFound) {
			m_aryCurColumnDataElements.Add(peide);
		}
	}
	else {
		BOOL bFound = FALSE;
		for(int i=0; i<m_aryCurDataElements.GetSize() && !bFound; i++) {
			if(m_aryCurDataElements.GetAt(i)->m_nSortOrder > peide->m_nSortOrder) {
				bFound = TRUE;
				m_aryCurDataElements.InsertAt(i, peide);
			}
		}
		if(!bFound) {
			m_aryCurDataElements.Add(peide);
		}
	}

	// Create the row in the datalist
	//TES 3/14/2011 - PLID 42784 - Converted to datalist2
	// (j.jones 2011-05-04 09:24) - PLID 43527 - if we add an inactive element, don't display it unless
	// Show Inactive is checked
	if(IsDlgButtonChecked(IDC_SHOW_INACTIVE_ELEMENTS) || !peide->m_bInactive) {
		if(!bColumnList) {
			m_pdlDataElementList->AddRowSorted(CreateDatalistRowFromDataElement(peide), NULL);

			// (j.jones 2012-09-20 12:58) - PLID 52316 - if a label, update the ParentLabelID column's
			// dropdown list with all current labels
			if(peide->m_bIsLabel) {
				RecalculateAndApplyParentLabelComboSql();
			}
		}
		else {
			m_pdlColumnDataElementList->AddRowSorted(CreateDatalistRowFromDataElement(peide), NULL);
		}
	}

	UpdateVisibleIndices();
	UpdateFormulaReferences();
}

// (z.manning 2010-02-12 12:39) - PLID 37320 - Function to increment the sort order by 1 for all
// rows or cols with a sort order greater than or equal to nSortOrder.
void CEmrItemEntryDlg::IncrementSortOrderGreaterThanOrEqualTo(const long nSortOrder, BOOL bColumnList)
{
	// (j.jones 2009-08-13 10:02) - PLID 31730 - update the sort orders of all subsequent elements in the cur list
	if(bColumnList) {			
		for (long i=0; i<m_aryCurColumnDataElements.GetSize(); i++) {
			if(m_aryCurColumnDataElements.GetAt(i)->m_nSortOrder >= nSortOrder)
				m_aryCurColumnDataElements.GetAt(i)->m_nSortOrder++;
		}

		//TES 3/14/2011 - PLID 42784 - Converted to datalist2
		NXDATALIST2Lib::IRowSettingsPtr pRow = m_pdlColumnDataElementList->GetFirstRow();
		while(pRow) {
			long nPriorSortOrder = VarLong(pRow->GetValue(cdelcSortOrder));
			if (nPriorSortOrder >= nSortOrder) {
				pRow->PutValue(cdelcSortOrder, (long)(nPriorSortOrder + 1));
			}
			pRow = pRow->GetNextRow();
		}
	}
	else {
		for (long i=0; i<m_aryCurDataElements.GetSize(); i++) {
			if(m_aryCurDataElements.GetAt(i)->m_nSortOrder >= nSortOrder)
				m_aryCurDataElements.GetAt(i)->m_nSortOrder++;
		}

		//TES 3/14/2011 - PLID 42784 - Converted to datalist2
		NXDATALIST2Lib::IRowSettingsPtr pRow = m_pdlDataElementList->GetFirstRow();
		while (pRow) {
			long nPriorSortOrder = VarLong(pRow->GetValue(delcSortOrder));
			if (nPriorSortOrder >= nSortOrder) {
				pRow->PutValue(delcSortOrder, (long)(nPriorSortOrder + 1));
			}
			pRow = pRow->GetNextRow();
		}
	}
}

// (j.jones 2013-01-28 11:57) - PLID 54731 - renamed Add Product to Add Other
void CEmrItemEntryDlg::OnBtnAddOtherDataItem() 
{
	try {

		//this button now always opens a pop-out list

		enum {
			miAddProductList = 1,
			miAddProductAsRows,
			miAddProductAsColumns,
			miAddMedicationsList,
			miAddMedicationsAsRows,
			miAddMedicationsAsColumns,
		};

		CMenu mnu;
		mnu.m_hMenu = CreatePopupMenu();

		bool bUseSubmenus = false;
		CMenu pSubMenuProducts;
		CMenu pSubMenuMedications;

		if(IsDlgButtonChecked(IDC_RADIO_TABLE)) {
			bUseSubmenus = true;
			pSubMenuProducts.m_hMenu = CreatePopupMenu();	
			pSubMenuMedications.m_hMenu = CreatePopupMenu();
		}

		//we will disable medications on current meds & allergy tables
		BOOL bEnableMedications = (eistCurrentMedicationsTable != m_DataSubType && eistAllergiesTable != m_DataSubType);
		//we will hide the inventory options if they don't have the license
		BOOL bHasInventoryLicense = g_pLicense->CheckForLicense(CLicense::lcInv, CLicense::cflrSilent);

		if(!bUseSubmenus) {
			mnu.InsertMenu(0, MF_BYPOSITION|(bEnableMedications ? 0 : MF_DISABLED|MF_GRAYED), miAddMedicationsList, "Add Medications...");
			if(bHasInventoryLicense) {
				mnu.InsertMenu(1, MF_BYPOSITION, miAddProductList, "Add Product...");
			}
		}
		else {
			pSubMenuMedications.InsertMenu(0, MF_BYPOSITION|(bEnableMedications ? 0 : MF_DISABLED|MF_GRAYED), miAddMedicationsAsRows, IsDlgButtonChecked(IDC_TABLE_ROWS_AS_FIELDS) ? "Add As New Column..." : "Add As New Row...");
			pSubMenuMedications.InsertMenu(1, MF_BYPOSITION|(bEnableMedications ? 0 : MF_DISABLED|MF_GRAYED), miAddMedicationsAsColumns, IsDlgButtonChecked(IDC_TABLE_ROWS_AS_FIELDS) ? "Add As New Row..." : "Add As New Column...");
			mnu.InsertMenu(0, MF_BYPOSITION|MF_POPUP|(bEnableMedications ? 0 : MF_DISABLED|MF_GRAYED), (UINT)pSubMenuMedications.m_hMenu, "Add Medications...");

			if(bHasInventoryLicense) {
				pSubMenuProducts.InsertMenu(0, MF_BYPOSITION, miAddProductAsRows, IsDlgButtonChecked(IDC_TABLE_ROWS_AS_FIELDS) ? "Add As New Column..." : "Add As New Row...");
				pSubMenuProducts.InsertMenu(1, MF_BYPOSITION, miAddProductAsColumns, IsDlgButtonChecked(IDC_TABLE_ROWS_AS_FIELDS) ? "Add As New Row..." : "Add As New Column...");
				mnu.InsertMenu(1, MF_BYPOSITION|MF_POPUP, (UINT)pSubMenuProducts.m_hMenu, "Add Product...");
			}
		}

		CRect rc;
		CWnd *pWnd = GetDlgItem(IDC_ADD_OTHER_DATA_ITEM);
		if (pWnd) {
			pWnd->GetWindowRect(&rc);
			switch(mnu.TrackPopupMenu(TPM_LEFTALIGN|TPM_RETURNCMD, rc.right, rc.top, this, NULL)) {
				case miAddMedicationsList:
					OnAddMedicationDataItem(FALSE, TRUE);
					break;
				case miAddMedicationsAsRows:
					OnAddMedicationDataItem(FALSE);
					break;
				case miAddMedicationsAsColumns:
					OnAddMedicationDataItem(TRUE);
					break;
				case miAddProductList:
				case miAddProductAsRows:
					OnAddInvDataItem(FALSE);
					break;
				case miAddProductAsColumns:
					OnAddInvDataItem(TRUE);
					break;			
			}
		}

	}NxCatchAll(__FUNCTION__);
}

void CEmrItemEntryDlg::OnAddInvDataItem(BOOL bColumnList) 
{
	try {
		// Pop up the selection dialog
		CEMRSelectProductDlg dlg(this);
		
		if(IsDlgButtonChecked(IDC_RADIO_TABLE))
			dlg.m_bDisableInvAction = TRUE;

		if (dlg.DoModal() == IDOK) {
			// The user hit OK
			if (dlg.m_nSelectedProductID == -1 && dlg.m_nSelectedCategoryID == -1) {
				// We know the user hit ok, so this should be impossible ("OK" but nothing selected)
				ASSERT(FALSE);
				return;
			} else {

				BOOL bAddToCurrentList = FALSE;

				// Prompt to add to the current list as will if applicable.
				// (c.haag 2006-07-05 16:51) - PLID 19862 - This is obselete since we no longer have a current list
				if(m_bMaintainCurrentList) {
					//if(m_pSelectListTab->GetCurSel() == sltAdminList) {
					//	if(IDNO != DontShowMeAgain("Would you like to add the product(s) to the current list as well?"
					//		"\r\nIf yes, the item(s) will be added once you save this EMN."
					//		"\r\n\r\n(Checking 'Don't Show Me Again' will always add in the future.)", "AddToCurrentListToo", "Practice", FALSE, TRUE))
					//	{
							bAddToCurrentList = TRUE;
					//	}
					//}
					//else if(m_pSelectListTab->GetCurSel() == sltCurrentList) {
					//
					//	bAddToCurrentList = TRUE;
					//
					//	if(IDNO == DontShowMeAgain("Adding a product to the current list requires it to be added to the admin list."
					//		"\r\nDo you still wish to add the product(s)?"
					//		"\r\n\r\n(Checking 'Don't Show Me Again' will always add in the future.)", "AddToAdminListToo", "Practice", FALSE, TRUE))
					//	{
					//		// Cancel the operation
					//		return;
					//	}
					//}
				}

				if (dlg.m_nSelectedProductID != -1) {
					// One product chosen
					AddDataElement(dlg.m_strProductName, bColumnList, dlg.m_bAutoAddAction, eaoCpt, dlg.m_nSelectedProductID);
					if(bAddToCurrentList) {
						CurrentListItem cli;
						cli.strData = dlg.m_strProductName;
						cli.bSelected = false;
						cli.bSelectedOnTopic = cli.bSelected; // (a.walling 2008-02-07 11:05) - PLID 14982 - Match the selected value
						m_aryCurrentList.Add(cli);
					}

				} else if (dlg.m_nSelectedCategoryID != -1) {
					// A whole category of products

					// Get the set of products that we are going to add
					_RecordsetPtr rs = CreateRecordset(
						"SELECT ServiceT.ID, ServiceT.Name FROM ServiceT INNER JOIN ProductT ON ServiceT.ID = ProductT.ID "
						"WHERE Category = %li AND Active = 1", dlg.m_nSelectedCategoryID);
					// Loop through adding each product
					FieldsPtr pflds = rs->GetFields();
					FieldPtr fldID = pflds->GetItem("ID");
					FieldPtr fldName = pflds->GetItem("Name");
					while (!rs->eof) {
						AddDataElement(AdoFldString(fldName), bColumnList, dlg.m_bAutoAddAction, eaoCpt, AdoFldLong(fldID));
						if(bAddToCurrentList) {
							CurrentListItem cli;
							cli.strData = AdoFldString(fldName);
							cli.bSelected = false;
							cli.bSelectedOnTopic = cli.bSelected; // (a.walling 2008-02-07 11:05) - PLID 14982 - Match the selected value
							m_aryCurrentList.Add(cli);
						}
						rs->MoveNext();
					}
				}
			}
		}

	} NxCatchAll(__FUNCTION__);
}

// (j.jones 2013-01-28 12:17) - PLID 54731 - added ability to add medications
void CEmrItemEntryDlg::OnAddMedicationDataItem(BOOL bColumnList, BOOL bAddAsAction /*= FALSE*/)
{
	try {
		
		// (j.jones 2013-03-05 10:01) - PLID 55376 - changed so this interface
		// has its own dedicated dialog
		CEMRSelectMedicationsDlg dlg(this);
		if(dlg.DoModal() == IDOK) {

			if(dlg.m_arySelectedMeds.GetSize() == 0) {
				return;
			}

			BOOL bAddToCurrentList = FALSE;

			if(m_bMaintainCurrentList) {
				bAddToCurrentList = TRUE;
			}

			CString strBadNames = "";
			long nCountBadNames = 0;

			for(int i=0;i<dlg.m_arySelectedMeds.GetSize();i++) {
				IdName idNameElement = dlg.m_arySelectedMeds.GetAt(i);
				if(AddDataElement(idNameElement.strName, bColumnList, bAddAsAction, eaoMedication, idNameElement.nID, TRUE)) {
					if(bAddToCurrentList) {
						CurrentListItem cli;
						cli.strData = idNameElement.strName;
						cli.bSelected = false;
						cli.bSelectedOnTopic = cli.bSelected; // (a.walling 2008-02-07 11:05) - PLID 14982 - Match the selected value
						m_aryCurrentList.Add(cli);
					}
				}
				else {
					//the add would fail if it was a duplicate name
					if(nCountBadNames < 20) {
						if(!strBadNames.IsEmpty()) {
							strBadNames += "\n";
						}
						strBadNames += idNameElement.strName;
					}
					nCountBadNames++;
				}
			}

			if(nCountBadNames > 20) {
				//we would have only tracked 20 duplicate names, if there were more, say so
				strBadNames += "\n<more...>";
			}

			if(nCountBadNames > 0) {
				CString strMessage;
				strMessage.Format("The following medications could not be added because an entry with the same name already exists:\n\n"
					"%s", strBadNames);
				AfxMessageBox(strMessage);
			}
		}

	} NxCatchAll(__FUNCTION__);
}

BOOL CEmrItemEntryDlg::IsMedicationInUse(long nMedicationID, CString &strCounts) {

	_RecordsetPtr rs;
	CString str;
	strCounts = "";
	BOOL bNoDelete = FALSE;
		
	rs = CreateParamRecordset("SELECT Count(ID) AS Count FROM PatientMedications WHERE MedicationID = {INT} AND Deleted = 0", nMedicationID);
	if (!rs->eof) {
		long nCount = AdoFldLong(rs, "Count", -1);
		if (nCount > 0) {
			//we can't delete
			str.Format(" - %li prescriptions\n",  nCount);
			strCounts += str;
			bNoDelete = TRUE;
		}
	}
	
	rs = CreateParamRecordset("SELECT Count(MedicationID) as Count FROM CurrentPatientMedsT WHERE MedicationID = {INT}", nMedicationID);
	
	if (! rs->eof) {
		long nCount = AdoFldLong(rs, "Count");
		if (nCount > 0) {
			//we can't delete
			str.Format(" - %li current medications\n",  nCount);
			strCounts += str;
			bNoDelete = TRUE;
		}
	}


	rs = CreateParamRecordset("SELECT Count(MedicationID) as Count FROM MedSchedDetailsT WHERE MedicationID = {INT} ", nMedicationID);
	
	if (!rs->eof) {
		long nCount = AdoFldLong(rs, "Count");
		
		if (nCount > 0) {
			//we can't delete
			str.Format(" - %li medication schedules\n",  nCount);
			strCounts += str;
			bNoDelete = TRUE;
		}
	}

	rs = CreateParamRecordset("SELECT Count(ID) as Count FROM PatientMedications WHERE MedicationID = {INT} "
		" AND ID IN (SELECT MedicationID FROM EMRMedicationsT)", nMedicationID);
	if (!rs->eof) {
		long nCount = AdoFldLong(rs, "Count");
		if (nCount > 0) {
			//we can't delete
			str.Format(" - %li EMN prescriptions (They may be marked as deleted.)\n",  nCount);
			strCounts += str;
			bNoDelete = TRUE;
		}
			
	}

	rs = CreateParamRecordset("SELECT Count(DISTINCT EMRTemplateID) as Count FROM EMRTemplatePrescriptionsT WHERE MedicationID = {INT} ", nMedicationID);
	
	if (!rs->eof) {
		long nCount = AdoFldLong(rs, "Count");

		if (nCount > 0) {
			//we can't delete
			str.Format(" - %li EMN Templates. (They may be marked as deleted.)\n", nCount);
			strCounts += str;
			bNoDelete = TRUE;
			
		}
	}

	// (c.haag 2007-02-12 17:22) - PLID 24422 - Do not delete if the medication is in use by an EMR detail
	rs = CreateParamRecordset(
		"SELECT Count(*) as Count FROM EMRDetailTableDataT \r\n"
		"LEFT JOIN EmrDataT ON EmrDataT.ID = EMRDetailTableDataT.EMRDataID_Y \r\n"
		"WHERE "
		// The table data belongs to a detail that is not deleted
		"EmrDetailID IN (SELECT ID FROM EMRDetailsT WHERE Deleted = 0 AND EMRID IN (SELECT ID FROM EMRMasterT WHERE Deleted = 0)) \r\n"
		// The table data is not populated (regardless of column)
		// (z.manning 2008-12-10 16:00) - PLID 32389 - We now check for non-blank data in all column types
		// (a.walling 2009-04-03 10:44) - PLID 33831 - blank data is no longer saved to the database
		/*
		"	AND Len(EMRDetailTableDataT.Data) > 0 \r\n"
		"	AND ( \r\n"
		"		(ListType = 4 AND EMRDetailTableDataT.Data <> '0' AND EMRDetailTableDataT.Data <> '-1') \r\n" // dropdown
		"		OR (ListType = 5 AND EMRDetailTableDataT.Data <> '0' AND EMRDetailTableDataT.Data <> '-1') \r\n" // checkbox
		"	) \r\n"					
		*/
		// The table row belongs to this medication
		"AND EMRDataID_X IN (SELECT EMRDataID FROM DrugList WHERE ID = {INT}) \r\n", nMedicationID);

	if (!rs->eof) {

		long nCount = AdoFldLong(rs, "Count");
		if (nCount > 0) {
			str.Format(" - %li patient medical records", nCount);
			strCounts += str;
			bNoDelete = TRUE;
		}
	}

	return bNoDelete;

}

// (z.manning 2010-04-19 11:30) - PLID 29301 - PLID 29301 - Will check data to see if an EMR data item is in use
BOOL CEmrItemEntryDlg::CheckDataItemUseInDataForLabel(const long nDataID)
{
	if (nDataID == -1) {
		return FALSE;
	}

	// (b.cardillo 2009-07-22 12:07) - PLID 34844 - As a convenience we detect here whether the data element is in 
	// use by any wellness template criteria.
	CDWordArray arydwDataIDs;
	arydwDataIDs.Add(nDataID);
	_RecordsetPtr prs = GetWellnessTemplatesThatReferenceEMRInfoDataElements(GetRemoteData(), m_nEmrInfoMasterID, arydwDataIDs);
	CString strReferences = GenerateDelimitedListFromRecordsetColumn(prs, "Name", " - ", "\r\n");
	if (!strReferences.IsEmpty()) {
		// There are some, so warn the user and fail
		MsgBox(MB_ICONWARNING|MB_OK, 
			"You may not change this list element to a label because it is referenced in the criteria of the following Wellness Template(s): \r\n"
			"\r\n%s\r\n\r\n"
			"Please remove this list element from all Wellness Criteria before attempting to change it to a label."
			,
			strReferences);
		return TRUE;
	}

	if(ReturnsRecords("SELECT EmrDataID FROM EmrSelectT WHERE EmrDataID = %li", nDataID))
	{
		MsgBox("This item has been selected on existing EMNs.  It cannot be made into a label.");
		return TRUE;
	}
	// (z.manning 2010-04-20 11:26) - PLID 29301 - Tables can now have labels
	if(ReturnsRecords("SELECT ID FROM EMRDetailTableDataT WHERE EmrDataID_X = %li OR EmrDataID_Y = %li", nDataID, nDataID))
	{
		MsgBox("This item has table data filled out on existing EMNs.  It cannot be made into a label.");
		return TRUE;
	}
	// (a.wilson 2012-07-16 16:35) - PLID 51306 - prevent them from changing to a label.
	CString strAssignedTo = IsDataIDAssignedInGraphing(nDataID);
	if (!strAssignedTo.IsEmpty()) {
		MsgBox("The following item is assigned in graphing.\r\n\r\nAreas Assigned:\r\n%s\r\n"
			"You cannot make an item that is assigned in graphing into a label.", strAssignedTo);
		return TRUE;
	}

	if(ReturnsRecords("SELECT EmrDataID FROM EmrTemplateSelectT WHERE EmrDataID = %li", nDataID))
	{
		if(IDYES != MsgBox(MB_YESNO, "This item is the default on at least one existing EMN Template.  Are you sure you wish to make it a label?")) {
			return TRUE;
		}
	}
	// (z.manning 2010-04-20 11:26) - PLID 29301 - Tables can now have labels
	if(ReturnsRecords("SELECT ID FROM EMRTemplateTableDefaultsT WHERE EmrDataID_X = %li OR EmrDataID_Y = %li", nDataID, nDataID))
	{
		if(IDYES != MsgBox(MB_YESNO, "This item has table data filled out on at least one existing EMN Template.  Are you sure you wish to make it a label?")) {
			return TRUE;
		}
	}

	return FALSE;
}

//TES 3/14/2011 - PLID 42784 - Converted to datalist2, this function doesn't actually do anything so I didn't recreate it
/*void CEmrItemEntryDlg::OnLeftClickEmrColumnDataList(long nRow, short nCol, long x, long y, long nFlags) 
{
	// Make sure we clicked a row
	if (nRow == sriNoRow) {
		return;
	}

	try {
		
		
	} NxCatchAll("CEmrItemEntryDlg::OnLeftClickEmrColumnDataList");
}*/

BOOL CEmrItemEntryDlg::Validate()
{
	// (a.walling 2009-07-01 16:02) - PLID 34759
	m_nOriginalInfoID = m_nID;

	// (c.haag 2006-02-28 11:09) - PLID 12763 - Warn if a user is about to
	// add an inactive item to a topic
	if (m_bWillAddToTopic && IsDlgButtonChecked(IDC_CHECK_EMRINFO_INACTIVE)) {
		AfxMessageBox("You cannot add an inactive item to an EMR. Please uncheck the 'Inactive' checkbox before saving.");
		return FALSE;
	}

	//warn if the item name is empty
	CString strName;
	GetDlgItemText(IDC_ITEM_NAME, strName);
	strName.TrimRight();
	strName.TrimLeft();
	SetDlgItemText(IDC_ITEM_NAME, strName);
	if(strName.IsEmpty()) {
		AfxMessageBox("You cannot have an item with no name. Please enter a name before saving.");
		return FALSE;
	}

	// (j.jones 2006-03-02 11:09) - PLID 19372 - if there is any other active EMR item with the same name,
	// and we are changing this item's name OR reactivating it, then stop them from saving
	if(ReturnsRecords("SELECT EmrInfoMasterT.ID FROM EMRInfoT INNER JOIN EmrInfoMasterT ON EmrInfoT.ID = EmrInfoMasterT.ActiveEmrInfoID WHERE Name = '%s' AND EmrInfoMasterT.ID <> %li AND Inactive = 0", _Q(strName), m_nEmrInfoMasterID)
		&& (IsRecordsetEmpty("SELECT EmrInfoMasterT.ID FROM EMRInfoT INNER JOIN EmrInfoMasterT ON EmrInfoT.ID = EmrInfoMasterT.ActiveEmrInfoID WHERE Name = '%s' AND EmrInfoMasterT.ID = %li", _Q(strName), m_nEmrInfoMasterID) 
		|| ((ReturnsRecords("SELECT ID FROM EMRInfoMasterT WHERE Inactive = 1 AND ID = %li", m_nEmrInfoMasterID))) && !IsDlgButtonChecked(IDC_CHECK_EMRINFO_INACTIVE))) {
		if(IDNO == MessageBox("There is already an active EMR item with this name.\n"
			"It is recommended that you enter unique names for EMR items to minimize confusion.\n\n"
			"Do you still wish to use this name?","Practice",MB_ICONQUESTION|MB_YESNO)) {
			return FALSE;
		}
	}

	// (j.gruber 2009-11-23 13:10) - PLID 35945 - another check before saving for TOPS codes
	NXDATALIST2Lib::IRowSettingsPtr pCodeRow = m_dlEmrDataCode->CurSel;
	if (pCodeRow) {
		
		CString strCode = VarString(pCodeRow->GetValue(lcCode), "");

		// (j.gruber 2010-01-18 10:18) - PLID 36929 took out report and thus codes
		if (IsTOPSCode(strCode) /*|| IsReportCode(strCode)*/) {

			// (j.gruber 2009-12-23 09:53) - PLID 35771			
			if (!CheckTOPSCodeAgainstType(strCode, "")) {				
				return FALSE;
			}
		}
	
		// (j.gruber 2010-04-28 12:17) - PLID 38377 - BOLD codes
		if (IsBOLDCode(strCode) ) {
			
			if (!CheckBOLDCodeAgainstType(strCode, "")) {				
				return FALSE;
			}
		}
	}

	//warn if a list with no rows
	if(IsDlgButtonChecked(IDC_RADIO_LIST_SELECT) || IsDlgButtonChecked(IDC_RADIO_LIST_MULTISELECT)) {

		if(m_bMaintainCurrentList) {

			//check both the admin and current lists, if we're editing both

			// (c.haag 2006-07-12 15:13) - PLID 19862 - Don't check the current list when validating
			//BOOL bCurrentListOK = FALSE;
			BOOL bAdminListOK = FALSE;

			for (long i=0; i<m_aryCurDataElements.GetSize(); i++) {
				CEmrInfoDataElement *peide = m_aryCurDataElements.GetAt(i);
				if (!peide->m_bInactive) {
					if(peide->m_nListType < 3) {
						//if(FindInCurrentList(peide->m_strData) != -1) {
						//	bCurrentListOK = TRUE;
						//}
						bAdminListOK = TRUE;
					}
				}
				//else if(FindInCurrentList(peide->m_strData) != -1) {
				//	bCurrentListOK = TRUE;
				//}
			}

			// (c.haag 2006-03-10 16:20) - PLID 19378 - Flag the current list as being "OK" if you changed the
			// data type such that the current list would be overwritten
			//if (m_bMaintainCurrentList) {
			//	long nNewSelect = CalcDataTypeByCurSelection();
			//	if (nNewSelect != m_nDataType && (nNewSelect == 2 || nNewSelect == 3)) {
			//		bCurrentListOK = TRUE;
			//	}
			//}

			//if(!bCurrentListOK && !bAdminListOK) {
			//	AfxMessageBox("You must have at least one item in the current list and one active item in the Admin List.");
			//	return FALSE;

			//}
			//else 
			if(!bAdminListOK) {
				//PLID 21696 - the admin/current list doesn't exist anymore, so this message should be changed
				AfxMessageBox("You must have at least one active item in the list.");
				return FALSE;
			}
			//else if(!bCurrentListOK) {
			//	AfxMessageBox("You must have at least one item in the Current List.");
			//	return FALSE;
			//}
		}
		else {

			//otherwise just check the datalist

			BOOL bOK = FALSE;
			//TES 3/14/2011 - PLID 42784 - Converted to datalist2
			NXDATALIST2Lib::IRowSettingsPtr pRow = m_pdlDataElementList->GetFirstRow();
			while(pRow && !bOK) {
				if(!VarBool(pRow->GetValue(delcInactive))) {
					bOK = TRUE;
				}
				pRow = pRow->GetNextRow();
			}

			if(!bOK) {
				AfxMessageBox("A list must have at least one active item.");
				return FALSE;
			}
		}
	}

	//warn if a table and no rows or columns, or warn if only one column is marked as "grouped"
	if(IsDlgButtonChecked(IDC_RADIO_TABLE))
	{
		// (a.walling 2007-11-05 16:08) - PLID 27980 - VS2008 - for() loops
		int i = 0;
		
		BOOL bOK = FALSE;
		// (z.manning 2010-02-11 14:41) - PLID 37228 - Smart stamp tables are not required to have a row
		if(!m_bIsSmartStampTable) {
			//TES 3/14/2011 - PLID 42784 - Converted to datalist2
			NXDATALIST2Lib::IRowSettingsPtr pRow = m_pdlDataElementList->GetFirstRow();
			while(pRow && !bOK) {
				if(!VarBool(pRow->GetValue(delcInactive))) {
					bOK = TRUE;
				}
				pRow = pRow->GetNextRow();
			}

			if(!bOK) {
				//TES 8/30/2010 - PLID 38255 - Specify whether this is a row or a column.
				CString strRowCol = IsDlgButtonChecked(IDC_TABLE_ROWS_AS_FIELDS)?"column":"row";
				AfxMessageBox("A table must have at least one active " + strRowCol + ".");
				return FALSE;
			}
		}

		bOK = FALSE;
		
		long nCountGroupedColumns = 0;

		//TES 3/14/2011 - PLID 42784 - Converted to datalist2
		NXDATALIST2Lib::IRowSettingsPtr pRow= m_pdlColumnDataElementList->GetFirstRow();
		while(pRow) {

			//check grouped columns
			if(VarBool(pRow->GetValue(cdelcIsGrouped))) {
				nCountGroupedColumns++;
			}

			//check inactive columns
			if(!VarBool(pRow->GetValue(cdelcInactive))) {
				bOK = TRUE;
			}
			pRow = pRow->GetNextRow();
		}

		//TES 8/30/2010 - PLID 38255 - Specify whether this is a row or a column.
		CString strRowCol = IsDlgButtonChecked(IDC_TABLE_ROWS_AS_FIELDS)?"row":"column";
		if(!bOK) {
			AfxMessageBox("A table must have at least one active " + strRowCol + ".");
			return FALSE;
		}

		if(nCountGroupedColumns == 1) {
			CString strWarn;
			//TES 8/30/2010 - PLID 38255 - Specify whether this is a row or a column.
			strWarn.Format("You only have one " + strRowCol + " marked as 'Grouped'.\n"
				"You must have at least two " + strRowCol + "s with this setting in order for the grouping feature to go into effect.\n"
				"Are you sure you wish to save this table?");
			
			if(IDNO == MessageBox(strWarn,"Practice",MB_ICONEXCLAMATION|MB_YESNO)) {
				return FALSE;
			}
		}
	}

	// (c.haag 2006-03-20 09:25) - PLID 19557 - Only check if this is currently a table, and not
	// some list or text box item that used to be a table.
	if(IsDlgButtonChecked(IDC_RADIO_TABLE))
	{
		CString strBad;
		CString strRowCol = IsDlgButtonChecked(IDC_TABLE_ROWS_AS_FIELDS)?"row":"column";
		CString strRowColCap = IsDlgButtonChecked(IDC_TABLE_ROWS_AS_FIELDS)?"Row":"Column";

		//warn if there is nothing in the list
		for (int i=0; i<m_aryCurColumnDataElements.GetSize(); i++)
		{
			CEmrInfoDataElement *peide = m_aryCurColumnDataElements.GetAt(i);
			if(peide->m_nListType == LIST_TYPE_DROPDOWN)
			{
				if(peide->m_arypEMRDropDownList.empty()) {
					strBad += peide->m_strData;
					strBad += "\n";
				}
				else {
				
					//if there are no active columns
					BOOL bActive = FALSE;
					// (a.walling 2014-06-30 10:21) - PLID 62497
					for (const auto& pDDI : peide->m_arypEMRDropDownList) {
						if (!pDDI->bInactive) {
							bActive = TRUE;
							break;
						}
					}

					if(!bActive) {
						strBad += peide->m_strData;
						strBad += "\n";
					}
				}
			}

			if(peide->m_eAutofillType != etatNone)
			{
				// (z.manning 2011-03-22 10:14) - PLID 23662 - While we're here, make sure that we don't have any grouped
				// columns set to autofill as that is not valid.
				if(peide->m_bIsGrouped) {
					MessageBox(FormatString("%s '%s' is set to auto-fill and is also a grouped column, which is not allowed. "
						"Please fix this before continuing.", strRowColCap, peide->m_strData));
					return FALSE;
				}

				// (z.manning 2011-03-22 11:25) - PLID 23662 - Warn if autofill AND formula
				if(peide->IsCalculated()) {
					int nResult = MessageBox(FormatString("%s '%s' is set to auto-fill but also has a formula. The auto-fill will not work. "
						"Are you sure you want to continue?", strRowColCap, peide->m_strData), NULL, MB_YESNO|MB_ICONQUESTION);
					if(nResult != IDYES) {
						return FALSE;
					}
				}

				// (z.manning 2011-03-22 11:25) - PLID 23662 - Warn if autofill AND input mask
				if(!peide->m_strInputMask.IsEmpty()) {
					int nResult = MessageBox(FormatString("%s '%s' is set to auto-fill but also has an input mask. The auto-fill will not work. "
						"Are you sure you want to continue?", strRowColCap, peide->m_strData), NULL, MB_YESNO|MB_ICONQUESTION);
					if(nResult != IDYES) {
						return FALSE;
					}
				}
			}
		}

		if(!strBad.IsEmpty()) {
			CString strWarn;
			//TES 8/30/2010 - PLID 38255 - Specify whether this is a row or a column.
			strWarn.Format("The following 'Dropdown' " + strRowCol + "s currently have empty (or entirely inactive) dropdown lists:\n\n"
				"%s\n"
				"If you try to use this table on an EMR, you will be unable to enter any data in these " + strRowCol + "s.\n"
				"Are you sure you wish to save this table?",strBad);
			
			if(IDNO == MessageBox(strWarn,"Practice",MB_ICONEXCLAMATION|MB_YESNO)) {
				return FALSE;
			}
		}
	}

	if(IsDlgButtonChecked(IDC_RADIO_SLIDER)) {

		// (j.jones 2006-08-01 11:48) - PLID 20880 - make sure you cannot save a slider (new or existing)
		// with a minimum value less than its maximum value
		// (ie. 100 to 1 is bad, -1 to -15 is bad, 1 to 100 is good, -15 to -1 is good)
		CString strSliderMin;
		GetDlgItemText(IDC_EMR_MINIMUM, strSliderMin);
		strSliderMin = FormatString("%0.04f", atof(strSliderMin));
		CString strSliderMax;
		GetDlgItemText(IDC_EMR_MAXIMUM, strSliderMax);
		strSliderMax = FormatString("%0.04f", atof(strSliderMax));
		if(atof(strSliderMin) >= atof(strSliderMax)) {
			//set the text with the new values incase they were rounded up
			SetDlgItemText(IDC_EMR_MINIMUM, AsStringCleanDouble(atof(strSliderMin)));
			SetDlgItemText(IDC_EMR_MAXIMUM, AsStringCleanDouble(atof(strSliderMax)));
			AfxMessageBox("The minimum slider value must be less than the maximum slider value.");
			return FALSE;
		}

		//PLID 21947 - also make sure that increment is not greater than the difference of the max - min
		CString strSliderIncrement;
		GetDlgItemText(IDC_EMR_INCREMENT, strSliderIncrement);
		strSliderIncrement = FormatString("%0.04f", atof(strSliderIncrement));
		if (atof(strSliderIncrement) > (atof(strSliderMax) - atof(strSliderMin))) {
			AfxMessageBox("The increment value cannot be greater than the difference of the maximum and minimum slider values.");
			return FALSE;
		}

		// (a.walling 2007-03-01 11:01) - PLID 22270 - Also warn if the range is not evenly divisible by the increment.
		double dIncrement = atof(strSliderIncrement);
		double dMaximum = atof(strSliderMax);
		double dMinimum = atof(strSliderMin);

		double dOffset = dMaximum - dMinimum; // translate the range to [0, max]
		double dDivisible = dOffset / dIncrement;

		double dFracPart, dIntPart;
		dFracPart = modf(dDivisible, &dIntPart);

		if (dFracPart != 0) {
			// the numbers are not evenly divisible
			double dNear = dIncrement * (dIntPart);
			dNear += dMinimum;
			CString str;
			str.Format("The range [%g, %g] is not evenly divisible by %g. This means the highest possible value is %g. "
				"Would you like to continue saving?",
				dMinimum, dMaximum, dIncrement, dNear);
			if (IDNO == MessageBox(str, "Practice", MB_YESNO | MB_ICONINFORMATION))
				return FALSE;
			// this isn't really invalid, just a warning, but allow the user to cancel the save if they desire.
		}
			
	}

	if(IsDlgButtonChecked(IDC_RADIO_IMAGE) && IsDlgButtonChecked(IDC_ENABLE_SMART_STAMPS)) {
		// (z.manning 2010-02-09 16:53) - PLID 37228
		if(m_pdlSmartStampTable->GetCurSel() == NULL) {
			MessageBox("You must select a smart stamp table.");
			return FALSE;
		}

		// (j.jones 2010-02-26 09:40) - PLID 37231 - disallow saving if we cannot change the table's
		// remembering value
		BOOL bCurrentEnableSmartStamps = (m_btnEnableSmartStamps.GetCheck() == BST_CHECKED);
		BOOL bRememberForPatient = (IsDlgButtonChecked(IDC_REMEMBER_FOR_PATIENT) && eistCurrentMedicationsTable != m_DataSubType && eistAllergiesTable != m_DataSubType) ? TRUE : FALSE;
		BOOL bRememberForEMR = (IsDlgButtonChecked(IDC_REMEMBER_FOR_EMR) && eistCurrentMedicationsTable != m_DataSubType && eistAllergiesTable != m_DataSubType) ? TRUE : FALSE;
		_variant_t varCurrentSmartStampTableMasterID = g_cvarNull;
		if(m_pdlSmartStampTable->GetCurSel() != NULL) {
			varCurrentSmartStampTableMasterID = m_pdlSmartStampTable->GetCurSel()->GetValue(sstcMasterID);
		}

		if((bCurrentEnableSmartStamps && varCurrentSmartStampTableMasterID.vt != VT_NULL &&
			(!m_bEnableSmartStamps || varCurrentSmartStampTableMasterID != m_varSmartStampTableMasterID))
			|| (bCurrentEnableSmartStamps && bRememberForPatient != m_bRememberForPatient)
			|| (bCurrentEnableSmartStamps && bRememberForEMR != m_bRememberForEMR))
		{
			
			long nSmartStampTableMasterID = VarLong(varCurrentSmartStampTableMasterID, -1);
			if(bCurrentEnableSmartStamps && nSmartStampTableMasterID != -1) {
				//Find out if this table has a different remember setting than what our image has,
				//and if it is linked to another image as well. If it's not linked to another image,
				//we'll be able to change the setting, but otherwise we can't. Warn about this.
				CString strImage, strTable;
				if(!CompareSmartStampRememberSettings(nSmartStampTableMasterID, strImage, strTable)) {
					CString strWarn;
					strWarn.Format("%s %s\n\n"
						"Because this table is also linked to another Image, the setting cannot be changed on the table.\n"
						"The link to this table cannot be saved unless you change the 'remember this item's value' settings for this Image.", strImage, strTable);
					AfxMessageBox(strWarn);
					return FALSE;
				}
			}
		}
	}

	// (c.haag 2005-08-23 15:36) - PLID 16328 - If this item can only appear once
	// in an EMN, we need to check that there are no existing EMN's or EMN templates
	// that already have two of them
	//
	if (-1 != m_nID && IsDlgButtonChecked(IDC_CHECK_ONE_PER_EMN))
	{
		//
		// Check for EMN's that have two or more of this item
		//
		_RecordsetPtr prsEMN = CreateRecordset("SELECT [Last] + ', ' + [First] + ' ' + [Middle] AS PersonName FROM (SELECT EMRID FROM EMRDetailsT WHERE Deleted = 0 AND EMRDetailsT.EMRInfoID = %d GROUP BY EMRID, EmrInfoID HAVING COUNT(EMRInfoID) > 1) SubQ "
			"LEFT JOIN EMRMasterT ON EMRMasterT.ID = SubQ.EMRID "
			"LEFT JOIN EMRGroupsT ON EMRGroupsT.ID = EMRMasterT.EMRGroupID "
			"LEFT JOIN PersonT ON PersonT.ID = EMRGroupsT.PatientID "
			"WHERE EMRMasterT.Deleted = 0 AND EMRGroupsT.Deleted = 0 "
			"GROUP BY [Last] + ', ' + [First] + ' ' + [Middle]", m_nID);
		FieldsPtr fEMN = prsEMN->Fields;
		CString strNames;
		while (!prsEMN->eof) {
			strNames += AdoFldString(fEMN, "PersonName") + "\n";
			prsEMN->MoveNext();
		}
		if (strNames.GetLength()) {
			if (IDNO == MsgBox(MB_YESNO, CString("The following patients have EMN's that contain this item more than once:\n\n") +
				strNames + "\nDo you wish to enforce the One-Per-EMN rule anyway? No patient data will be changed as a result of your selection.")) {
				return FALSE;
			}
		}
		prsEMN->Close();
		strNames.Empty();

		//
		// Check for MINT's that have two or more of this item
		//

		// (c.haag 2005-10-10 13:09) - PLID 16328 - Now deleted templates are ignored

		_RecordsetPtr prsMINT = CreateRecordset("SELECT TemplateID, Name FROM (SELECT TemplateID FROM EMRTemplateDetailsT INNER JOIN EmrInfoMasterT ON EmrTemplateDetailsT.EmrInfoMasterID = EmrInfoMasterT.ID WHERE EmrInfoMasterT.ActiveEMRInfoID = %d GROUP BY TemplateID, ActiveEmrInfoID HAVING COUNT(ActiveEMRInfoID) > 1) SubQ "
			"LEFT JOIN EMRTemplateT ON EMRTemplateT.ID = SubQ.TemplateID "
			"WHERE EMRTemplateT.Deleted = 0 "
			"GROUP BY TemplateID, Name ", m_nID);
		FieldsPtr fMINT = prsMINT->Fields;
		while (!prsMINT->eof) {
			strNames += AdoFldString(fMINT, "Name") + "\n";
			prsMINT->MoveNext();
		}
		if (strNames.GetLength()) {
			if (IDNO == MsgBox(MB_YESNO, CString("The following EMN templates contain this item more than once:\n\n") +
				strNames + "\nDo you wish to enforce the One-Per-EMN rule anyway? No EMN templates will be changed as a result of your selection.")) {
				return FALSE;
			}
		}

		//
		// Check if saving the item like this would cause problems with existing
		// template configurations.
		//
		CStringArray astrOffendingMints;
		// (j.jones 2008-12-22 12:23) - PLID 32548 - this should not have disabled saving, it should just warn them like it does
		// in the above warning, and allow them to continue, otherwise they can never change this item again while maintaining
		// the OnePerEMN rule
		if (EmbeddedSpawnsViolateOnePerEmnRule(m_nID, astrOffendingMints)) {
			CString str = "The following templates can potentially violate the One Per EMN rule due to the embedded spawning of other EMN's:\n\n";
			for (long i=0; i < astrOffendingMints.GetSize(); i++) {
				str += astrOffendingMints[i] + "\n";
			}
			str += "\nDo you wish to enforce the One-Per-EMN rule anyway? No EMN templates will be changed as a result of your selection.";
			//used a MsgBox to visually match the same prompts as above
			if (IDNO == MsgBox(MB_YESNO, str)) {
				return FALSE;
			}
		}
	}

	// (j.jones 2007-08-15 08:50) - PLID 27052 - if E/M Coding is enabled, a category must be selected
	if(IsDlgButtonChecked(IDC_CHECK_USE_FOR_EM_CODING) && m_pdlEMCategoryCombo->CurSel == NULL) {
		AfxMessageBox("E/M Coding is enabled for this item, but no E/M Category is selected.\n"
			"An E/M Category is required on all EMR items that are configured to use E/M Coding.");
		return FALSE;
	}

	// (j.jones 2007-08-15 08:50) - PLID 27053 - if E/M Coding is enabled, and the data type is list or table,
	// a coding method must be selected
		
	if(IsDlgButtonChecked(IDC_CHECK_USE_FOR_EM_CODING)
		&& (IsDlgButtonChecked(IDC_RADIO_LIST_MULTISELECT) || IsDlgButtonChecked(IDC_RADIO_TABLE))
		&& m_pdlEMCodeTypeCombo->CurSel == NULL) {

		AfxMessageBox("E/M Coding is enabled for this item, but no E/M Coding Type is selected.\n"
			"An E/M Code Type is required on all multi-select lists and tables that are configured to use E/M Coding.");
		return FALSE;
	}

	// (j.jones 2007-08-15 13:07) - PLID 27053 - if E/M Coding is enabled, and the data type is a table,
	// and the coding method needs a row specified, then stop them from saving without the E/M column
	// checked for at least one row
	if(NeedTableRowEMColumn()) {

		// (c.haag 2008-10-27 17:45) - PLID 31708 - Change the language based on table flipping state
		CString strType = IsDlgButtonChecked(IDC_TABLE_ROWS_AS_FIELDS) ? "column" : "row";

		BOOL bOK = FALSE;
		//TES 3/14/2011 - PLID 42784 - Converted to datalist2
		NXDATALIST2Lib::IRowSettingsPtr pRow = m_pdlDataElementList->GetFirstRow();
		while(pRow && !bOK) {
			if(VarBool(pRow->GetValue(delcUseEMCoding))) {
				bOK = TRUE;
			}
			pRow = pRow->GetNextRow();
		}

		if(!bOK) {
			AfxMessageBox("Your E/M Category selection for this item indicates that at least one table " + strType + " must have an E/M Category selected.\n"
				"You may not save this item using the selected E/M Category rule until at least one table " + strType + " has an E/M Category selected.");
			return FALSE;
		}
	}

	// (j.jones 2007-08-15 13:07) - PLID 27053 - if E/M Coding is enabled, and the data type is a table,
	// and the coding method needs a column specified, then stop them from saving without the E/M column
	// checked for at least one column
	if(NeedTableColumnEMColumn()) {

		// (c.haag 2008-10-27 17:45) - PLID 31708 - Change the language based on table flipping state
		CString strType = IsDlgButtonChecked(IDC_TABLE_ROWS_AS_FIELDS) ? "row" : "column";

		BOOL bOK = FALSE;
		//TES 3/14/2011 - PLID 42784 - Converted to datalist2
		NXDATALIST2Lib::IRowSettingsPtr pRow = m_pdlColumnDataElementList->GetFirstRow();
		while(pRow && !bOK) {
			if(VarBool(pRow->GetValue(cdelcUseEMCoding))) {
				bOK = TRUE;
			}
			pRow = pRow->GetNextRow();
		}

		if(!bOK) {
			AfxMessageBox("Your E/M Category selection for this item indicates that at least one table " + strType + " must have an E/M Category selected.\n"
				"You may not save this item using the selected E/M Category rule until at least one table " + strType + " has an E/M Category selected.");
			return FALSE;
		}
	}

	// (j.jones 2011-03-08 12:25) - PLID 42282 - validate if E/M categories need to be selected per row or column
	if(NeedTableRowEMCodeCategoryColumn()) {

		CString strType = IsDlgButtonChecked(IDC_TABLE_ROWS_AS_FIELDS) ? "column" : "row";

		BOOL bOK = FALSE;
		//TES 3/14/2011 - PLID 42784 - Converted to datalist2
		NXDATALIST2Lib::IRowSettingsPtr pRow = m_pdlDataElementList->GetFirstRow();
		while(pRow && !bOK) {
			if(VarLong(pRow->GetValue(delcEMCodeCategoryID), -1) != -1) {
				bOK = TRUE;
			}
			pRow = pRow->GetNextRow();
		}

		if(!bOK) {
			AfxMessageBox("Your E/M Code Type indicates that at least one table " + strType + " must be specified for E/M calculations.\n"
				"You may not save this item using the selected E/M Code Type until at least one table " + strType + " has the E/M field checked.");
			return FALSE;
		}
	}

	if(NeedTableColumnEMCodeCategoryColumn()) {

		CString strType = IsDlgButtonChecked(IDC_TABLE_ROWS_AS_FIELDS) ? "row" : "column";

		BOOL bOK = FALSE;
		//TES 3/14/2011 - PLID 42784 - Converted to datalist2
		NXDATALIST2Lib::IRowSettingsPtr pRow = m_pdlColumnDataElementList->GetFirstRow();
		while(pRow && !bOK) {
			if(VarLong(pRow->GetValue(cdelcEMCodeCategoryID), -1) != -1) {
				bOK = TRUE;
			}
			pRow = pRow->GetNextRow();
		}

		if(!bOK) {
			AfxMessageBox("Your E/M Code Type indicates that at least one table " + strType + " must be specified for E/M calculations.\n"
				"You may not save this item using the selected E/M Code Type until at least one table " + strType + " has the E/M field checked.");
			return FALSE;
		}
	}

	// (a.walling 2009-05-28 16:25) - PLID 34389
	{
		CString strDataUnit;
		m_nxeditDataUnit.GetWindowText(strDataUnit);

		if (strDataUnit.FindOneOf(" \t") != -1) {
			AfxMessageBox("The data unit cannot contain any whitespace characters. Please see http://unitsofmeasure.org for more information on valid UCUM codes.");
			return FALSE;
		}
	}

	//TES 12/22/2004 - We now properly handle these "bad" characters in the GenerateXML function.
	//verify the contents are safe
	/*strBad = "";

	for(i=0;i<m_pdlDataElementList->GetRowCount();i++) {
		CString strData = VarString(m_pdlDataElementList->GetValue(i,delcData),"");
		if(strData.Find("<") != -1 || strData.Find(">") != -1 || strData.Find("\"") != -1) {
			if(IsDlgButtonChecked(IDC_RADIO_TABLE))
				strData = "List Item: " + strData;
			else
				strData = "Row: " + strData;
			strBad += strData;
			strBad += "\n";
		}
	}

	for(i=0;i<m_pdlColumnDataElementList->GetRowCount();i++) {
		CString strData = VarString(m_pdlColumnDataElementList->GetValue(i,cdelcData),"");
		if(strData.Find("<") != -1 || strData.Find(">") != -1 || strData.Find("\"") != -1) {
			strData = "Column: " + strData;
			strBad += strData;
			strBad += "\n";
		}
	}

	if(!strBad.IsEmpty()) {
		strBad = "The following items have invalid names:\n\n" + strBad;
		strBad += "\nItems cannot have the characters '>', '<', or '\"'";

		AfxMessageBox(strBad);
		return FALSE;
	}*/

	// (b.cardillo 2009-07-13 10:38) - PLID 34844 - For an EMR Item whose master is in use by a wellness 
	// template, we cannot allow the user to:
	//   - change the data type of the item (unless the criterion is an existential operator)
	//   - remove a referenced data element
	if (m_nID != -1) {
		// If the data type is changing, check if this EMR Item is in use by a wellness criterion
		if (CalcDataTypeByCurSelection() != m_nDataType) {
			_RecordsetPtr prs = GetWellnessTemplatesThatReferenceEMRInfoMasterItem(GetRemoteData(), m_nEmrInfoMasterID, TRUE);
			CString strWellTemplateList = GenerateDelimitedListFromRecordsetColumn(prs, "Name", " - ", "\r\n");
			if (!strWellTemplateList.IsEmpty()) {
				// There are some, so warn the user and fail
				CString strMsg;
				strMsg.Format(
					"You may not change the type of this EMR Item because it is in use in the criteria of the "
					"following Wellness Templates: "
					"\r\n\r\n%s\r\n\r\n"
					"Please remove this Item from all Wellness Criteria before attempting to change its type."
					,
					strWellTemplateList);
				AfxMessageBox(strMsg, MB_ICONEXCLAMATION|MB_OK);
				return FALSE;
			}
		}

		// If there are data elements being deleted, check if any of them are in use by a wellness criterion
		if ((m_nDataType == 2 || m_nDataType == 3) && !m_aryCurDeletedDataElements.IsEmpty()) {
			CDWordArray arydwDataIDs;
			for (int i=0, nCount=m_aryCurDeletedDataElements.GetSize(); i<nCount; i++) {
				arydwDataIDs.Add(m_aryCurDeletedDataElements.GetAt(i)->m_nID);
			}
			_RecordsetPtr prs = GetWellnessTemplatesThatReferenceEMRInfoDataElements(GetRemoteData(), m_nEmrInfoMasterID, arydwDataIDs);
			CString strReferences = GenerateDelimitedListFromRecordsetColumn(prs, "Name", " - ", "\r\n");
			if (!strReferences.IsEmpty()) {
				// There are some, so warn the user and fail
				CString strMsg;
				strMsg.Format(
					"You may not delete the specified list elements from this EMR Item because they are in use in the criteria of the following Wellness Template(s): \r\n"
					"\r\n%s\r\n\r\n"
					"Please remove these list elements from all Wellness Criteria before attempting to delete them."
					,
					strReferences);
				AfxMessageBox(strMsg, MB_ICONEXCLAMATION|MB_OK);
				return FALSE;
			}
		}
	}

	//TES 3/16/2011 - PLID 42757 - Add validation to make sure that there aren't any obvious problems with this item if it's tied to
	// Glasses Orders.  That will only be the case on lists or tables.
	if(g_pLicense->CheckForLicense(CLicense::lcGlassesOrders, CLicense::cflrSilent)) {
		if(IsDlgButtonChecked(IDC_RADIO_LIST_SELECT) || IsDlgButtonChecked(IDC_RADIO_LIST_MULTISELECT)) {
			if(IsDlgButtonChecked(IDC_ASSOCIATE_WITH_GLASSES_ORDER)) {
				//TES 3/16/2011 - PLID 42757 - For lists, make sure that:
				// 1.) A lens is selected, 
				// 2.) At least one item is associated with a Glasses Order type,
				// 3.) All items that have a Glasses Order type also have a Glasses Order record

				// 1.) A lens is selected
				NXDATALIST2Lib::IRowSettingsPtr pLensRow = m_pdlGlassesOrderLens->CurSel;
				if(pLensRow == NULL) {
					// (j.dinatale 2012-06-11 13:10) - PLID 50909 - optical order instead of glasses order for column names
					MsgBox(MB_ICONEXCLAMATION|MB_OK, "You have chosen to associate this item with Optical Order data, but you have not selected "
						"a Lens to fill with the data from this item.  Please choose either OD or OS.");
					return FALSE;
				}

				// 2.) At least one item is associated with a Glasses Order type
				// 3.) All items that have a Glasses Order type also have a Glasses Order record
				bool bTypeFound = false, bTypeWithoutRecordFound = false;
				NXDATALIST2Lib::IRowSettingsPtr pDataRow = m_pdlDataElementList->GetFirstRow();
				while(pDataRow) {
					if(((GlassesOrderDataType)VarLong(pDataRow->GetValue(delcGlassesOrderDataType),-1)) != godtInvalid) {
						bTypeFound = true;
						if(VarLong(pDataRow->GetValue(delcGlassesOrderDataID),-1) == -1) {
							bTypeWithoutRecordFound = true;
						}
					}
					pDataRow = pDataRow->GetNextRow();
				}
				if(!bTypeFound) {
					// (j.dinatale 2012-06-11 13:10) - PLID 50909 - optical order instead of glasses order for column names
					MsgBox(MB_ICONEXCLAMATION|MB_OK, "You have chosen to associate this item with Optical Order data, but you have not "
						"associated any of the items in the list with a field on the Optical Order.  Please fill in the Optical Order Field "
						"and Optical Order Record columns for at least one item in the list.");
					return FALSE;
				}
				if(bTypeWithoutRecordFound) {
					// (j.dinatale 2012-06-11 13:10) - PLID 50909 - optical order instead of glasses order for column names
					MsgBox(MB_ICONEXCLAMATION|MB_OK, "At least one item in the list has been associated with an Optical Order field, "
						"but not with a record to fill in that field on the Optical Order.  Please ensure that all items with an item selected "
						"in the Optical Order Field column also have a record selected in the Optical Order Record column.");
					return FALSE;
				}
			}
		}
		else if(IsDlgButtonChecked(IDC_RADIO_TABLE)) {
			//TES 4/6/2012 - PLID 49367 - Changed the checkbox IDC on tables
			if(IsDlgButtonChecked(IDC_ASSOCIATE_WITH_GLASSES_ORDER_OR_CL)) {
				//TES 3/16/2011 - PLID 42757 - For tables, make sure that:
				// 1.) At least one row has a lens selected
				// 2.) Any rows that have Lens selected have chosen a lens
				// 3.) The same lens is not selected for multiple rows
				// 4.) At least one column has a Glasses Order data type selected
				// 5.) That all columns with RxNumber selected have a Glasses Order record
				// 6.) That no two items with RxNumber selected have the same Glasses Order records
				// 7.) That all dropdown items with a Glasses Order data type other than RxNumber selected have at least 
				// one dropdown item with a Glasses Order record selected.
				// 8.) That no more than one dropdown item has Design selected
				// 9.) That no more than one dropdown item has Material selected

				// 1.) At least one row has a lens selected
				bool bLensFound = false; 
				// 2.) Any rows that have Lens selected have chosen a lens
				bool bTypeWithoutRecordFound = false;
				// 3.) The same lens is not selected for multiple rows
				bool bOneODFound = false, bOneOSFound = false, bTwoODsFound = false, bTwoOSsFound = false;
				NXDATALIST2Lib::IRowSettingsPtr pRow = m_pdlDataElementList->GetFirstRow();
				while(pRow) {
					if(((GlassesOrderDataType)VarLong(pRow->GetValue(delcGlassesOrderDataType),(long)godtInvalid)) == godtLens) {
						bLensFound = true;
						GlassesOrderLens gol = (GlassesOrderLens)VarLong(pRow->GetValue(delcGlassesOrderDataID),(long)golInvalid);
						switch(gol) {
							case golInvalid:
								bTypeWithoutRecordFound = true;
								break;
							case golOD:
								if(bOneODFound) bTwoODsFound = true;
								bOneODFound = true;
								break;
							case golOS:
								if(bOneOSFound) bTwoOSsFound = true;
								bOneOSFound = true;
								break;
						}
					}
					pRow = pRow->GetNextRow();
				}

				CString strRow = IsDlgButtonChecked(IDC_TABLE_ROWS_AS_FIELDS)?"column":"row";
				CString strCol = IsDlgButtonChecked(IDC_TABLE_ROWS_AS_FIELDS)?"row":"column";

				// 1.) At least one row has a lens selected
				if(!bLensFound) {
					// (j.dinatale 2012-06-11 13:10) - PLID 50909 - optical order instead of glasses order for column names
					MsgBox(MB_OK|MB_ICONEXCLAMATION, "You have chosen to associate this item with Optical Order data, but you have not chosen to "
						"associate any of the %ss on the list with a Lens.  Please fill in the Optical Order Field and Optical Order Record "
						"columns for at least one %s in this list.", strRow, strRow);
					return FALSE;
				}
				// (j.dinatale 2012-06-11 13:10) - PLID 50909 - optical order instead of glasses order for column names
				// 2.) Any rows that have Lens selected have chosen a lens
				if(bTypeWithoutRecordFound) {
					MsgBox(MB_OK|MB_ICONEXCLAMATION, "You have chosen to associate at least one %s in the list with a Lens, but have not "
						"chosen which Lens to associate it with.  Please select either OD or OS in the Optical Order Record column for every %s "
						"where you have filled in the Optical Order Field column.", strRow, strRow);
					return FALSE;
				}
				// (j.dinatale 2012-06-11 13:10) - PLID 50909 - optical order instead of glasses order for column names
				// 3.) The same lens is not selected for multiple rows
				if(bTwoODsFound || bTwoOSsFound) {
					MsgBox(MB_OK|MB_ICONEXCLAMATION, "You have associated more than one %s with the same Lens on the Optical Order.  Please make "
						"sure that OD and OS are each selected no more than once in your list of %ss.", strRow, strRow);
					return FALSE;
				}

				// 4.) At least one column has a Glasses Order data type selected
				bool bColumnDataTypeFound = false;
				// 5.) That all columns with RxNumber selected have a Glasses Order record
				bool bRxNumberWithoutRecordFound = false;
				// 6.) That no two items with RxNumber selected have the same Glasses Order records
				CMap<GlassesOrderRxNumber,GlassesOrderRxNumber,bool,bool> mapRxNumsFound;
				GlassesOrderRxNumber gornDuplicateFound = gornInvalid;
				// 7.) That all dropdown items with a Glasses Order data type other than RxNumber selected have at least 
				// one dropdown item with a Glasses Order record selected.
				bool bColumnDropdownWithoutRecordFound = false;
				// 8.) That no more than one dropdown item has Design selected
				bool bOneDesignFound = false, bTwoDesignsFound = false;
				// 9.) That no more than one dropdown item has Material selected
				bool bOneMaterialFound = false, bTwoMaterialsFound = false;

				pRow = m_pdlColumnDataElementList->GetFirstRow();
				while(pRow) {
					GlassesOrderDataType godt = ((GlassesOrderDataType)VarLong(pRow->GetValue(cdelcGlassesOrderDataType),(long)godtInvalid));
					if(godt != godtInvalid) {
						bColumnDataTypeFound = true;
						if(godt == godtRxNumber) {
							GlassesOrderRxNumber gorn = (GlassesOrderRxNumber)VarLong(pRow->GetValue(cdelcGlassesOrderDataID),(long)gornInvalid);
							//TES 4/23/2012 - PLID 49367 - Make sure it's a valid RxNumber depending on whether we're showing GO or CL data.
							if(gorn == gornInvalid || !IsRxNumberSupported(gorn, m_bHasContactLensData)) {
								bRxNumberWithoutRecordFound = true;
							}
							else {
								bool bTmp = false;
								if(mapRxNumsFound.Lookup(gorn, bTmp)){
									gornDuplicateFound = gorn;
								}
								else {
									mapRxNumsFound.SetAt(gorn, true);
								}
							}
						}
						else {
							bool bDropdownRecordFound = false;
							CEmrInfoDataElement *peideColumn = GetCurDataElementBySortOrder(VarLong(pRow->GetValue(cdelcSortOrder)), TRUE);
							// (a.walling 2014-06-30 10:21) - PLID 62497
							for(const auto& pDDI : peideColumn->m_arypEMRDropDownList) {
								if(pDDI->nGlassesOrderDataID != -1) {
									bDropdownRecordFound = true;
									break;
								}
							}
							if(!bDropdownRecordFound) {
								bColumnDropdownWithoutRecordFound = true;
							}
							if(godt == godtDesign) {
								if(bOneDesignFound) bTwoDesignsFound = true;
								bOneDesignFound = true;
							}
							else if(godt == godtMaterial) {
								if(bOneMaterialFound) bTwoMaterialsFound = true;
								bOneMaterialFound = true;
							}
						}
					}
					pRow = pRow->GetNextRow();
				}

				// 4.) At least one column has a Glasses Order data type selected
				if(!bColumnDataTypeFound) {
					// (j.dinatale 2012-06-11 13:10) - PLID 50909 - optical order instead of glasses order for column names
					MsgBox(MB_OK|MB_ICONEXCLAMATION, "You have chosen to associate this item with Optical Order data, but you have not chosen "
						"to associate any of the %ss in the list with a field on the Optical Order.  Please fill in the Optical Order Field "
						"and Optical Order Record columns for at least one %s.\r\n"
						"\r\n"
						"NOTE: Only %ss with the type Text or Dropdown can be associated with Optical Order data.", strCol, strCol, strCol);
					return FALSE;
				}

				// 5.) That all columns with RxNumber selected have a Glasses Order record
				if(bRxNumberWithoutRecordFound) {
					// (j.dinatale 2012-06-11 13:10) - PLID 50909 - optical order instead of glasses order for column names
					MsgBox(MB_OK|MB_ICONEXCLAMATION, "You have chosen to associate at least one %s in the list with an Rx Field, but have "
						"not chosen which field to associate it with.  Please fill in the Optical Order Record column for each %s with "
						"Rx Field selected.", strCol, strCol);
					return FALSE;
				}

				// 6.) That no two items with RxNumber selected have the same Glasses Order records
				if(gornDuplicateFound != gornInvalid) {
					// (j.dinatale 2012-06-11 13:10) - PLID 50909 - optical order instead of glasses order for column names
					MsgBox(MB_OK|MB_ICONEXCLAMATION, "You have chosen to associate more than one %s with the %s field on the Optical Order.  "
						"Please make sure that no two %ss are associated with the same Rx Field.", 
						strCol, GetGlassesOrderRxNumberDescription(gornDuplicateFound), strCol);
					return FALSE;
				}
				// 7.) That all dropdown items with a Glasses Order data type other than RxNumber selected have at least 
				// one dropdown item with a Glasses Order record selected.
				if(bColumnDropdownWithoutRecordFound) {
					// (j.dinatale 2012-06-11 13:10) - PLID 50909 - optical order instead of glasses order for column names
					MsgBox(MB_OK|MB_ICONEXCLAMATION, "At least one Dropdown-type %s in the list has been associated with a Optical Order field, "
						"but none of the Dropdown Items have been associated with a Optical Order record.  Please edit the Dropdown Items for "
						"each Dropdown-type %s with a Optical Order field selected, and ensure that at least one item has a Optical Order record "
						"selected.", strCol, strCol);
					return FALSE;
				}
				// 8.) That no more than one dropdown item has Design selected
				if(bTwoDesignsFound) {
					MsgBox(MB_OK|MB_ICONEXCLAMATION, "You have associated more than one %s in the list with the Design field.  Please make sure "
						"that the Design field is associated with no more than one %s", strCol, strCol);
					return FALSE;
				}
				// 9.) That no more than one dropdown item has Material selected
				if(bTwoMaterialsFound) {
					MsgBox(MB_OK|MB_ICONEXCLAMATION, "You have associated more than one %s in the list with the Material field.  Please make sure "
						"that the Material field is associated with no more than one %s", strCol, strCol);
					return FALSE;
				}

			}

			// (r.gonet 08/03/2012) - PLID 51735 - If this is a wound care coding table, then validate it.
			//  We require 1, and only 1, of each wound care data type.
			if(m_nDataType == 7 && IsDlgButtonChecked(IDC_USE_WITH_WOUND_CARE_CALC)) {
				// Ensure that there is exactly 1 column per wound care data type (besides wcdtNone)
				CString strWoundCareValidationErrors = "";
				// (r.gonet 08/03/2012) - PLID 51735 - For each wound care data types
				for(long i = 1; i < (long)wcdtEndPlaceholder; i++) {
					long nFoundCount = 0;
					EWoundCareDataType ewcc = (EWoundCareDataType)i;
					NXDATALIST2Lib::IRowSettingsPtr pRowIter = m_pdlColumnDataElementList->FindAbsoluteFirstRow(VARIANT_FALSE);
					// (r.gonet 08/03/2012) - PLID 51735 - Go through every row that we have
					while(pRowIter != NULL) {
						EWoundCareDataType ewccCompare = (EWoundCareDataType)VarLong(pRowIter->GetValue(cdelcWoundCareDataType), (long)wcdtNone);
						// (r.gonet 08/03/2012) - PLID 51735 - And add up the count of columns that have this type
						if(ewcc == ewccCompare) {
							nFoundCount++;
						}
						pRowIter = m_pdlColumnDataElementList->FindAbsoluteNextRow(pRowIter, VARIANT_FALSE);
					}

					if(nFoundCount == 0) {
						// (r.gonet 08/03/2012) - PLID 51735 - If we've found none of the type, then that's an error since we require it.
						if(!strWoundCareValidationErrors.IsEmpty()) {
							strWoundCareValidationErrors += "\r\n";
						}
						strWoundCareValidationErrors += FormatString("'%s' must be assigned to a %s.", GetWoundCareDataTypeDescription(ewcc), !IsDlgButtonChecked(IDC_TABLE_ROWS_AS_FIELDS) ? "column" : "row");
					} else if(nFoundCount > 1) {
						// (r.gonet 08/03/2012) - PLID 51735 - If we've found more than one column having this type, then that's an error since we require at most 1 column to have a particular type.
						if(!strWoundCareValidationErrors.IsEmpty()) {
							strWoundCareValidationErrors += "\r\n";
						}
						strWoundCareValidationErrors += FormatString("'%s' cannot be assigned to multiple %s.", GetWoundCareDataTypeDescription(ewcc), !IsDlgButtonChecked(IDC_TABLE_ROWS_AS_FIELDS) ? "columns" : "rows");
					}
				}

				// (r.gonet 08/03/2012) - PLID 51735 - If there were validation errors, tell the user and abort saving.
				if(!strWoundCareValidationErrors.IsEmpty()) {
					strWoundCareValidationErrors = "The following Wound Care Coding related errors occured:\r\n\r\n" + strWoundCareValidationErrors;
					MsgBox(MB_OK|MB_ICONEXCLAMATION, strWoundCareValidationErrors);
					return FALSE;
				}
			}
		}
	}

	// (j.jones 2013-01-15 09:10) - PLID 54169 - if smartstamps is enabled for any non-image,
	// clear the SS links
	if(!IsDlgButtonChecked(IDC_RADIO_IMAGE)) {
		m_btnEnableSmartStamps.SetCheck(FALSE);
		m_pdlSmartStampTable->PutCurSel(NULL);
	}

	// TODO: Need to make sure nothing fundamental (like the data type) changes for an emr item that's in use on any EMNs

	return TRUE;
}

BOOL CEmrItemEntryDlg::AddStatementToSqlBatch_EmrTableDropDownChanges(IN OUT CString &strSqlBatch, const CString &strSourceID, const CEmrInfoDataElement &pOrigDataElement, const CEmrInfoDataElement &pDataElement, long &nAuditTransactionID)
{
	CString strName;
	GetDlgItemText(IDC_ITEM_NAME, strName);
	strName.TrimRight();
	strName.TrimLeft();

	// (a.walling 2007-11-05 16:08) - PLID 27980 - VS2008 - for() loops
	long i = 0;

	BOOL bAns = FALSE;
	BOOL bValidateEMRTableDropdownInfoSortOrder = FALSE; // (c.haag 2010-07-10 11:19) - PLID 39467

	//first generate statements for new items
	CString strAddXml, strActionXml, strDropdownStampSql;
	long nActionIDIncrement = 1;
	// (a.walling 2014-06-30 10:21) - PLID 62497
	for (const auto& pddi : pDataElement.m_arypEMRDropDownList)
	{
		if(pddi->nID == -1)
		{
			if(strAddXml.IsEmpty())
				strAddXml = "<ROOT>\r\n";
			g_nLastTableDropDownIndex++;
			// (z.manning 2009-02-12 10:22) - PLID 33029 - Table dropdown items can now have actions
			// so we need to pass an action ID incrementer in for the xml generation.
			strAddXml += pddi->GenerateXml(g_nLastTableDropDownIndex, nActionIDIncrement);

			//audit the addition
			CString strNewValue;
			strNewValue.Format("Added '%s' to Column '%s'", pddi->strData, pDataElement.m_strData);

			if(nAuditTransactionID == -1)
				nAuditTransactionID = BeginAuditTransaction();
			AuditEvent(-1, "", nAuditTransactionID, aeiEMRItemTableDropdownAdded, atoi(strSourceID), "Item: " + strName, strNewValue, aepMedium, aetCreated);
		}
	}

	if (!strAddXml.IsEmpty()) {
		strAddXml += "</ROOT>\r\n";
		bAns = TRUE;

		//TES 12/7/2006 - PLID 23766 - For new EmrTableDropdownInfoT records, initialize DropdownGroupID to an arbitrary number
		// that will tie future copies of this item together.
		// (a.walling 2007-08-29 11:27) - PLID 27223 - DropdownGroupID is not arbitrary anymore; it links to EmrTableDropdownGroupsT
		// (a.walling 2007-08-29 13:11) - PLID 27231 - Don't add one to the base id; we will already add 'TableArbVal' which starts at 1.
		if(strSqlBatch.Find("@nEMRTableDropdownInfoBase_EmrTableDropDownChanges") == -1)
			AddStatementToSqlBatch(strSqlBatch, "DECLARE @nEMRTableDropdownInfoBase_EmrTableDropDownChanges INT; "
				"SET @nEMRTableDropdownInfoBase_EmrTableDropDownChanges = (SELECT COALESCE(MAX(ID), 0) FROM EMRTableDropdownInfoT); ");
		
		// (a.walling 2007-08-29 11:27) - PLID 27223 - We need a new row in EmrTableDropdownGroupsT for each new DropdownGroupID
		// (a.walling 2007-08-29 13:11) - PLID 27231 - Don't add one to the base id; we will already add 'TableArbVal' which starts at 1.
		if(strSqlBatch.Find("@nDropdownGroupBase_EmrTableDropDownChanges") == -1)
			AddStatementToSqlBatch(strSqlBatch, "DECLARE @nDropdownGroupBase_EmrTableDropDownChanges INT; "
				"SET @nDropdownGroupBase_EmrTableDropDownChanges = (SELECT COALESCE(MAX(ID), 0) FROM EmrTableDropdownGroupsT); ");

		// (a.walling 2007-08-29 11:58) - PLID 27223 - Insert all the EmrTableDropdownGroupsT rows first
		AddStatementToSqlBatch(strSqlBatch, "EXEC sp_xml_preparedocument @hDoc OUTPUT, N'%s'; ", strAddXml);
		// (z.manning 2009-03-30 09:25) - PLID 33029 - Make sure we only declare this once.
		if(strSqlBatch.Find("@nEMRTableDropdownActionBase") == -1) {
			AddStatementToSqlBatch(strSqlBatch, "DECLARE @nEMRTableDropdownActionBase INT;\r\n ");
		}
		AddStatementToSqlBatch(strSqlBatch, 
			"SET @nEMRTableDropdownActionBase = IDENT_CURRENT('EmrActionsT');\r\n"
			"\r\n"
			"INSERT INTO EMRTableDropdownGroupsT (ID) "
				"SELECT @nDropdownGroupBase_EmrTableDropDownChanges + TableArbVal "
				"FROM OPENXML(@hDoc, '/ROOT/T', 1) WITH (TableArbVal INT); \r\n"
			//TES 3/15/2011 - PLID 42757 - Added GlassesOrderDataID
			// (j.gruber 2014-07-22 13:11) - PLID 62627 - Keyword fields
			"INSERT INTO EMRTableDropdownInfoT (ID, EMRDataID, Data, Inactive, SortOrder, GlassesOrderDataID, DropdownGroupID, UseKeyword, KeywordOverride) "
			" SELECT @nEMRTableDropdownInfoBase_EmrTableDropDownChanges + TableArbVal, %s, Data, Inactive, SortOrder, GlassesOrderDataID, "
			" @nDropdownGroupBase_EmrTableDropDownChanges + TableArbVal, UseKeyword, KeywordOverride "
			" FROM OPENXML(@hDoc, '/ROOT/T', 1) WITH (TableArbVal INT, Data NVARCHAR(2000), Inactive BIT, SortOrder INT, GlassesOrderDataID INT, "
			" DropdownGroupID INT, UseKeyword bit, KeywordOverride nvarchar(150)); \r\n"
			// (z.manning 2011-09-29 11:10) - PLID 45742 - Handle dropdown stamp filter
			"INSERT INTO EmrTableDropdownStampFilterT (EmrTableDropdownInfoID, StampID) \r\n"
			" SELECT @nEMRTableDropdownInfoBase_EmrTableDropDownChanges + TableArbVal, StampID \r\n"
			" FROM OPENXML(@hDoc, '/ROOT/T/SF', 1) WITH (TableArbVal INT '../@TableArbVal', StampID INT) \r\n"
			// (j.jones 2012-11-26 15:06) - PLID 53144 - added EMRTableDropdownStampDefaultsT
			"INSERT INTO EMRTableDropdownStampDefaultsT (EmrTableDropdownInfoID, StampID) \r\n"
			" SELECT @nEMRTableDropdownInfoBase_EmrTableDropDownChanges + TableArbVal, StampID \r\n"
			" FROM OPENXML(@hDoc, '/ROOT/T/SD', 1) WITH (TableArbVal INT '../@TableArbVal', StampID INT) \r\n"
			// (j.gruber 2013-09-30 12:26) - PLID 58675
			"INSERT INTO EmrTableDropdownGroupCodesT (EmrTableDropdownGroupID, CodeID) \r\n"			
			" SELECT @nDropdownGroupBase_EmrTableDropDownChanges + TableArbVal, CodeID \r\n"
			" FROM OPENXML(@hDoc, '/ROOT/T/CD', 1) WITH (TableArbVal INT '../@TableArbVal', CodeID INT) \r\n"
			// (z.manning 2009-02-11 17:53) - PLID 33029 - Need to handle EMR dropdown actions
			"INSERT INTO EmrActionsT (SourceType, SourceID, DestType, DestID, SortOrder, Popup, SpawnAsChild) \r\n"
			" SELECT %li, @nEMRTableDropdownInfoBase_EmrTableDropDownChanges + TableArbVal, DestType, DestID, SortOrder, Popup, SpawnAsChild \r\n"
			" FROM OPENXML(@hDoc, '/ROOT/T/A', 1) WITH (TableArbVal INT '../@TableArbVal', DestType INT, DestID INT, SortOrder INT, Popup BIT, SpawnAsChild BIT) \r\n"
			//DRT 1/17/2007 - PLID 24181 - Added insertion for Charge-specific actions.  This may be no records if there are no charge actions
			"INSERT INTO EmrActionChargeDataT (ActionID, Prompt, DefaultQuantity, Modifier1Number, Modifier2Number, Modifier3Number, Modifier4Number) \r\n"
			" SELECT @nEMRTableDropdownActionBase + ArbVal, Prompt, Quantity, Mod1, Mod2, Mod3, Mod4 \r\n"
			" FROM OPENXML(@hDoc, '/ROOT/T/A/C', 1) WITH (ArbVal INT '../@ArbVal', Prompt INT, Quantity FLOAT, Mod1 NVARCHAR(10), Mod2 NVARCHAR(10), Mod3 NVARCHAR(10), Mod4 NVARCHAR(10)) \r\n"
			// (c.haag 2008-06-20 10:53) - PLID 30221 - Also todos
			"INSERT INTO EmrActionsTodoDataT (ActionID, RemindType, RemindInterval, DeadlineType, DeadlineInterval, Notes, Priority, Task, CategoryID) \r\n"
			" SELECT @nEMRTableDropdownActionBase + ArbVal, RemindType, RemindInterval, DeadlineType, DeadlineInterval, Notes, Priority, Task, CategoryID \r\n"
			" FROM OPENXML(@hDoc, '/ROOT/T/A/Q', 1) WITH (ArbVal INT '../@ArbVal', RemindType INT, RemindInterval INT, DeadlineType INT, DeadlineInterval INT, Notes NVARCHAR(2000), Priority INT, Task NVARCHAR(50), CategoryID INT) \r\n"
			"INSERT INTO EmrActionsTodoAssignToT (ActionID, AssignTo) \r\n"
			" SELECT @nEMRTableDropdownActionBase + ArbVal, AssignTo \r\n"
			" FROM OPENXML(@hDoc, '/ROOT/T/A/R', 1) WITH (ArbVal INT '../@ArbVal', AssignTo INT) \r\n"
			// (b.savon 2014-07-21 16:45) - PLID 62707 - Handle saving the new Diagnosis DestType action to EmrActionsT and EmrActionsDiagnosisDataT
			"INSERT INTO EMRActionDiagnosisDataT (EmrActionID, DiagCodeID_ICD9, DiagCodeID_ICD10) "
			"	SELECT @nEMRTableDropdownActionBase + ArbVal, CASE WHEN DiagCodeID_ICD9 = -1 THEN NULL ELSE DiagCodeID_ICD9 END AS DiagCodeID_ICD9, CASE WHEN DiagCodeID_ICD10 = -1 THEN NULL ELSE DiagCodeID_ICD10 END AS DiagCodeID_ICD10 \r\n"
			"	FROM OPENXML(@hDoc, '/ROOT/T/A/DI', 1) WITH (ArbVal INT '../@ArbVal', DiagCodeID_ICD9 INT, DiagCodeID_ICD10 INT) "
			// (c.haag 2008-07-17 16:41) - PLID 30724 - Problem actions
			// (c.haag 2014-07-22) - PLID 62789 - Added SNOMEDCodeID
			// (s.tullis 2015-02-23 17:47) - PLID 64749 
			// (r.gonet 2015-03-10 14:48) - PLID 65013 - Added DoNotShowOnProblemPrompt.
			"INSERT INTO EmrProblemActionsT (EmrActionID, DefaultDescription, DefaultStatus, SpawnToSourceItem, SNOMEDCodeID, DoNotShowOnCCDA, DoNotShowOnProblemPrompt) \r\n"
			" SELECT @nEMRTableDropdownActionBase + ArbVal, DefaultDescription, DefaultStatus, SpawnToSourceItem, SNOMEDCodeID, DoNotShowOnCCDA, DoNotShowOnProblemPrompt \r\n"
			" FROM OPENXML(@hDoc, '/ROOT/T/A/P', 1) WITH (ArbVal INT '../@ArbVal', DefaultDescription nvarchar(2000), DefaultStatus INT, SpawnToSourceItem BIT, SNOMEDCodeID INT, DoNotShowOnCCDA BIT, DoNotShowOnProblemPrompt BIT) \r\n"
			"EXEC sp_xml_removedocument @hDoc;\r\n", strSourceID, eaoEmrTableDropDownItem);

		// (c.haag 2010-07-10 11:19) - PLID 39467 - Any time we potentially modify the sort order of EMRTableDropdownInfoT,
		// we have to do validation to ensure we did not create multiple values for a dropdown with the same sort order.
		bValidateEMRTableDropdownInfoSortOrder = TRUE;
	}

	//then generate statements to delete items
	// (a.walling 2014-06-30 10:21) - PLID 62497
	for(const auto& pddi : pDataElement.m_arypEMRDropDownDeleted)
	{
		if(pddi->nID != -1) {
			bAns = TRUE;
			CString str;

			// (z.manning 2011-09-28 12:07) - PLID 45729 - Delete stamp filter
			strSqlBatch += FormatString("DELETE FROM EmrTableDropdownStampFilterT WHERE EmrTableDropdownInfoID = %li \r\n", pddi->nID);
			// (j.jones 2012-11-27 09:45) - PLID 53144 - added EMRTableDropdownStampDefaultsT
			strSqlBatch += FormatString("DELETE FROM EMRTableDropdownStampDefaultsT WHERE EmrTableDropdownInfoID = %li \r\n", pddi->nID);
			// (j.gruber 2013-09-30 12:37) - PLID 58675 - delete codes
			strSqlBatch += FormatString("DELETE FROM EmrTableDropdownGroupCodesT WHERE EmrTableDropdownGroupID = %li \r\n", pddi->nDropDownGroupID);
			// (z.manning 2009-02-12 10:23) - PLID 33029 - Delete any actions that may have been associated
			// with this dropdown item.
			strSqlBatch += FormatString(
				"UPDATE EmrActionsT SET Deleted = 1 WHERE SourceType = %li AND SourceID = %li\r\n"
				, eaoEmrTableDropDownItem, pddi->nID);
			str.Format("UPDATE EMRTableDropdownInfoT SET CopiedFromDropdownID = NULL WHERE CopiedFromDropdownID = %li\r\n", pddi->nID);
			strSqlBatch += str;
			str.Format("DELETE FROM EMRTableDropdownInfoT WHERE ID = %li\r\n", pddi->nID);
			strSqlBatch += str;
			// (z.manning 2011-04-06 11:02) - PLID 42337
			strSqlBatch += "DELETE FROM EmrProviderFloatTableDropdownT WHERE EmrTableDropdownGroupID NOT IN (SELECT DISTINCT DropdownGroupID FROM EMRTableDropDownInfoT)\r\n";
			// (a.walling 2007-08-29 13:26) - PLID 27223 - Remove the Groups row if necessary
			str.Format("DELETE FROM EMRTableDropdownGroupsT WHERE ID NOT IN (SELECT DISTINCT DropdownGroupID FROM EMRTableDropDownInfoT)\r\n");
			strSqlBatch += str;

			//audit the deletion
			CString strNewValue;
			strNewValue.Format("Removed '%s' from Column '%s'", pddi->strData, pDataElement.m_strData);

			if(nAuditTransactionID == -1)
				nAuditTransactionID = BeginAuditTransaction();
			AuditEvent(-1, "", nAuditTransactionID, aeiEMRItemTableDropdownDeleted, atoi(strSourceID), "Item: " + strName, strNewValue, aepMedium, aetDeleted);
		}
	}

	//lastly generate statements to update items
	// (a.walling 2014-06-30 10:21) - PLID 62497
	for(const auto& pddi : pDataElement.m_arypEMRDropDownList)
	{
		if(pddi->nID != -1)
		{
			//compare to the existing data so we can determine if anything actually changed, and then audit

			// (j.jones 2006-08-30 15:11) - PLID 22038 - use the bSomethingChanged variable to only
			// update the data when something actually changed, and in turn causes this function to return TRUE

			// (a.walling 2014-06-30 10:21) - PLID 62497
			CEmrTableDropDownItem* pddiOrig = pOrigDataElement.m_arypEMRDropDownList.FindDropdownElement(pddi->nID);
			if (!pddiOrig) {
				// (z.manning 2009-02-12 09:50) - PLID 33029 - This dropdown item already existed so we should have found it in the original array.
				ThrowNxException("CEmrItemEntryDlg::AddStatementToSqlBatch_EmrTableDropDownChanges - Could not find original dropdown item with ID %li", pddi->nID);
			}

			BOOL bSomethingChanged = FALSE;

			// (z.manning 2009-02-12 16:22) - PLID 33065 - We already keep track of the original values
			// for everything here so there's no need to pull this stuff from data.
			//_RecordsetPtr rs = CreateRecordset("SELECT Data, SortOrder, Inactive FROM EMRTableDropdownInfoT WHERE ID = %li", ((CEmrTableDropDownItem*)pDataElement.m_arypEMRDropDownList.GetAt(i))->nID);
			CString strData = pddiOrig->strData;
			long nSortOrder = pddiOrig->nSortOrder;
			BOOL bInactive = pddiOrig->bInactive;
			//TES 3/15/2011 - PLID 42757 - Added GlassesOrderDataID and GlassesOrderDataName
			long nGlassesOrderDataID = pddiOrig->nGlassesOrderDataID;
			CString strGlassesOrderDataName = pddiOrig->strGlassesOrderDataName;
			// (j.gruber 2014-07-22 13:11) - PLID 62627 - Keyword columns
			BOOL bOrigUseKeyword = pddiOrig->bUseKeyword;
			CString strOrigKeywordOverride = pddiOrig->strKeywordOverride;

			if (strData != pddi->strData) {

				bSomethingChanged = TRUE;

				CString strOldValue, strNewValue;
				strOldValue.Format("%s (Column '%s', Item: %s)", strData, pDataElement.m_strData, strName);
				strNewValue.Format("%s (Column '%s', Item: %s)", pddi->strData, pDataElement.m_strData, strName);

				if(nAuditTransactionID == -1)
					nAuditTransactionID = BeginAuditTransaction();
				AuditEvent(-1, "", nAuditTransactionID, aeiEMRItemTableDropdownName, atoi(strSourceID), strOldValue, strNewValue, aepMedium, aetChanged);
			}

			if (nSortOrder != pddi->nSortOrder) {

				bSomethingChanged = TRUE;

				CString strOldValue, strNewValue;
				strOldValue.Format("'%s', Order: %li (Column '%s', Item: %s)", strData, nSortOrder, pDataElement.m_strData, strName);
				strNewValue.Format("'%s', Order: %li (Column '%s', Item: %s)", strData, pddi->nSortOrder, pDataElement.m_strData, strName);

				if(nAuditTransactionID == -1)
					nAuditTransactionID = BeginAuditTransaction();
				AuditEvent(-1, "", nAuditTransactionID, aeiEMRItemTableDropdownSortOrder, atoi(strSourceID), strOldValue, strNewValue, aepMedium, aetChanged);
			}

			if (bInactive != pddi->bInactive) {

				bSomethingChanged = TRUE;

				CString strOldValue, strNewValue;
				strOldValue.Format("'%s', %s (Column '%s', Item: %s)", strData, bInactive ? "Inactive" : "Active", pDataElement.m_strData, strName);
				strNewValue.Format("'%s', %s (Column '%s', Item: %s)", strData, pddi->bInactive ? "Inactive" : "Active", pDataElement.m_strData, strName);

				if(nAuditTransactionID == -1)
					nAuditTransactionID = BeginAuditTransaction();
				AuditEvent(-1, "", nAuditTransactionID, aeiEMRItemTableDropdownInactive, atoi(strSourceID), strOldValue, strNewValue, aepMedium, aetChanged);
			}

			//TES 3/15/2011 - PLID 42757 - Added GlassesOrderDataID
			if (nGlassesOrderDataID != pddi->nGlassesOrderDataID) {

				bSomethingChanged = TRUE;

				CString strOldValue, strNewValue;
				CString strOldName = strGlassesOrderDataName;
				if(strOldName.IsEmpty()) strOldName = "<None>";
				CString strNewName = pddi->strGlassesOrderDataName;
				if(strNewName.IsEmpty()) strNewName = "<None>";
				strOldValue.Format("'%s', %s (Column '%s', Item: %s)", strData, strOldName, pDataElement.m_strData, strName);
				strNewValue.Format("'%s', %s (Column '%s', Item: %s)", strData, strNewName, pDataElement.m_strData, strName);

				if(nAuditTransactionID == -1)
					nAuditTransactionID = BeginAuditTransaction();
				AuditEvent(-1, "", nAuditTransactionID, aeiEMRItemTableDropdownGlassesOrderRecord, atoi(strSourceID), strOldValue, strNewValue, aepMedium, aetChanged);
			}

			// (j.gruber 2014-07-22 13:11) - PLID 62627 - Keyword
			if (bOrigUseKeyword != pddi->bUseKeyword)
			{
				bSomethingChanged = TRUE;

				CString strOldValue, strNewValue;
				strOldValue.Format("'%s', %s (Column '%s', Item: %s)", strData, bOrigUseKeyword ? "Checked" : "Unchecked", pDataElement.m_strData, strName);
				strNewValue.Format("'%s', %s (Column '%s', Item: %s)", strData, pddi->bUseKeyword ? "Checked" : "Unchecked", pDataElement.m_strData, strName);

				if (nAuditTransactionID == -1)
					nAuditTransactionID = BeginAuditTransaction();
				AuditEvent(-1, "", nAuditTransactionID, aeiEMRTableDropDownUseKeyword, atoi(strSourceID), strOldValue, strNewValue, aepMedium, aetChanged);
				
			}

			// (j.gruber 2014-07-22 13:11) - PLID 62627 - KeywordOverride
			if (strOrigKeywordOverride != pddi->strKeywordOverride)
			{
				bSomethingChanged = TRUE;

				CString strOldValue, strNewValue;
				strOldValue.Format("'%s', %s (Column '%s', Item: %s)", strData, strOrigKeywordOverride, pDataElement.m_strData, strName);
				strNewValue.Format("'%s', %s (Column '%s', Item: %s)", strData, pddi->strKeywordOverride, pDataElement.m_strData, strName);

				if (nAuditTransactionID == -1)
					nAuditTransactionID = BeginAuditTransaction();
				AuditEvent(-1, "", nAuditTransactionID, aeiEMRTableDropDownKeywordOverride, atoi(strSourceID), strOldValue, strNewValue, aepMedium, aetChanged);

			}
			
			if(bSomethingChanged) {
				CString str;
				//TES 3/15/2011 - PLID 42757 - Added GlassesOrderDataID
				// (j.gruber 2014-07-22 13:11) - PLID 62627 - Keyword Fields
				CString strGlassesOrderDataID = "NULL";
				if (pddi->nGlassesOrderDataID != -1) {
					strGlassesOrderDataID = AsString(pddi->nGlassesOrderDataID);
				}
				str.Format("UPDATE EMRTableDropdownInfoT SET Data = '%s', SortOrder = %li, Inactive = %li, GlassesOrderDataID = %s, UseKeyword = %li, KeywordOverride = '%s' "
					"WHERE ID = %li\r\n",
					_Q(pddi->strData),
					pddi->nSortOrder,
					pddi->bInactive ? 1 : 0,
					strGlassesOrderDataID,
					pddi->bUseKeyword ? 1 : 0,
					_Q(pddi->strKeywordOverride),
					pddi->nID);
				strSqlBatch += str;

				// (c.haag 2010-07-10 11:19) - PLID 39467 - Any time we potentially modify the sort order of EMRTableDropdownInfoT,
				// we have to do validation to ensure we did not create multiple values for a dropdown with the same sort order.
				bValidateEMRTableDropdownInfoSortOrder = TRUE;
				bAns = TRUE;
			}

			// (z.manning 2009-02-12 09:54) - PLID 33029 - Table dropdown items can now have their own
			// actions so we need to save them.
			CString strSourceID = AsString(pddi->nID);
			if(AddStatementToSqlBatch_EmrActionChanges(strSqlBatch, eaoEmrTableDropDownItem, strSourceID, pddiOrig->aryActions, pddi->aryActions, nAuditTransactionID)) {
				bAns = TRUE;
			}

			// (z.manning 2011-09-28 17:41) - PLID 45729 - See if we need to update the stamp filter for this dropdown item
			if(pddi->bStampFilterChanged)
			{
				AddStatementToSqlBatch(strSqlBatch, "DELETE FROM EmrTableDropdownStampFilterT WHERE EmrTableDropdownInfoID = %li", pddi->nID);
				// (a.walling 2014-06-30 10:21) - PLID 62497
				for(auto dropdownStampInfo : pddi->aryStampFilter) {
					AddStatementToSqlBatch(strSqlBatch,
						"INSERT INTO EmrTableDropdownStampFilterT (EmrTableDropdownInfoID, StampID) VALUES (%li, %li)"
						, pddi->nID, dropdownStampInfo.nStampID);
				}
				bAns = TRUE;
			}
			// (j.jones 2012-11-26 15:24) - PLID 53144 - added EMRTableDropdownStampDefaultsT
			if(pddi->bStampDefaultsChanged)
			{
				AddStatementToSqlBatch(strSqlBatch, "DELETE FROM EMRTableDropdownStampDefaultsT WHERE EmrTableDropdownInfoID = %li", pddi->nID);
				// (a.walling 2014-06-30 10:21) - PLID 62497
				for (auto dropdownStampInfo : pddi->aryStampDefaults) {
					AddStatementToSqlBatch(strSqlBatch,
						"INSERT INTO EMRTableDropdownStampDefaultsT (EmrTableDropdownInfoID, StampID) VALUES (%li, %li)"
						, pddi->nID, dropdownStampInfo.nStampID);
				}
				bAns = TRUE;
			}

			// (j.gruber 2013-09-30 12:04) - PLID 58675
			if(pddi->bCodesChanged)
			{

				//let's audit
				CString strOldValue, strNewValue;
				strOldValue.Format("Column '%s', Dropdown: %s, Codes: %s", pddiOrig->strData, pDataElement.m_strData, pddiOrig->aryCodes.GetCodeString());
				strNewValue.Format("Column '%s', Dropdown: %s, Codes: %s", pddi->strData, pDataElement.m_strData, pddi->aryCodes.GetCodeString());

				if(nAuditTransactionID == -1)
					nAuditTransactionID = BeginAuditTransaction();
				AuditEvent(-1, "", nAuditTransactionID, aeiEMRTemplateDropDownCode, atoi(strSourceID), strOldValue, strNewValue, aepMedium, aetChanged);

				AddStatementToSqlBatch(strSqlBatch, "DELETE FROM EmrTableDropdownGroupCodesT WHERE EmrTableDropdownGroupID  = %li", pddi->nDropDownGroupID);
				for(int nCodeIndex = 0; nCodeIndex < pddi->aryCodes.GetCount(); nCodeIndex++) {
					CEMRCode code = pddi->aryCodes.GetAt(nCodeIndex);
					AddStatementToSqlBatch(strSqlBatch,
						"INSERT INTO EmrTableDropdownGroupCodesT (EmrTableDropdownGroupID, CodeID) VALUES (%li, %li)"
						, pddi->nDropDownGroupID, code.GetID());
				}
				bAns = TRUE;
			}
		}
	}	

	// (c.haag 2010-07-10 11:19) - PLID 39467 - Any time we potentially modify the sort order of EMRTableDropdownInfoT,
	// we have to do validation to ensure we did not create multiple values for a dropdown with the same sort order.
	if (bValidateEMRTableDropdownInfoSortOrder)
	{
		CString str;
		str.Format("IF EXISTS(SELECT EMRDataID, SortOrder FROM EMRTableDropdownInfoT WHERE EMRDataID = (%s) GROUP BY EMRDataID, SortOrder HAVING Count(SortOrder) > 1) \r\n"
			"BEGIN \r\n"
			"	RAISERROR('Duplicate SortOrder values found for EmrDataID %s!', 16, 1) ROLLBACK TRAN RETURN \r\n"
			"END \r\n"
			, strSourceID, strSourceID);
		strSqlBatch += str;
	}

	return bAns;
}

// (c.haag 2008-06-27 18:23) - PLID 30221 - Uses to sort todo assign-to array values for easy comparison
// with other arrays
int CompareTodoAssignToAryElements(const void *pa, const void *pb)
{
	const long* pna = (const long*)pa;
	const long* pnb = (const long*)pb;
	if (*pna < *pnb) {
		return -1;
	} else if (*pna == *pnb) {
		return 0;
	} else {
		return 1;
	}
}

// (c.haag 2007-03-05 10:02) - PLID 23943 - Added support for auditing
BOOL CEmrItemEntryDlg::AddStatementToSqlBatch_EmrActionChanges(IN OUT CString &strSqlBatch, long nSourceType, const CString &strSourceID, const MFCArray<EmrAction> &arOriginalActions, const MFCArray<EmrAction> &arCurrentActions, long &nAuditTransactionID)
{
	CString strName;
	GetDlgItemText(IDC_ITEM_NAME, strName);
	strName.TrimRight();
	strName.TrimLeft();

	MFCArray<EmrAction> arActionsToAdd, arActionsToRemove, arActionsToUpdate;
	// (a.walling 2007-11-05 16:08) - PLID 27980 - VS2008 - Use Copy()
	int i = 0;

	arActionsToAdd.Copy(arCurrentActions);
	arActionsToRemove.Copy(arOriginalActions);

	//for(i = 0; i < arCurrentActions.GetSize(); i++) arActionsToAdd.Add(arCurrentActions[i]);
	//for(i = 0; i < arOriginalActions.GetSize(); i++) arActionsToRemove.Add(arOriginalActions[i]);
	
	for(i = arActionsToAdd.GetSize()-1; i >= 0; i--) {
		EmrAction eaCurrent = arActionsToAdd[i];
		//Try to match to an original action.
		bool bMatched = false;
		for(int j = 0; j < arActionsToRemove.GetSize() && !bMatched; j++) {
			EmrAction eaOrig = arActionsToRemove[j];
			//(s.dhole 8/15/2014 9:46 AM ) - PLID 62724  for dignosis code we should check pair of ICD id's , Since gany session there wont be duplicate ICD code  pair
			if ((eaCurrent.eaoDestType != eaoDiagnosis && eaCurrent.eaoDestType == eaOrig.eaoDestType && eaCurrent.nDestID == eaOrig.nDestID)
				|| (eaCurrent.eaoDestType == eaoDiagnosis && 
				eaCurrent.diaDiagnosis.nDiagCodeID_ICD10 == eaOrig.diaDiagnosis.nDiagCodeID_ICD10 &&
				eaCurrent.diaDiagnosis.nDiagCodeID_ICD9 == eaOrig.diaDiagnosis.nDiagCodeID_ICD9))
			{
				//Found it!
				bMatched = true;
				arActionsToAdd.RemoveAt(i);
				arActionsToRemove.RemoveAt(j);
				//Does it need updating?
				// (c.haag 2008-07-18 08:57) - PLID 30775 - Use the new utility function to compare the two actions.
				if (!DoesEmrActionContentMatch(eaCurrent, eaOrig)) {
					// (z.manning, 04/09/2007) - PLID 25542 - If we removed and then re-added the same action
					// then the action ID of the new one may be -1 and thus won't save anything. Let's fix that.
					if(eaCurrent.nID == -1) {
						eaCurrent.nID = eaOrig.nID;
					}
					//Yup.
					arActionsToUpdate.Add(eaCurrent);
				}
			}
		}
	}


	// Now if we have to make a change, generate the sql statement for the change
	BOOL bAns = FALSE;
	if (arActionsToRemove.GetSize() > 0) {
		bAns = TRUE;
		AddStatementToSqlBatch(strSqlBatch, 
			"EXEC sp_xml_preparedocument @hDoc OUTPUT, N'%s'; "
			"UPDATE EmrActionsT SET Deleted = 1 FROM EmrActionsT INNER JOIN OPENXML(@hDoc, '/ROOT/A') WITH (ID INT, DestType INT, DestID INT, SortOrder INT, Popup BIT) XmlQ "
			"  ON EmrActionsT.ID = XmlQ.ID "
			" WHERE SourceType = %li AND SourceID = %s "
			"EXEC sp_xml_removedocument @hDoc;", GenerateXMLFromActionArray(arActionsToRemove), nSourceType, strSourceID);

		//DRT 1/10/2007 - PLID 24181 - EMRActionChargeDataT inherits its deleted flag from EMRActionsT, so there is no need
		//	to update this table at all for removed actions.

		for(i = 0; i < arActionsToRemove.GetSize(); i++) {

			long nActionIDToRemove = arActionsToRemove[i].nID;

			//TES 12/12/2006 - PLID 22321 - Just store locally for now, until we're sure the changes have been committed.
			/*if(m_pCurrentEMN) {
				m_pCurrentEMN->m_arActionsToRevoke.Add(arActionsToRemove.GetAt(i));
			}*/
			m_arActionsToRevoke.Add(arActionsToRemove.GetAt(i));

			// (z.manning, PLID 19099, 3/28/2006) - Since these actions will no longer be processed
			// on templates, make sure we clean up the data.
			// (c.haag 2007-03-06 11:36) - PLID 23943 - The transaction ID is now passed into this function
			//long nAuditTransactionID = -1;
			// Remove all spawned template topics for this deleted action.
			_RecordsetPtr prsTemplateTopics = CreateRecordset("SELECT ID FROM EmrTemplateTopicsT "
				"WHERE SourceActionID = %li", nActionIDToRemove);
			while(!prsTemplateTopics->eof) {
				long nTemplateTopicID = AdoFldLong(prsTemplateTopics, "ID");

				Nx::Quantum::Batch strDeleteBatch;
				DeleteEMRTemplateTopic(nTemplateTopicID, strDeleteBatch);
				strSqlBatch += strDeleteBatch.FlattenToEither();
				
				/*
				CEMRTopic* pTopic = new CEMRTopic(TRUE, TRUE);
				pTopic->LoadFromTemplateTopicID(nTemplateTopicID, FALSE, NULL, nActionIDToRemove);
				AddStatementToSqlBatch(strSqlBatch, pTopic->GenerateDeleteString(nAuditTransactionID));
				delete pTopic;
				*/

				prsTemplateTopics->MoveNext();
			}
			prsTemplateTopics->Close();

			// Remove all spawned template details for this deleted action.

			// (j.jones 2006-06-23 09:50) - PLID 20962 - changed the logic to not load details and delete,
			// instead just run the delete statements

			// (j.jones 2007-01-12 11:09) - PLID 24027 - migrated to DeleteEMRTemplateDetail

			_RecordsetPtr rsDetails = CreateRecordset("SELECT ID FROM EmrTemplateDetailsT WHERE SourceActionID = %li", nActionIDToRemove);
			while(!rsDetails->eof) {
				Nx::Quantum::Batch strDeleteBatch;
				DeleteEMRTemplateDetail(AdoFldLong(rsDetails,"ID"), strDeleteBatch);
				strSqlBatch += strDeleteBatch.FlattenToEither();
				rsDetails->MoveNext();
			}
			rsDetails->Close();

			/*
			AddStatementToSqlBatch(strSqlBatch, "DELETE FROM EMRTemplateTableDefaultsT WHERE EmrTemplateDetailID IN (SELECT ID FROM EmrTemplateDetailsT "
				"WHERE SourceActionID = %li)", nActionIDToRemove);
			AddStatementToSqlBatch(strSqlBatch, "DELETE FROM EMRTemplateTableColumnWidthsT WHERE EmrDetailID IN (SELECT ID FROM EmrTemplateDetailsT "
				"WHERE SourceActionID = %li)", nActionIDToRemove);
			AddStatementToSqlBatch(strSqlBatch, "DELETE FROM EmrTemplateSelectT WHERE EmrTemplateDetailID IN (SELECT ID FROM EmrTemplateDetailsT "
				"WHERE SourceActionID = %li)", nActionIDToRemove);
			AddStatementToSqlBatch(strSqlBatch, "DELETE FROM EmrTemplateDetailsT WHERE ID IN (SELECT ID FROM EmrTemplateDetailsT "
				"WHERE SourceActionID = %li)", nActionIDToRemove);
			*/				

			/*
			_RecordsetPtr prsTemplateDetails = CreateRecordset("SELECT ID FROM EmrTemplateDetailsT "
				"WHERE SourceActionID = %li", nActionIDToRemove);
			while(!prsTemplateDetails->eof) {
				long nTemplateDetailID = AdoFldLong(prsTemplateDetails, "ID");
				CEMNDetail* pDetail = CEMNDetail::CreateDetail(NULL);
				pDetail->LoadFromTemplateDetailID(nTemplateDetailID, TRUE, FALSE, NULL);
				AddStatementToSqlBatch(strSqlBatch, pDetail->GenerateDeleteString(nAuditTransactionID));
				delete pDetail;

				prsTemplateDetails->MoveNext();
			}
			prsTemplateDetails->Close();
			*/


			//
			// (c.haag 2007-03-06 11:22) - PLID 23943 - Audit the deletion of the action if this is not a new item (this will
			// probably never happen on a new item, but I'm checking for completeness)
			//
			if (-1 != m_nID) {
				const EmrAction& acDelete = arActionsToRemove[i];
				CString strSourceTypeText = GetAuditSourceTypeText((EmrActionObject)nSourceType, strSourceID, NULL, NULL);
				CString strDestTypeText = GetAuditDestTypeText(acDelete.eaoDestType, acDelete.nDestID);
				CString strNewValue = CString("Removed spawning of ") + strDestTypeText + " from the " + strSourceTypeText;
				if(nAuditTransactionID == -1) nAuditTransactionID = BeginAuditTransaction();
				AuditEvent(-1, "", nAuditTransactionID, aeiEMRActionDeleted, (strSourceID == "@nEMRInfoID") ? m_nID : atoi(strSourceID), "Item: " + strName, strNewValue, aepMedium, aetDeleted);
			} // if (-1 != m_nID)

		} // for(i = 0; i < arActionsToRemove.GetSize(); i++) {
	} // if (arActionsToRemove.GetSize() > 0) {

	if(arActionsToUpdate.GetSize() > 0) {
		bAns = TRUE;
		AddStatementToSqlBatch(strSqlBatch,
			"EXEC sp_xml_preparedocument @hDoc OUTPUT, N'%s'; "
			"UPDATE EmrActionsT SET SortOrder = XmlQ.SortOrder, Popup = XmlQ.Popup, SpawnAsChild = XmlQ.SpawnAsChild FROM EmrActionsT INNER JOIN OPENXML(@hDoc, '/ROOT/A') WITH (ID INT, DestType INT, DestID INT, SortOrder INT, Popup BIT, SpawnAsChild BIT) XmlQ "
			" ON EmrActionsT.ID = XmlQ.ID "
			" WHERE SourceType = %li AND SourceID = %s "
			"EXEC sp_xml_removedocument @hDoc;", GenerateXMLFromActionArray(arActionsToUpdate), nSourceType, strSourceID);

		//(s.dhole 7/18/2014 1:57 PM ) - PLID 62724 Change save code to support new diagnosis structure
		AddStatementToSqlBatch(strSqlBatch,
			"EXEC sp_xml_preparedocument @hDoc OUTPUT, N'%s'; "
			"UPDATE EMRActionDiagnosisDataT  SET DiagCodeID_ICD9 = XmlQ.DiagCodeID_ICD9, DiagCodeID_ICD10 = XmlQ.DiagCodeID_ICD10  FROM EMRActionDiagnosisDataT INNER JOIN OPENXML(@hDoc, '/ROOT/A') WITH (EmrActionID INT, DiagCodeID_ICD9 INT, DiagCodeID_ICD10 INT) XmlQ "
			" ON EMRActionDiagnosisDataT.EmrActionID = XmlQ.EmrActionID "
			" INNER JOIN EmrActionsT ON EmrActionsT.ID =EMRActionDiagnosisDataT.EmrActionID "
			" WHERE SourceType = %li AND SourceID = %s "
			"EXEC sp_xml_removedocument @hDoc;", GenerateXMLFromDiagActionArray(arActionsToUpdate), nSourceType, strSourceID);

		//DRT 1/10/2007 - PLID 24181 - We need to update the special charge data table, changes may exist there as well.
		AddStatementToSqlBatch(strSqlBatch,
			"EXEC sp_xml_preparedocument @hDoc OUTPUT, N'%s'; "
			"UPDATE EmrActionChargeDataT SET Prompt = XmlQ.Prompt, DefaultQuantity = XmlQ.DefaultQuantity, Modifier1Number = XmlQ.Modifier1Number, "
			"Modifier2Number = XmlQ.Modifier2Number, Modifier3Number = XmlQ.Modifier3Number, Modifier4Number = XmlQ.Modifier4Number "
			"FROM EmrActionChargeDataT INNER JOIN EmrActionsT ON EmrActionChargeDataT.ActionID = EMRActionsT.ID "
			"INNER JOIN OPENXML(@hDoc, '/ROOT/A') WITH (ActionID INT, Prompt BIT, DefaultQuantity FLOAT, "
			"Modifier1Number NVARCHAR(10), Modifier2Number NVARCHAR(10), Modifier3Number NVARCHAR(10), Modifier4Number NVARCHAR(10)) XmlQ "
			" ON EmrActionsT.ID = XmlQ.ActionID "
			" WHERE SourceType = %li AND SourceID = %s "
			"EXEC sp_xml_removedocument @hDoc;", GenerateChargeDataXMLFromActionArray(arActionsToUpdate), nSourceType, strSourceID);

		// (c.haag 2008-06-20 10:32) - PLID 30221 - We need to update EMRActionsTodoDataT
		AddStatementToSqlBatch(strSqlBatch,
			"EXEC sp_xml_preparedocument @hDoc OUTPUT, N'%s'; "
			"UPDATE EMRActionsTodoDataT SET RemindType = XmlQ.RemindType, RemindInterval = XmlQ.RemindInterval, "
			"DeadlineType = XmlQ.DeadlineType, DeadlineInterval = XmlQ.DeadlineInterval, Notes = XmlQ.Notes, "
			"Priority = XmlQ.Priority, Task = XmlQ.Task, CategoryID = XmlQ.CategoryID "
			"FROM EMRActionsTodoDataT INNER JOIN EmrActionsT ON EMRActionsTodoDataT.ActionID = EMRActionsT.ID "
			"INNER JOIN OPENXML(@hDoc, '/ROOT/A') WITH (ActionID INT, RemindType INT, RemindInterval INT, "
			"DeadlineType INT, DeadlineInterval INT, Notes NVARCHAR(2000), Priority TINYINT, Task NVARCHAR(50), "
			"CategoryID INT) XmlQ "
			" ON EmrActionsT.ID = XmlQ.ActionID "
			" WHERE SourceType = %li AND SourceID = %s "
			"EXEC sp_xml_removedocument @hDoc;", GenerateTodoDataXMLFromActionArray(arActionsToUpdate), nSourceType, strSourceID);

		// Update "assign to" records...though we update by deleting and adding records. First, delete existing records.
		// (c.haag 2008-07-18 11:46) - PLID 30724 - Following the role model of Emr Problem Actions, we should only have to
		// generate the XML SQL once.
		const CString strTodoAssignToXML = GenerateTodoAssignToXMLFromActionArray(arActionsToUpdate);
		AddStatementToSqlBatch(strSqlBatch,
			"EXEC sp_xml_preparedocument @hDoc OUTPUT, N'%s'; "
			"DELETE FROM EmrActionsTodoAssignToT WHERE EmrActionsTodoAssignToT.ActionID IN ("
			" SELECT EmrActionsTodoAssignToT.ActionID FROM EmrActionsTodoAssignToT "
			" INNER JOIN EmrActionsT ON EmrActionsTodoAssignToT.ActionID = EMRActionsT.ID "
			" INNER JOIN OPENXML(@hDoc, '/ROOT/A') WITH (ActionID INT, AssignTo INT) XmlQ ON EmrActionsT.ID = XmlQ.ActionID "
			" WHERE SourceType = %li AND SourceID = %s ) "
			"EXEC sp_xml_removedocument @hDoc;", strTodoAssignToXML, nSourceType, strSourceID);
		// ...second, add new assignees
		AddStatementToSqlBatch(strSqlBatch,
			"EXEC sp_xml_preparedocument @hDoc OUTPUT, N'%s'; "
			"INSERT INTO EmrActionsTodoAssignToT (ActionID, AssignTo) "
			" SELECT XmlQ.ActionID, XmlQ.AssignTo FROM EMRActionsT "
			" INNER JOIN OPENXML(@hDoc, '/ROOT/A') WITH (ActionID INT, AssignTo INT) XmlQ ON EmrActionsT.ID = XmlQ.ActionID "
			" WHERE SourceType = %li AND SourceID = %s "
			"EXEC sp_xml_removedocument @hDoc;", strTodoAssignToXML, nSourceType, strSourceID);

		// (c.haag 2008-07-17 17:09) - PLID 30724 - Update Emr Problem Actions. Keep in mind that actions may have been created, deleted, and modified.
		// So, we will just delete any existing records, and add new records.
		// (c.haag 2008-08-05 09:14) - PLID 30941 - We no longer delete EMR problem action records; we only flag them as inactive
		int nCnt;
		for (nCnt = 0; nCnt < arActionsToUpdate.GetSize(); nCnt++) {
			EmrAction acCurrent = arActionsToUpdate.GetAt(nCnt);
			EmrAction acOld;
			BOOL bFound = FALSE;
			CProblemActionAry aCreated, aDeleted, aModified;

			// Find the original version of the item so we know how to do the audit
			for (int nOld=0; nOld < arOriginalActions.GetSize() && !bFound; nOld++) {
				if (arOriginalActions[nOld].nID == acCurrent.nID) {
					acOld = arOriginalActions[nOld];
					bFound = TRUE;
				}
			}
			if (!bFound) {				
				ASSERT(FALSE); // We should never get here
				ThrowNxException(FormatString("Could not find original action for auditing change! (ID = %li)",acCurrent.nID));
			}

			// Generate unique XML for every action
			GetEmrActionProblemDiffs(acOld, acCurrent, aCreated, aDeleted, aModified);
			if (!aCreated.empty()) {
				// (c.haag 2014-07-22) - PLID 62789 - Added SNOMEDCodeID
				// (s.tullis 2015-02-23 17:47) - PLID 64749 
				// (r.gonet 2015-03-10 14:48) - PLID 65013 - Added DoNotShowOnProblemPrompt.
				const CString strEmrProblemActionXML = GenerateEmrProblemDataXMLFromActionArray(acCurrent, aCreated);
				AddStatementToSqlBatch(strSqlBatch,
					"EXEC sp_xml_preparedocument @hDoc OUTPUT, N'%s'; "
					"INSERT INTO EmrProblemActionsT (EmrActionID, DefaultDescription, DefaultStatus, SpawnToSourceItem, SNOMEDCodeID, DoNotShowOnCCDA, DoNotShowOnProblemPrompt) "
					" SELECT XmlQ.ActionID, XmlQ.DefaultDescription, XmlQ.DefaultStatus, XmlQ.SpawnToSourceItem, XmlQ.SNOMEDCodeID, XmlQ.DoNotShowOnCCDA, XmlQ.DoNotShowOnProblemPrompt FROM EMRActionsT "
					" INNER JOIN OPENXML(@hDoc, '/ROOT/A') WITH (EmrProblemActionID INT, ActionID INT, DefaultDescription NVARCHAR(2000), DefaultStatus INT, SpawnToSourceItem BIT, SNOMEDCodeID INT, DoNotShowOnCCDA BIT, DoNotShowOnProblemPrompt BIT) XmlQ ON EmrActionsT.ID = XmlQ.ActionID "
					" WHERE SourceType = %li AND SourceID = %s "
					"EXEC sp_xml_removedocument @hDoc;", strEmrProblemActionXML, nSourceType, strSourceID);
			}
			if (!aModified.empty()) {
				// (c.haag 2014-07-22) - PLID 62789 - Added SNOMEDCodeID
				// (s.tullis 2015-02-23 17:47) - PLID 64749 
				// (r.gonet 2015-03-10 14:48) - PLID 65013 - Added DoNotShowOnProblemPrompt.
				const CString strEmrProblemActionXML = GenerateEmrProblemDataXMLFromActionArray(acCurrent, aModified);
				AddStatementToSqlBatch(strSqlBatch,
					"EXEC sp_xml_preparedocument @hDoc OUTPUT, N'%s'; "
					"UPDATE EmrProblemActionsT SET DefaultDescription = XmlQ.DefaultDescription, DefaultStatus = XmlQ.DefaultStatus, SpawnToSourceItem = XmlQ.SpawnToSourceItem, SNOMEDCodeID = XmlQ.SNOMEDCodeID,DoNotShowOnCCDA= XmlQ.DoNotShowOnCCDA, DoNotShowOnProblemPrompt = XmlQ.DoNotShowOnProblemPrompt FROM EmrProblemActionsT "
					" INNER JOIN OPENXML(@hDoc, '/ROOT/A') WITH (EmrProblemActionID INT, ActionID INT, DefaultDescription NVARCHAR(2000), DefaultStatus INT, SpawnToSourceItem BIT, SNOMEDCodeID INT, DoNotShowOnCCDA BIT, DoNotShowOnProblemPrompt BIT) XmlQ ON EmrProblemActionsT.ID = XmlQ.EmrProblemActionID "
					"EXEC sp_xml_removedocument @hDoc;", strEmrProblemActionXML, nSourceType, strSourceID);
			}
			if (!aDeleted.empty()) {
				// (r.gonet 2015-03-10 14:48) - PLID 65013 - Added DoNotShowOnProblemPrompt.
				const CString strEmrProblemActionXML = GenerateEmrProblemDataXMLFromActionArray(acCurrent, aDeleted);
				AddStatementToSqlBatch(strSqlBatch,
					"EXEC sp_xml_preparedocument @hDoc OUTPUT, N'%s'; "
					"UPDATE EmrProblemActionsT SET Inactive = 1 WHERE EmrProblemActionsT.ID IN ("
					" SELECT EmrProblemActionsT.ID FROM EmrProblemActionsT "
					" INNER JOIN OPENXML(@hDoc, '/ROOT/A') WITH (EmrProblemActionID INT, ActionID INT, DefaultDescription NVARCHAR(2000), DefaultStatus INT, SpawnToSourceItem BIT, SNOMEDCodeID INT, DoNotShowOnCCDA BIT, DoNotShowOnProblemPrompt BIT) XmlQ ON EmrProblemActionsT.ID = XmlQ.EmrProblemActionID ) "
					"EXEC sp_xml_removedocument @hDoc;", strEmrProblemActionXML, nSourceType, strSourceID);
			}
		}

		//
		// (c.haag 2007-03-06 11:46) - PLID 23943 - Audit the updating of action data
		//
		for (nCnt = 0; nCnt < arActionsToUpdate.GetSize(); nCnt++) {
			EmrAction acCurrent = arActionsToUpdate.GetAt(nCnt);
			EmrAction acOld;
			BOOL bFound = FALSE;

			// Find the original version of the item so we know how to do the audit
			for (int nOld=0; nOld < arOriginalActions.GetSize() && !bFound; nOld++) {
				if (arOriginalActions[nOld].nID == acCurrent.nID) {
					acOld = arOriginalActions[nOld];
					bFound = TRUE;
				}
			}
			if (!bFound) {				
				ASSERT(FALSE); // We should never get here
				ThrowNxException(FormatString("Could not find original action for auditing change! (ID = %li)",acCurrent.nID));
			}

			// When we get here, we have the old and new data values. Check if anything we recognize
			// has changed (which should be everything), and if so, flag the change to take effect.
			BOOL bAudit = FALSE;

			// (c.haag 2008-07-18 08:58) - PLID 30775 - Use the new utility function to compare the two actions.
			if (!DoesEmrActionContentMatch(acCurrent, acOld)) {
				bAudit = TRUE;
			}

			// Now audit all recognized individual differences
			if (bAudit) {
				CString strOldValue, strNewValue;
				CString strSourceTypeText = GetAuditSourceTypeText((EmrActionObject)nSourceType, strSourceID);
				CString strDestTypeText = GetAuditDestTypeText(acCurrent.eaoDestType, acCurrent.nDestID);
				CString strAction = CString("Spawning of ") + strDestTypeText + " for the " + strSourceTypeText;

				if (acCurrent.bPrompt != acOld.bPrompt) {
					if (acCurrent.bPrompt) {
						strOldValue.Format("Will not prompt");
						strNewValue.Format("Will prompt");
					} else {
						strOldValue.Format("Will prompt");
						strNewValue.Format("Will not prompt");
					}
					if(nAuditTransactionID == -1) nAuditTransactionID = BeginAuditTransaction();
					AuditEvent(-1, "", nAuditTransactionID, aeiEMRActionChgPrompt, (strSourceID == "@nEMRInfoID") ? m_nID : atoi(strSourceID), "Item: " + strName + ".   Action: " + strAction + ".   Value: " + strOldValue, strNewValue, aepLow, aetChanged);
				}
				if (acCurrent.dblDefaultQuantity != acOld.dblDefaultQuantity) {
					// (c.haag 2007-03-06 12:14) - PLID 23943 - This is consistent with auditing billing quantities (see billingdlg.cpp)
					strOldValue.Format("%g", acOld.dblDefaultQuantity);
					strNewValue.Format("%g", acCurrent.dblDefaultQuantity);
					if(nAuditTransactionID == -1) nAuditTransactionID = BeginAuditTransaction();
					AuditEvent(-1, "", nAuditTransactionID, aeiEMRActionChgQuantity, (strSourceID == "@nEMRInfoID") ? m_nID : atoi(strSourceID), "Item: " + strName + ".   Action: " + strAction + ".   Value: " + strOldValue, strNewValue, aepLow, aetChanged);
				}
				if (acCurrent.strMod1 != acOld.strMod1) {
					strOldValue = acOld.strMod1;
					strNewValue = acCurrent.strMod1;
					if (strOldValue.IsEmpty()) strOldValue = "<none>";
					if (strNewValue.IsEmpty()) strNewValue = "<none>";
					if(nAuditTransactionID == -1) nAuditTransactionID = BeginAuditTransaction();
					AuditEvent(-1, "", nAuditTransactionID, aeiEMRActionChgMod1, (strSourceID == "@nEMRInfoID") ? m_nID : atoi(strSourceID), "Item: " + strName + ".   Action: " + strAction + ".   Value: " + strOldValue, strNewValue, aepLow, aetChanged);
				}
				if (acCurrent.strMod2 != acOld.strMod2) {
					strOldValue = acOld.strMod2;
					strNewValue = acCurrent.strMod2;
					if (strOldValue.IsEmpty()) strOldValue = "<none>";
					if (strNewValue.IsEmpty()) strNewValue = "<none>";
					if(nAuditTransactionID == -1) nAuditTransactionID = BeginAuditTransaction();
					AuditEvent(-1, "", nAuditTransactionID, aeiEMRActionChgMod2, (strSourceID == "@nEMRInfoID") ? m_nID : atoi(strSourceID), "Item: " + strName + ".   Action: " + strAction + ".   Value: " + strOldValue, strNewValue, aepLow, aetChanged);
				}
				if (acCurrent.strMod3 != acOld.strMod3) {
					strOldValue = acOld.strMod3;
					strNewValue = acCurrent.strMod3;
					if (strOldValue.IsEmpty()) strOldValue = "<none>";
					if (strNewValue.IsEmpty()) strNewValue = "<none>";
					if(nAuditTransactionID == -1) nAuditTransactionID = BeginAuditTransaction();
					AuditEvent(-1, "", nAuditTransactionID, aeiEMRActionChgMod3, (strSourceID == "@nEMRInfoID") ? m_nID : atoi(strSourceID), "Item: " + strName + ".   Action: " + strAction + ".   Value: " + strOldValue, strNewValue, aepLow, aetChanged);
				}
				if (acCurrent.strMod4 != acOld.strMod4) {
					strOldValue = acOld.strMod4;
					strNewValue = acCurrent.strMod4;
					if (strOldValue.IsEmpty()) strOldValue = "<none>";
					if (strNewValue.IsEmpty()) strNewValue = "<none>";
					if(nAuditTransactionID == -1) nAuditTransactionID = BeginAuditTransaction();
					AuditEvent(-1, "", nAuditTransactionID, aeiEMRActionChgMod4, (strSourceID == "@nEMRInfoID") ? m_nID : atoi(strSourceID), "Item: " + strName + ".   Action: " + strAction + ".   Value: " + strOldValue, strNewValue, aepLow, aetChanged);
				}
				if (acCurrent.bSpawnAsChild != acOld.bSpawnAsChild) {
					if (acCurrent.bSpawnAsChild) {
						strOldValue.Format("Spawn as siblings");
						strNewValue.Format("Spawn as children");
					} else {
						strOldValue.Format("Spawn as children");
						strNewValue.Format("Spawn as siblings");
					}
					if(nAuditTransactionID == -1) nAuditTransactionID = BeginAuditTransaction();
					AuditEvent(-1, "", nAuditTransactionID, aeiEMRActionSpawnAsChild, (strSourceID == "@nEMRInfoID") ? m_nID : atoi(strSourceID), "Item: " + strName + ".   Action: " + strAction + ".   Value: " + strOldValue, strNewValue, aepLow, aetChanged);
				}
				if (acCurrent.bPopup != acOld.bPopup) {
					if (acCurrent.bPopup) {
						strOldValue.Format("Will not pop up");
						strNewValue.Format("Will pop up");
					} else {
						strOldValue.Format("Will pop up");
						strNewValue.Format("Will not pop up");
					}
					if(nAuditTransactionID == -1) nAuditTransactionID = BeginAuditTransaction();
					AuditEvent(-1, "", nAuditTransactionID, aeiEMRActionPopup, (strSourceID == "@nEMRInfoID") ? m_nID : atoi(strSourceID), "Item: " + strName + ".   Action: " + strAction + ".   Value: " + strOldValue, strNewValue, aepLow, aetChanged);
				}
				if (acCurrent.nSortOrder != acOld.nSortOrder) {
					strOldValue.Format("%d", acOld.nSortOrder);
					strNewValue.Format("%d", acCurrent.nSortOrder);
					if(nAuditTransactionID == -1) nAuditTransactionID = BeginAuditTransaction();
					AuditEvent(-1, "", nAuditTransactionID, aeiEMRActionSortOrder, (strSourceID == "@nEMRInfoID") ? m_nID : atoi(strSourceID), "Item: " + strName + ".   Action: " + strAction + ".   Value: " + strOldValue, strNewValue, aepLow, aetChanged);
				}
				// (c.haag 2008-06-27 17:30) - PLID 30221 - Auditing for todo actions
				// Use max because the category ID can be -2 if the value loaded from data was NULL
				if (max(-1, acCurrent.nTodoCategoryID) != max(-1, acOld.nTodoCategoryID)) {
					_RecordsetPtr prs = CreateParamRecordset("SELECT "
						"(SELECT Description FROM NoteCatsF WHERE ID = {INT}) AS OldCategory, "
						"(SELECT Description FROM NoteCatsF WHERE ID = {INT}) AS NewCategory ",
						acOld.nTodoCategoryID, acCurrent.nTodoCategoryID);
					FieldsPtr f = prs->Fields;
					strOldValue = AdoFldString(f, "OldCategory", "");
					strNewValue = AdoFldString(f, "NewCategory", "");
					if(nAuditTransactionID == -1) nAuditTransactionID = BeginAuditTransaction();
					AuditEvent(-1, "", nAuditTransactionID, aeiEMRActionTodoCategory, (strSourceID == "@nEMRInfoID") ? m_nID : atoi(strSourceID), "Item: " + strName + ".   Action: " + strAction + ".   Value: " + strOldValue, strNewValue, aepLow, aetChanged);
				}
				if (acCurrent.strTodoMethod != acOld.strTodoMethod) {
					strOldValue = acOld.strTodoMethod;
					strNewValue = acCurrent.strTodoMethod;
					if(nAuditTransactionID == -1) nAuditTransactionID = BeginAuditTransaction();
					AuditEvent(-1, "", nAuditTransactionID, aeiEMRActionTodoMethod, (strSourceID == "@nEMRInfoID") ? m_nID : atoi(strSourceID), "Item: " + strName + ".   Action: " + strAction + ".   Value: " + strOldValue, strNewValue, aepLow, aetChanged);
				}
				if (acCurrent.strTodoNotes != acOld.strTodoNotes) {
					strOldValue = acOld.strTodoNotes;
					strNewValue = acCurrent.strTodoNotes;
					if(nAuditTransactionID == -1) nAuditTransactionID = BeginAuditTransaction();
					AuditEvent(-1, "", nAuditTransactionID, aeiEMRActionTodoNotes, (strSourceID == "@nEMRInfoID") ? m_nID : atoi(strSourceID), "Item: " + strName + ".   Action: " + strAction + ".   Value: " + strOldValue, strNewValue, aepLow, aetChanged);
				}
				if (!DoEmrActionTodoAssigneesMatch(acOld, acCurrent)) {
					_RecordsetPtr prs = CreateRecordset(
						"SELECT Username FROM UsersT WHERE PersonID IN (%s) ORDER BY Username;\r\n"
						"SELECT Username FROM UsersT WHERE PersonID IN (%s) ORDER BY Username;\r\n"
						, ArrayAsString(acOld.anTodoAssignTo), ArrayAsString(acCurrent.anTodoAssignTo)); // (a.walling 2014-07-01 15:28) - PLID 62697
					strOldValue.Empty();
					while (!prs->eof) {
						strOldValue += AdoFldString(prs, "Username") + ", ";
						prs->MoveNext();
					}
					if (strOldValue.GetLength() > 0) { strOldValue = strOldValue.Left( strOldValue.GetLength() - 2 ); }
					prs = prs->NextRecordset(NULL);
					strNewValue.Empty();
					while (!prs->eof) {
						strNewValue += AdoFldString(prs, "Username") + ", ";
						prs->MoveNext();
					}
					if (strNewValue.GetLength() > 0) { strNewValue = strNewValue.Left( strNewValue.GetLength() - 2 ); }
					prs->Close();
					if(nAuditTransactionID == -1) nAuditTransactionID = BeginAuditTransaction();
					AuditEvent(-1, "", nAuditTransactionID, aeiEMRActionTodoAssignees, (strSourceID == "@nEMRInfoID") ? m_nID : atoi(strSourceID), "Item: " + strName + ".   Action: " + strAction + ".   Value: " + strOldValue, strNewValue, aepLow, aetChanged);
				}
				if (acCurrent.nTodoPriority != acOld.nTodoPriority) {
					switch (acOld.nTodoPriority) {
					case 1: strOldValue = "High"; break;
					case 2: strOldValue = "Medium"; break;
					case 3: strOldValue = "Low"; break;
					default: 
						ASSERT(FALSE);
						strOldValue.Empty();
						break;
					}
					switch (acCurrent.nTodoPriority) {
					case 1: strNewValue = "High"; break;
					case 2: strNewValue = "Medium"; break;
					case 3: strNewValue = "Low"; break;
					default: 
						ASSERT(FALSE);
						strNewValue.Empty();
						break;
					}
					if(nAuditTransactionID == -1) nAuditTransactionID = BeginAuditTransaction();
					AuditEvent(-1, "", nAuditTransactionID, aeiEMRActionTodoPriority, (strSourceID == "@nEMRInfoID") ? m_nID : atoi(strSourceID), "Item: " + strName + ".   Action: " + strAction + ".   Value: " + strOldValue, strNewValue, aepLow, aetChanged);
				}
				if (acCurrent.nTodoRemindType != acOld.nTodoRemindType ||
					acCurrent.nTodoRemindInterval != acOld.nTodoRemindInterval)
				{
					switch (acOld.nTodoRemindType) {
					case -1: strOldValue = "Immediate"; break;
					case 0: strOldValue = FormatString("%d day(s)", acOld.nTodoRemindInterval); break;
					case 1: strOldValue = FormatString("%d week(s)", acOld.nTodoRemindInterval); break;
					case 2: strOldValue = FormatString("%d month(s)", acOld.nTodoRemindInterval); break;
					case 3: strOldValue = FormatString("%d year(s)", acOld.nTodoRemindInterval); break;
					default: ASSERT(FALSE); strOldValue.Empty(); break;
					}
					switch (acCurrent.nTodoRemindType) {
					case -1: strNewValue = "Immediate"; break;
					case 0: strNewValue = FormatString("%d day(s)", acCurrent.nTodoRemindInterval); break;
					case 1: strNewValue = FormatString("%d week(s)", acCurrent.nTodoRemindInterval); break;
					case 2: strNewValue = FormatString("%d month(s)", acCurrent.nTodoRemindInterval); break;
					case 3: strNewValue = FormatString("%d year(s)", acCurrent.nTodoRemindInterval); break;
					default: ASSERT(FALSE); strNewValue.Empty(); break;
					}
					if(nAuditTransactionID == -1) nAuditTransactionID = BeginAuditTransaction();
					AuditEvent(-1, "", nAuditTransactionID, aeiEMRActionTodoRemindDuration, (strSourceID == "@nEMRInfoID") ? m_nID : atoi(strSourceID), "Item: " + strName + ".   Action: " + strAction + ".   Value: " + strOldValue, strNewValue, aepLow, aetChanged);
				}
				if (acCurrent.nTodoDeadlineType != acOld.nTodoDeadlineType ||
					acCurrent.nTodoDeadlineInterval != acOld.nTodoDeadlineInterval)
				{
					switch (acOld.nTodoDeadlineType) {
					case -1: strOldValue = "Immediate"; break;
					case 0: strOldValue = FormatString("%d day(s)", acOld.nTodoDeadlineInterval); break;
					case 1: strOldValue = FormatString("%d week(s)", acOld.nTodoDeadlineInterval); break;
					case 2: strOldValue = FormatString("%d month(s)", acOld.nTodoDeadlineInterval); break;
					case 3: strOldValue = FormatString("%d year(s)", acOld.nTodoDeadlineInterval); break;
					default: ASSERT(FALSE); strOldValue.Empty(); break;
					}
					switch (acCurrent.nTodoDeadlineType) {
					case -1: strNewValue = "Immediate"; break;
					case 0: strNewValue = FormatString("%d day(s)", acCurrent.nTodoDeadlineInterval); break;
					case 1: strNewValue = FormatString("%d week(s)", acCurrent.nTodoDeadlineInterval); break;
					case 2: strNewValue = FormatString("%d month(s)", acCurrent.nTodoDeadlineInterval); break;
					case 3: strNewValue = FormatString("%d year(s)", acCurrent.nTodoDeadlineInterval); break;
					default: ASSERT(FALSE); strNewValue.Empty(); break;
					}
					if(nAuditTransactionID == -1) nAuditTransactionID = BeginAuditTransaction();
					AuditEvent(-1, "", nAuditTransactionID, aeiEMRActionTodoDeadlineDuration, (strSourceID == "@nEMRInfoID") ? m_nID : atoi(strSourceID), "Item: " + strName + ".   Action: " + strAction + ".   Value: " + strOldValue, strNewValue, aepLow, aetChanged);
				}
				// (c.haag 2008-07-18 09:04) - PLID 30724 - Audit changes to the EMRProblemActions table.
				// To do this, we need to figure out which actions were added, which were removed, and which
				// had changed.
				CProblemActionAry aCreated, aDeleted, aModified;
				GetEmrActionProblemDiffs(acOld, acCurrent, aCreated, aDeleted, aModified);
				// (a.walling 2014-07-01 15:28) - PLID 62697
				for (const EmrProblemAction& prob : aCreated) {
					CString strNewValue = GetProblemActionAuditString(acCurrent, prob);
					if(nAuditTransactionID == -1) nAuditTransactionID = BeginAuditTransaction();
					AuditEvent(-1, "", nAuditTransactionID, aeiEMRProblemActionCreated, (strSourceID == "@nEMRInfoID") ? m_nID : atoi(strSourceID), "Item: " + strName + ".   Action: " + strAction + ".", strNewValue, aepLow, aetCreated);
				}
				for (const EmrProblemAction& prob : aDeleted) {
					CString strOldValue = GetProblemActionAuditString(acOld, prob);
					CString strNewValue = "<deleted>";
					if(nAuditTransactionID == -1) nAuditTransactionID = BeginAuditTransaction();
					AuditEvent(-1, "", nAuditTransactionID, aeiEMRProblemActionDeleted, (strSourceID == "@nEMRInfoID") ? m_nID : atoi(strSourceID), "Item: " + strName + ".   Action: " + strAction + ".   Value: " + strOldValue, strNewValue, aepLow, aetDeleted);
				}
				for (const EmrProblemAction& probCurrent : aModified) {
					// Get the old value
					for (const EmrProblemAction& probOld : acOld.aProblemActions) {
						if (probCurrent.nID == probOld.nID) {
							// Found the old value
							if (probCurrent.bSpawnToSourceItem != probOld.bSpawnToSourceItem) {
								CString strOldValue = GetEmrActionObjectName(probOld.bSpawnToSourceItem ? acOld.eaoSourceType : acOld.eaoDestType, TRUE);
								CString strNewValue = GetEmrActionObjectName(probCurrent.bSpawnToSourceItem ? acCurrent.eaoSourceType : acCurrent.eaoDestType, TRUE);
								if (strOldValue != strNewValue) {
									if(nAuditTransactionID == -1) nAuditTransactionID = BeginAuditTransaction();
									AuditEvent(-1, "", nAuditTransactionID, aeiEMRProblemActionSpawnToSourceItem, (strSourceID == "@nEMRInfoID") ? m_nID : atoi(strSourceID), "Item: " + strName + ".   Action: " + strAction + ".   Value: " + strOldValue, strNewValue, aepLow, aetChanged);
								}
							}
							if (probCurrent.strDescription != probOld.strDescription) {
								CString strOldValue = probOld.strDescription;
								CString strNewValue = probCurrent.strDescription;
								if(nAuditTransactionID == -1) nAuditTransactionID = BeginAuditTransaction();
								AuditEvent(-1, "", nAuditTransactionID, aeiEMRProblemActionDescription, (strSourceID == "@nEMRInfoID") ? m_nID : atoi(strSourceID), "Item: " + strName + ".   Action: " + strAction + ".   Value: " + strOldValue, strNewValue, aepLow, aetChanged);
							}
							if (probCurrent.nStatus != probOld.nStatus) {
								_RecordsetPtr prsStatus = CreateRecordset("SELECT ID, Name FROM EMRProblemStatusT WHERE ID IN (%d,%d)", probOld.nStatus, probCurrent.nStatus);
								FieldsPtr f = prsStatus->Fields;
								CString strOldValue, strNewValue;
								while (!prsStatus->eof) {
									long nID = AdoFldLong(f, "ID");
									if (nID == probOld.nStatus) {
										strOldValue = AdoFldString(f, "Name");
									} else if (nID == probCurrent.nStatus) {
										strNewValue = AdoFldString(f, "Name");
									}
									prsStatus->MoveNext();
								}
								prsStatus->Close();
								if(nAuditTransactionID == -1) nAuditTransactionID = BeginAuditTransaction();
								AuditEvent(-1, "", nAuditTransactionID, aeiEMRProblemActionStatus, (strSourceID == "@nEMRInfoID") ? m_nID : atoi(strSourceID), "Item: " + strName + ".   Action: " + strAction + ".   Value: " + strOldValue, strNewValue, aepLow, aetChanged);
							}
							// (c.haag 2014-07-23) - PLID 62789 - EMR problem action SNOMED code
							if (probCurrent.nSNOMEDCodeID != probOld.nSNOMEDCodeID)
							{
								_RecordsetPtr prs = CreateRecordset("SELECT ID, Code + '  ' + Name AS Name FROM CodesT WHERE ID IN (%d,%d)", probOld.nSNOMEDCodeID, probCurrent.nSNOMEDCodeID);
								FieldsPtr f = prs->Fields;
								CString strOldValue, strNewValue;
								while (!prs->eof) {
									long nID = AdoFldLong(f, "ID");
									if (nID == probOld.nSNOMEDCodeID) {
										strOldValue = AdoFldString(f, "Name");
									}
									else if (nID == probCurrent.nSNOMEDCodeID) {
										strNewValue = AdoFldString(f, "Name");
									}
									prs->MoveNext();
								}
								prs->Close();
								if (nAuditTransactionID == -1) nAuditTransactionID = BeginAuditTransaction();
								AuditEvent(-1, "", nAuditTransactionID, aeiEMRProblemActionSNOMEDCode, (strSourceID == "@nEMRInfoID") ? m_nID : atoi(strSourceID), "Item: " + strName + ".   Action: " + strAction + ".   Value: " + strOldValue, strNewValue, aepLow, aetChanged);
							}

							// (s.tullis 2015-03-05 15:06) - PLID 64724 
							if (probCurrent.bDoNotShowOnCCDA != probOld.bDoNotShowOnCCDA)
							{
								CString strOldValue, strNewValue;
								strOldValue = probOld.bDoNotShowOnCCDA ? "Checked" : "Unchecked";
								strNewValue = probCurrent.bDoNotShowOnCCDA ? "Checked" : "Unchecked";
								if (nAuditTransactionID == -1) nAuditTransactionID = BeginAuditTransaction();
								AuditEvent(-1, "", nAuditTransactionID, aeiEMRProblemActionDoNotShowOnCCDA, (strSourceID == "@nEMRInfoID") ? m_nID : atoi(strSourceID), "Item: " + strName + ".   Action: " + strAction + ".   Value: " + strOldValue, strNewValue, aepLow, aetChanged);
							}

							// (r.gonet 2015-03-10 14:48) - PLID 65013 - Audit if the DoNotShowOnProblemPrompt value has changed.
							if (probCurrent.bDoNotShowOnProblemPrompt != probOld.bDoNotShowOnProblemPrompt) {
								CString strOldValue, strNewValue;
								strOldValue = probOld.bDoNotShowOnProblemPrompt ? "Checked" : "Unchecked";
								strNewValue = probCurrent.bDoNotShowOnProblemPrompt ? "Checked" : "Unchecked";
								if (nAuditTransactionID == -1) {
									nAuditTransactionID = BeginAuditTransaction();
								}
								AuditEvent(-1, "", nAuditTransactionID, aeiEMRProblemActionDoNotShowOnProblemPrompt, (strSourceID == "@nEMRInfoID") ? m_nID : atoi(strSourceID), "Item: " + strName + ".   Action: " + strAction + ".   Value: " + strOldValue, strNewValue, aepLow, aetChanged);
							}

							// ADD ANY ADDITIONAL AUDITS ABOVE THE BREAK.
							break;
						}
					}
				}

			} // if (bAudit) {

		} // for(int nCnt = 0; nCnt < arActionsToUpdate.GetSize(); nCnt++) {

	}
	if (arActionsToAdd.GetSize() > 0) {
		bAns = TRUE;

		//DRT 1/10/2007 - PLID 24181 - I am removing the XML-based saving for newly added actions.  There is a hole left here in the
		//	saving from the start that I need to fill.  The way this entire ItemEntryDlg is designed, when you save new actions, it
		//	is impossible to back-fill the m_arActions array(s).  So once this code is executed, you must close the dialog and reopen it.
		//I am changing the saving because I need access to those IDs.  This will be a slight speed hit, but should be minimal.  This
		//	also allows us the option on the future of adding an "Apply" button.

		//Old Code for saving (EMRActionsT only)
		/*AddStatementToSqlBatch(strSqlBatch, 
			"EXEC sp_xml_preparedocument @hDoc OUTPUT, N'%s'; "
			"INSERT INTO EmrActionsT (SourceType, SourceID, DestType, DestID, SortOrder, Popup, SpawnAsChild) "
			" SELECT %li, %s, DestType, DestID, SortOrder, Popup, SpawnAsChild FROM OPENXML(@hDoc, '/ROOT/A') WITH (ID INT, DestType INT, DestID INT, SortOrder INT, Popup BIT, SpawnAsChild BIT); "
			"EXEC sp_xml_removedocument @hDoc;", GenerateXMLFromActionArray(arActionsToAdd), nSourceType, strSourceID);*/

		//New Implementation
		for(int nCnt = 0; nCnt < arActionsToAdd.GetSize(); nCnt++) {
			CString str;

			EmrAction acSave = arActionsToAdd.GetAt(nCnt);

			//Modifier data
			CString strMod1, strMod2, strMod3, strMod4;
			if(acSave.strMod1.IsEmpty()) {	strMod1 = "NULL";	}	else {	strMod1.Format("'%s'", acSave.strMod1);	}
			if(acSave.strMod2.IsEmpty()) {	strMod2 = "NULL";	}	else {	strMod2.Format("'%s'", acSave.strMod2);	}
			if(acSave.strMod3.IsEmpty()) {	strMod3 = "NULL";	}	else {	strMod3.Format("'%s'", acSave.strMod3);	}
			if(acSave.strMod4.IsEmpty()) {	strMod4 = "NULL";	}	else {	strMod4.Format("'%s'", acSave.strMod4);	}


			//
			// (c.haag 2007-03-05 10:27) - PLID 23943 - Audit the addition of the action if this is not a new item
			// (c.haag 2015-07-07) - PLID 65572 - Moved the block of code here so that we guarantee the creation
			// of the action is always audited first
			//
			if (-1 != m_nID) {
				// Build a string that looks like "Added spawning of X to Y"
				CString strSourceTypeText = GetAuditSourceTypeText((EmrActionObject)nSourceType, strSourceID);
				CString strDestTypeText = GetAuditDestTypeText(acSave.eaoDestType, acSave.nDestID);
				CString strNewValue = CString("Added spawning of ") + strDestTypeText + " to the " + strSourceTypeText;
				if (nAuditTransactionID == -1) nAuditTransactionID = BeginAuditTransaction();
				AuditEvent(-1, "", nAuditTransactionID, aeiEMRActionAdded, (strSourceID == "@nEMRInfoID") ? m_nID : atoi(strSourceID), "Item: " + strName, strNewValue, aepMedium, aetCreated);
			} // if (-1 != m_nID)

			//Generate an insert for EMRActionsT
			// (c.haag 2008-06-04 10:25) - PLID 30221 - Assign @ActionID
			str.Format("INSERT INTO EmrActionsT (SourceType, SourceID, DestType, DestID, SortOrder, Popup, SpawnAsChild) "
				" (SELECT %li, %s, %li, %li, %li, %li, %li); \r\nSET @ActionID = SCOPE_IDENTITY();\r\n", nSourceType, strSourceID, acSave.eaoDestType, acSave.nDestID, 
				acSave.nSortOrder, acSave.bPopup ? 1 : 0, acSave.bSpawnAsChild ? 1 : 0);
			AddStatementToSqlBatch(strSqlBatch, str);

			//Generate an insert for EMRActionChargeDataT - Use @@identity to get the ID of the action.  Only if this is a cpt charge
			if(acSave.eaoDestType == eaoCpt) {
				str.Format("INSERT INTO EmrActionChargeDataT (ActionID, Prompt, DefaultQuantity, Modifier1Number, Modifier2Number, Modifier3Number, Modifier4Number) "
					" (SELECT @@identity, %li, %g, %s, %s, %s, %s);\r\n ", acSave.bPrompt ? 1 : 0, 
					acSave.dblDefaultQuantity, strMod1, strMod2, strMod3, strMod4);

				AddStatementToSqlBatch(strSqlBatch, str);
			}
			// (c.haag 2008-06-04 10:23) - PLID 30221 - Support for todo actions
			else if(acSave.eaoDestType == eaoTodo) {

				str.Format("INSERT INTO EMRActionsTodoDataT "
					"(ActionID, RemindType, RemindInterval, DeadlineType, DeadlineInterval, "
					"Notes, Priority, Task, CategoryID) "
					"VALUES "
					"(@ActionID, %d, %d, %d, %d, "
					"'%s', %d, '%s', %s)",
					acSave.nTodoRemindType, acSave.nTodoRemindInterval,
					acSave.nTodoDeadlineType, acSave.nTodoDeadlineInterval,
					_Q(acSave.strTodoNotes), acSave.nTodoPriority, 	_Q(acSave.strTodoMethod), 
					(acSave.nTodoCategoryID <= 0) ? "NULL" : AsString(acSave.nTodoCategoryID));

				AddStatementToSqlBatch(strSqlBatch, str);

				for (long assignTo : acSave.anTodoAssignTo) {
					str.Format("INSERT INTO EMRActionsTodoAssignToT (ActionID, AssignTo) "
						"VALUES (@ActionID, %d)", assignTo);
					AddStatementToSqlBatch(strSqlBatch, str);
				}
			}				
			// (b.savon 2014-07-16 09:20) - PLID 62707 - Handle saving the new Diagnosis DestType action to EmrActionsT and EmrActionsDiagnosisDataT
			//(s.dhole 7/17/2014 4:45 PM ) - PLID 62724 
			else if (acSave.eaoDestType == eaoDiagnosis){
				AddStatementToSqlBatch(
					strSqlBatch,
					R"(
						INSERT INTO EMRActionDiagnosisDataT (EmrActionID, DiagCodeID_ICD9, DiagCodeID_ICD10)
						VALUES (@ActionID, %s, %s)
						)",
						(acSave.diaDiagnosis.nDiagCodeID_ICD9 == -1 ? "NULL": AsStringForSql(acSave.diaDiagnosis.nDiagCodeID_ICD9)),
						(acSave.diaDiagnosis.nDiagCodeID_ICD10 == -1 ? "NULL": AsStringForSql(acSave.diaDiagnosis.nDiagCodeID_ICD10))
						);
			}
			// (c.haag 2008-07-17 16:37) - PLID 30724 - Support for EMR problem actions
			// (c.haag 2014-07-22) - PLID 62789 - Added SNOMEDCodeID
			// (s.tullis 2015-02-23 17:47) - PLID 64749 
			// (r.gonet 2015-03-10 14:48) - PLID 65013 - Added DoNotShowOnProblemPrompt.
			for (const EmrProblemAction& epa : acSave.aProblemActions) 
			{
				// (c.haag 2015-07-07) - PLID 65572 - Audit the problem actions if this is not a new EMR item
				if (-1 != m_nID)
				{
					CString strSourceTypeText = GetAuditSourceTypeText((EmrActionObject)nSourceType, strSourceID);
					CString strDestTypeText = GetAuditDestTypeText(acSave.eaoDestType, acSave.nDestID);
					CString strAction = CString("Spawning of ") + strDestTypeText + " for the " + strSourceTypeText;
					CString strNewValue = GetProblemActionAuditString(acSave, epa);
					if (nAuditTransactionID == -1) nAuditTransactionID = BeginAuditTransaction();
					AuditEvent(-1, "", nAuditTransactionID, aeiEMRProblemActionCreated, (strSourceID == "@nEMRInfoID") ? m_nID : atoi(strSourceID), "Item: " + strName + ".   Action: " + strAction + ".", strNewValue, aepLow, aetCreated);
				}

				str.Format("INSERT INTO EmrProblemActionsT "
					"(EmrActionID, DefaultDescription, DefaultStatus, SpawnToSourceItem, SNOMEDCodeID, DoNotShowOnCCDA, DoNotShowOnProblemPrompt) "
					"VALUES "
					"(@ActionID, '%s', %d, convert(bit,%d), %s, %li, %li)"
					, _Q(epa.strDescription), epa.nStatus, (epa.bSpawnToSourceItem ? 1 : 0), epa.GetSNOMEDValueForSQL(), epa.bDoNotShowOnCCDA, epa.bDoNotShowOnProblemPrompt);
				AddStatementToSqlBatch(strSqlBatch, str);				
			}

		} // for(int nCnt = 0; nCnt < arActionsToAdd.GetSize(); nCnt++) {
	} // if (arActionsToAdd.GetSize() > 0) {
	return bAns;
}

// (j.jones 2006-12-21 10:44) - PLID 22189 - added more thorough auditing so now all changes to an item are audited
BOOL CEmrItemEntryDlg::Apply()
{
	// Build a single update string as we go through each piece of data that could be 
	// saved, grabbing only those things that have changed from their load state.

	long nCurDataType;

	g_nLastTableDropDownIndex = 0;

	// (j.jones 2007-08-15 09:02) - PLID 27053 - add E/M Code Type
	EMCodingTypes emctCurEMCodingType = emctUndefined;
	BOOL bCurUseEMCoding = FALSE;

	// (j.jones 2007-08-14 16:58) - PLID 27052 - added E/M Category
	long nCurEMCodeCategoryID = -1;
	// (j.jones 2011-03-08 12:25) - PLID 42282 - added eEMCodeUseTableCategories
	EMCodeUseTableCategories eCurEMCodeUseTableCategories = emcutcNone;
	// (a.walling 2009-05-28 15:36) - PLID 34389	
	long nCurrentEmrDataCodeID = -1;
	// (z.manning 2010-02-09 15:25) - PLID 37228
	BOOL bCurrentEnableSmartStamps = (m_btnEnableSmartStamps.GetCheck() == BST_CHECKED);
	_variant_t varCurrentSmartStampTableMasterID = g_cvarNull;
	if(m_pdlSmartStampTable->GetCurSel() != NULL) {
		varCurrentSmartStampTableMasterID = m_pdlSmartStampTable->GetCurSel()->GetValue(sstcMasterID);
	}

	// (a.walling 2008-06-30 17:23) - PLID 30570
	// (b.cardillo 2012-03-06 15:46) - PLID 48666 - Initialize to the previous value and then set/clear known bits.
	DWORD nPreviewFlags = m_nPreviewFlags;
	long nInfoFlags = m_nInfoFlags;

	//TES 3/11/2011 - PLID 42757 - Added Glasses Order data
	BOOL bCurHasGlassesOrderData = FALSE;
	GlassesOrderLens CurGlassesOrderLens = golInvalid;

	// (r.gonet 08/03/2012) - PLID 51735
	BOOL bCurUseWithWoundCareCoding = FALSE;

	// (j.jones 2006-09-11 09:52) - PLID 22284 - compressed what was once more booleans into just two:
	// bSomethingCriticalChanged means something changed that we can't change on a locked or saved EMN item
	// which is to say, virtually everything on the screen
	// bSomethingMinorChanged means something so minor change that we can even change it when the item is used
	// on a locked or saved EMN, really this only means the Inactive status
	// (j.jones 2007-08-15 14:10) - PLID 27053 - added E/M coding information to EMRInfoMasterT and EMRDataGroupsT,
	// both of which do not negatively affect saved EMNs and thus are only minor
	BOOL bSomethingCriticalChanged = FALSE;
	BOOL bSomethingMinorChanged = FALSE;

	long nAuditTransactionID = -1;

	CString strBatchSql = BeginSqlBatch();

	AddDeclarationToSqlBatch(strBatchSql, 
		"DECLARE @hDoc INT; "
		"DECLARE @nEMRInfoID INT; "
		"DECLARE @nEMRInfoMasterID INT; "
		// (c.haag 2008-06-03 11:14) - PLID 30221 - We need to preserve the Action ID through multiple inserts
		"DECLARE @ActionID INT; "
		// (j.dinatale 2010-10-20) - PLID 31160 - Used in multiple inserts and its possible for two of those inserts to happen in the same query, so just declare it up here
		//		and let the inserts use it as they wish
		"DECLARE @nEMRActionBase INT; "
		);

	// Add the string that will set our local variable (in the sql batch) to be the 
	// official ID of the emr item for use later in the batch.  Also decide if this 
	// is a new item or an existing one
	//TES 12/6/2006 - PLID 23724 - Added analogous handling for the EmrInfoMasterT record which we are either creating or updating.
	BOOL bIsNew;
	BOOL bIsNewMaster;
	{
		if(m_nEmrInfoMasterID == -1) {
			bIsNewMaster = TRUE;
			AddStatementToSqlBatch(strBatchSql, "INSERT INTO EmrInfoMasterT (ActiveEmrInfoID) VALUES (NULL); "
				"SET @nEMRInfoMasterID = SCOPE_IDENTITY(); ");
		}
		else {
			bIsNewMaster = FALSE;
			AddStatementToSqlBatch(strBatchSql, "SET @nEMRInfoMasterID = %li; ", m_nEmrInfoMasterID);
		}

		if (m_nID == -1) {
			// It's new, so have the batch generate a new ID
			bIsNew = TRUE;
		} else {
			// It's not new so use the known ID
			bIsNew = FALSE;
			AddStatementToSqlBatch(strBatchSql, "SET @nEMRInfoID = %li; ", m_nID);

			
			if (m_nOriginalInfoID == -1) {
				m_nOriginalInfoID = m_nID;
			}
			// (a.walling 2009-06-30 15:32) - PLID 34759 - Fail if this item has already been updated since we opened this dialog. If we are not making a copy,
			// there is no corruption.
			// (a.walling 2011-01-19 10:48) - PLID 34813 - Rollback and return if calling RAISERROR
			if (m_nEmrInfoMasterID != -1 && m_nOriginalInfoID != -1) {
				AddStatementToSqlBatch(strBatchSql, "IF %li <> (SELECT ActiveEmrInfoID FROM EmrInfoMasterT WHERE ID = %li) BEGIN RAISERROR('Item is out of date', 16, 41) ROLLBACK TRAN RETURN END; ", m_nOriginalInfoID, m_nEmrInfoMasterID);
			}

			// (a.walling 2013-03-27 09:47) - PLID 55898 - Update EmrInfoT.ModifiedDate (and vicariously, the .Revision rowversion)
			AddStatementToSqlBatch(strBatchSql, 
				"IF NOT EXISTS("
					"SELECT EMRDetailsT.EmrInfoID FROM EMRDetailsT "
					"INNER JOIN EMRInfoT ON EMRDetailsT.EMRInfoID = EMRInfoT.ID AND EMRDetailsT.EMRInfoID = @nEMRInfoID "
					"INNER JOIN EMRMasterT ON EMRDetailsT.EMRID = EMRMasterT.ID "
					"WHERE EMRDetailsT.Deleted = 0 AND EMRMasterT.Deleted = 0 "
				") "
				"UPDATE EMRInfoT SET ModifiedDate = GETDATE() WHERE ID = @nEMRInfoID"
			);
		}
	}

	// Two synchronized arrays, one to track the field names we're using, the other for 
	// the corresponding formatted value to be placed into that field
	CStringArray arystrFields, arystrValues;
	//TES 12/13/2006 - PLID 23792 - We also have to track the fields we're changing in EmrInfoMasterT
	CStringArray arystrMasterFields, arystrMasterValues;

	CString strName;
	GetDlgItemText(IDC_ITEM_NAME, strName);
	strName.TrimRight();
	strName.TrimLeft();

	// First deal with all the EMRInfoT fields, because we can generate one statement to 
	// set those (whether we're talking an INSERT or an UPDATE)
	{
		// The name of the emr item
		{			
			if (bIsNew || strName != m_strName) {
				arystrFields.Add("Name");
				arystrValues.Add("'" + _Q(strName) + "'");
				bSomethingCriticalChanged = TRUE;

				if(!bIsNew) {
					if(nAuditTransactionID == -1)
						nAuditTransactionID = BeginAuditTransaction();
					AuditEvent(-1, "", nAuditTransactionID, aeiEMRItemNameChanged, m_nID, m_strName, strName, aepHigh, aetChanged);
				}
			}
		}

		// The one-per-emn status of the emr item
		if ((m_bOnePerEmn && !IsDlgButtonChecked(IDC_CHECK_ONE_PER_EMN)) ||
			(!m_bOnePerEmn && IsDlgButtonChecked(IDC_CHECK_ONE_PER_EMN)))
		{
			CString str = (IsDlgButtonChecked(IDC_CHECK_ONE_PER_EMN)) ? "1" : "0";
			arystrFields.Add("OnePerEmn");
			arystrValues.Add(_Q(str));

			if(!bIsNew) {
				if(nAuditTransactionID == -1)
					nAuditTransactionID = BeginAuditTransaction();
				CString strOldValue, strNewValue;
				if(m_bOnePerEmn)
					strOldValue = "Enabled for " + strName;
				else 
					strOldValue = "Disabled for " + strName;
				if(IsDlgButtonChecked(IDC_CHECK_ONE_PER_EMN))
					strNewValue = "Enabled for " + strName;
				else 
					strNewValue = "Disabled for " + strName;
				AuditEvent(-1, "", nAuditTransactionID, aeiEMRItemOnePerEMN, m_nID, strOldValue, strNewValue, aepLow, aetChanged);
			}
		}

		if ((m_bInactive && !IsDlgButtonChecked(IDC_CHECK_EMRINFO_INACTIVE)) ||
			(!m_bInactive && IsDlgButtonChecked(IDC_CHECK_EMRINFO_INACTIVE)))
		{
			CString str = (IsDlgButtonChecked(IDC_CHECK_EMRINFO_INACTIVE)) ? "1" : "0";
			arystrMasterFields.Add("Inactive");
			arystrMasterValues.Add(_Q(str));

			CString strOldValue, strNewValue;
			if(m_bInactive)
				strOldValue = strName + ": Inactive";
			else
				strOldValue = strName + ": Active";

			if(IsDlgButtonChecked(IDC_CHECK_EMRINFO_INACTIVE))
				strNewValue = strName + ": Inactive";
			else
				strNewValue = strName + ": Active";

			bSomethingMinorChanged = TRUE;

			if(!bIsNew) {
				if(nAuditTransactionID == -1)
					nAuditTransactionID = BeginAuditTransaction();
				AuditEvent(-1, "", nAuditTransactionID, aeiEMRItemInactive, m_nID, strOldValue, strNewValue, aepMedium, aetChanged);
			}
		}
		
		// The data type		
		{
			//for auditing
			CString strNewDataType, strOldDataType;

			if (IsDlgButtonChecked(IDC_RADIO_TEXT_SELECT)) {
				nCurDataType = 1;
				strNewDataType = "Text";
			} else if (IsDlgButtonChecked(IDC_RADIO_LIST_SELECT)) {
				nCurDataType = 2;
				strNewDataType = "Single-Select List";
			} else if (IsDlgButtonChecked(IDC_RADIO_LIST_MULTISELECT)) {
				nCurDataType = 3;
				strNewDataType = "Multi-Select List";
			} else if (IsDlgButtonChecked(IDC_RADIO_IMAGE)) {
				nCurDataType = 4;
				strNewDataType = "Image";
			} else if (IsDlgButtonChecked(IDC_RADIO_SLIDER)) {
				nCurDataType = 5;
				strNewDataType = "Slider";
			} else if (IsDlgButtonChecked(IDC_RADIO_NARRATIVE)) {
				nCurDataType = 6;
				strNewDataType = "Narrative";
			} else if (IsDlgButtonChecked(IDC_RADIO_TABLE)) {
				nCurDataType = 7;
				strNewDataType = "Table";
			} else {
				ThrowNxException("Could not determine currently selected data type!");
			}

			// (a.walling 2008-01-18 13:22) - PLID 14982 - Final guard to ensure user cannot change item type
			if (m_bPreventTypeChange && nCurDataType != m_nDataType) {
				ThrowNxException("Attempted to change item type while disabled!");
			}

			if (bIsNew || nCurDataType != m_nDataType) {
				if(!bIsNew) {
					if(nCurDataType == 4) {
						//TES 9/8/05 - They're not allowed to export images, so delete any stored export fields that use this.
						AddStatementToSqlBatch(strBatchSql, "DELETE FROM ExportFieldsT WHERE FieldID = 480 AND DynamicID = %li", m_nID);
						// (j.jones 2008-10-22 17:32) - PLID 31692 - delete any EMR Analysis details that reference the master item,
						// but do not delete their master records, even if there are no details left in them
						AddStatementToSqlBatch(strBatchSql, "DELETE FROM EMRAnalysisConfigDetailsT WHERE EMRInfoMasterID IN (SELECT EMRInfoMasterID FROM EMRInfoT WHERE ID = %li)", m_nID);
					}
					// (j.jones 2008-10-22 17:32) - PLID 31692 - Delete any EMR Analysis details that reference the master item,
					// if the detail references data items, unless we are switching to a list type, and not also switching from a table type
					// Do not delete their master records, even if there are no details left in them.
					else if((nCurDataType != 2 && nCurDataType != 3) || m_nDataType == 7) {
						AddStatementToSqlBatch(strBatchSql, "DELETE FROM EMRAnalysisConfigDetailsT "
							"WHERE EMRInfoMasterID IN (SELECT EMRInfoMasterID FROM EMRInfoT WHERE ID = %li) "
							"AND EMRDataGroupID Is Not Null", m_nID);
					}
				}
				arystrFields.Add("DataType");
				arystrValues.Add(AsString((long)nCurDataType));

				if(!bIsNew) {
					//for auditing
					switch(m_nDataType) {
					case 1:
						strOldDataType = "Text";
						break;
					case 2:
						strOldDataType = "Single-Select List";
						break;
					case 3:
						strOldDataType = "Multi-Select List";
						break;
					case 4:
						strOldDataType = "Image";
						break;
					case 5:
						strOldDataType = "Slider";
						break;
					case 6:
						strOldDataType = "Narrative";
						break;
					case 7:
						strOldDataType = "Table";
						break;
					}

					strOldDataType = strName + ": " + strOldDataType;
					strNewDataType = strName + ": " + strNewDataType;

					if(nAuditTransactionID == -1)
						nAuditTransactionID = BeginAuditTransaction();
					AuditEvent(-1, "", nAuditTransactionID, aeiEMRItemDataType, m_nID, strOldDataType, strNewDataType, aepHigh, aetChanged);
				}
			}
		}

		// (z.manning 2011-07-22 11:14) - PLID 44676 - We need to handle DataSubType.
		{
			EmrInfoSubType eCurSubType = m_DataSubType;
			if(nCurDataType == eitImage)
			{
				if(IsDlgButtonChecked(IDC_USE_SELECTED_3DIMAGE) == BST_CHECKED) {
					eCurSubType = eist3DImage;
				}
				else {
					eCurSubType = eistNone;
				}
			}

			if(bIsNew || eCurSubType != m_DataSubType) {
				arystrFields.Add("DataSubType");
				arystrValues.Add(AsString((long)eCurSubType));
			}
		}

		// RememberForPatient
		{
			// (c.haag 2007-02-06 11:12) - PLID 24423 - The "Remember this item's value" for the Current Medications
			// table is always 0 in data. We check the button to show the user that it will be remembered -- but internally,
			// we just don't remember it in the same way
			// (c.haag 2007-04-03 09:27) - PLID 25468 - Same with patient allergies
			BOOL bRememberForPatient = (IsDlgButtonChecked(IDC_REMEMBER_FOR_PATIENT) && eistCurrentMedicationsTable != m_DataSubType && eistAllergiesTable != m_DataSubType) ? TRUE : FALSE;

			if (bIsNew || (bRememberForPatient && !m_bRememberForPatient) || (!bRememberForPatient && m_bRememberForPatient)) {
				arystrFields.Add("RememberForPatient");
				arystrValues.Add(bRememberForPatient ? "1" : "0");

				if(!bIsNew) {
					if(nAuditTransactionID == -1)
						nAuditTransactionID = BeginAuditTransaction();
					CString strOldValue, strNewValue;
					if(m_bRememberForPatient)
						strOldValue = "Enabled for " + strName;
					else 
						strOldValue = "Disabled for " + strName;
					if(bRememberForPatient)
						strNewValue = "Enabled for " + strName;
					else 
						strNewValue = "Disabled for " + strName;
					AuditEvent(-1, "", nAuditTransactionID, aeiEMRItemRememberForPatient, m_nID, strOldValue, strNewValue, aepLow, aetChanged);
				}
			}
		}
		
		// (j.jones 2008-09-22 13:04) - PLID 31476 - added "RememberForEMR"
		{
			//The "Remember this item's value per EMR" settings for the Current Medications and Allergies
			//table is always 0. Never save it if it is one of these settings.
			if(eistCurrentMedicationsTable != m_DataSubType && eistAllergiesTable != m_DataSubType) {

				BOOL bRememberForEMR = IsDlgButtonChecked(IDC_REMEMBER_FOR_EMR) ? TRUE : FALSE;

				if(bIsNew || (bRememberForEMR && !m_bRememberForEMR) || (!bRememberForEMR && m_bRememberForEMR)) {
					arystrFields.Add("RememberForEMR");
					arystrValues.Add(bRememberForEMR ? "1" : "0");

					if(!bIsNew) {
						if(nAuditTransactionID == -1) {
							nAuditTransactionID = BeginAuditTransaction();
						}
						CString strOldValue, strNewValue;
						if(m_bRememberForEMR) {
							strOldValue = "Enabled for " + strName;
						}
						else  {
							strOldValue = "Disabled for " + strName;
						}
						if(bRememberForEMR) {
							strNewValue = "Enabled for " + strName;
						}
						else {
							strNewValue = "Disabled for " + strName;
						}
						AuditEvent(-1, "", nAuditTransactionID, aeiEMRItemRememberForEMR, m_nID, strOldValue, strNewValue, aepLow, aetChanged);
					}
				}
			}
		}

		// (j.jones 2007-08-14 16:58) - PLID 27053 - added E/M Code Type		
		bCurUseEMCoding = IsDlgButtonChecked(IDC_CHECK_USE_FOR_EM_CODING);		
		
		//only store the coding type on multi-select lists and tables
		if(bCurUseEMCoding && (nCurDataType == 3 || nCurDataType == 7)) {
			NXDATALIST2Lib::IRowSettingsPtr pRow = m_pdlEMCodeTypeCombo->CurSel;
			if(pRow) {
				emctCurEMCodingType = (EMCodingTypes)VarLong(pRow->GetValue(0),emctUndefined);
			}
			else {
				//should not be allowed to get here, Validate() should have stopped us!
				ASSERT(FALSE);
				
				//but warn anyways, and get out
				AfxMessageBox("E/M Coding is enabled for this item, but no E/M Coding Type is selected.\n"
					"An E/M Code Type is required on all multi-select lists and tables that are configured to use E/M Coding.");
				//TES 10/28/2010 - PLID 41174 - Special logging
				if (IsSystemCurrentMedicationsItem()) {
					Log_CurrentMedicationsEdit("Returning FALSE due to EMCoding problem");
				}
				return FALSE;
			}
		}

		//UseEMCoding
		if(bCurUseEMCoding != m_bUseEMCoding) {

			arystrMasterFields.Add("UseEMCoding");
			arystrMasterValues.Add(bCurUseEMCoding ? "1" : "0");

			if(!bIsNew) {
				if(nAuditTransactionID == -1)
					nAuditTransactionID = BeginAuditTransaction();
				CString strOldValue, strNewValue;
				if(m_bUseEMCoding)
					strOldValue = "Enabled for " + strName;
				else 
					strOldValue = "Disabled for " + strName;
				if(bCurUseEMCoding)
					strNewValue = "Enabled for " + strName;
				else 
					strNewValue = "Disabled for " + strName;
				AuditEvent(-1, "", nAuditTransactionID, aeiEMRItemUseEMCoding, m_nID, strOldValue, strNewValue, aepMedium, aetChanged);
			}
		}

		//EMCodingType
		if(emctCurEMCodingType != m_emctEMCodingType) {

			arystrMasterFields.Add("EMCodingType");
			arystrMasterValues.Add(emctCurEMCodingType != emctUndefined ? AsString((long)emctCurEMCodingType) : "NULL");

			if(!bIsNew) {
				if(nAuditTransactionID == -1)
					nAuditTransactionID = BeginAuditTransaction();
				CString strOldValue, strNewValue;

				if(m_emctEMCodingType == emctUndefined) 
					strOldValue.Format("%s: <None>", strName);
				else
					strOldValue.Format("%s: %s", strName, GetEMCodeTypeName(m_emctEMCodingType));

				if(emctCurEMCodingType == emctUndefined) 
					strNewValue.Format("%s: <None>", strName);
				else
					strNewValue.Format("%s: %s", strName, GetEMCodeTypeName(emctCurEMCodingType));			

				AuditEvent(-1, "", nAuditTransactionID, aeiEMRItemEMCodingType, m_nID, strOldValue, strNewValue, aepMedium, aetChanged);
			}
		}

		// (j.jones 2007-08-14 16:58) - PLID 27052 - added E/M Category
		if(bCurUseEMCoding) {
			NXDATALIST2Lib::IRowSettingsPtr pRow = m_pdlEMCategoryCombo->CurSel;
			if(pRow) {
				nCurEMCodeCategoryID = VarLong(pRow->GetValue(emcccID),-1);
				// (j.jones 2011-03-08 12:25) - PLID 42282 - added m_eEMCodeUseTableCategories
				eCurEMCodeUseTableCategories = (EMCodeUseTableCategories)VarLong(pRow->GetValue(emcccUseTableCategories), (long)emcutcNone);
			}
			else {
				//should not be allowed to get here, Validate() should have stopped us!
				ASSERT(FALSE);
				
				//but warn anyways, and get out
				AfxMessageBox("E/M Coding is enabled for this item, but no E/M Category is selected.\n"
					"An E/M Category is required on all EMR items that are configured to use E/M Coding.");
				//TES 10/28/2010 - PLID 41174 - Special logging
				if (IsSystemCurrentMedicationsItem()) {
					Log_CurrentMedicationsEdit("Returning FALSE due to EM Coding problem (2)");
				}
				return FALSE;
			}
		}
		
		//EMCodeCategoryID
		// (j.jones 2011-03-08 12:25) - PLID 42282 - added m_eEMCodeUseTableCategories, which saves
		// as a separate field, but is audited as though it is one field
		if(nCurEMCodeCategoryID != m_nEMCodeCategoryID || eCurEMCodeUseTableCategories != m_eEMCodeUseTableCategories) {

			if(nCurEMCodeCategoryID != m_nEMCodeCategoryID) {

				arystrMasterFields.Add("EMCodeCategoryID");
				arystrMasterValues.Add(nCurEMCodeCategoryID != -1 ? AsString(nCurEMCodeCategoryID) : "NULL");
			}

			if(eCurEMCodeUseTableCategories != m_eEMCodeUseTableCategories) {

				arystrMasterFields.Add("EMCodeUseTableCategories");
				//non-nullable, the enum values are exactly what we save, including zero
				arystrMasterValues.Add(AsString((long)eCurEMCodeUseTableCategories));
			}

			if(!bIsNew) {

				if(nAuditTransactionID == -1) {
					nAuditTransactionID = BeginAuditTransaction();
				}
				CString strOldValue, strNewValue;
				
				//harvest the descriptions from the datalist
				if(m_nEMCodeCategoryID == -1) {

					if(m_eEMCodeUseTableCategories == emcutcPerRow) {
						strOldValue.Format("%s: <Configure Categories Per Row>", strName);
					}
					else if(m_eEMCodeUseTableCategories == emcutcPerColumn) {
						strOldValue.Format("%s: <Configure Categories Per Column>", strName);
					}
					else {
						strOldValue.Format("%s: <No Category>", strName);
					}
				}
				else {
					NXDATALIST2Lib::IRowSettingsPtr pRow = m_pdlEMCategoryCombo->FindByColumn(emcccID, (long)m_nEMCodeCategoryID, NULL, FALSE);
					if(pRow) {
						strOldValue.Format("%s: %s", strName, VarString(pRow->GetValue(emcccDesc), ""));
					}
					else {
						ASSERT(FALSE);
					}
				}

				if(nCurEMCodeCategoryID == -1) {

					if(eCurEMCodeUseTableCategories == emcutcPerRow) {
						strNewValue.Format("%s: <Configure Categories Per Row>", strName);
					}
					else if(eCurEMCodeUseTableCategories == emcutcPerColumn) {
						strNewValue.Format("%s: <Configure Categories Per Column>", strName);
					}
					else {
						strNewValue.Format("%s: <No Category>", strName);
					}
				}
				else {
					NXDATALIST2Lib::IRowSettingsPtr pRow = m_pdlEMCategoryCombo->FindByColumn(emcccID, (long)nCurEMCodeCategoryID, NULL, FALSE);
					if(pRow) {
						strNewValue.Format("%s: %s", strName, VarString(pRow->GetValue(emcccDesc), ""));
					}
					else {
						ASSERT(FALSE);
					}
				}

				AuditEvent(-1, "", nAuditTransactionID, aeiEMRItemEMCodeCategoryID, m_nID, strOldValue, strNewValue, aepMedium, aetChanged);
			}
		}

		// AutoAlphabetizeListData
		{
			BOOL bAutoAlphabetizeListData = IsDlgButtonChecked(IDC_AUTO_ALPHABETIZE_LIST_DATA) ? TRUE : FALSE;
			if (bIsNew || (bAutoAlphabetizeListData && !m_bAutoAlphabetizeListData) || (!bAutoAlphabetizeListData && m_bAutoAlphabetizeListData)) {
				arystrFields.Add("AutoAlphabetizeListData");
				arystrValues.Add(bAutoAlphabetizeListData ? "1" : "0");

				if(!bIsNew) {
					if(nAuditTransactionID == -1)
						nAuditTransactionID = BeginAuditTransaction();
					CString strOldValue, strNewValue;
					if(m_bAutoAlphabetizeListData)
						strOldValue = "Enabled for " + strName;
					else 
						strOldValue = "Disabled for " + strName;
					if(bAutoAlphabetizeListData)
						strNewValue = "Enabled for " + strName;
					else 
						strNewValue = "Disabled for " + strName;
					AuditEvent(-1, "", nAuditTransactionID, aeiEMRItemAlphabetizeLists, m_nID, strOldValue, strNewValue, aepLow, aetChanged);
				}
			}
		}

		// (c.haag 2008-10-21 15:37) - PLID 31708 - TableRowsAsFields
		{
			BOOL bTableRowsAsFields = IsDlgButtonChecked(IDC_TABLE_ROWS_AS_FIELDS) ? TRUE : FALSE;
			if (bIsNew || (bTableRowsAsFields && !m_bTableRowsAsFields) || (!bTableRowsAsFields && m_bTableRowsAsFields)) {
				arystrFields.Add("TableRowsAsFields");
				arystrValues.Add(bTableRowsAsFields ? "1" : "0");

				if(!bIsNew) {
					if(nAuditTransactionID == -1)
						nAuditTransactionID = BeginAuditTransaction();
					CString strOldValue, strNewValue;
					if(m_bTableRowsAsFields)
						strOldValue = "Enabled for " + strName;
					else 
						strOldValue = "Disabled for " + strName;
					if(bTableRowsAsFields)
						strNewValue = "Enabled for " + strName;
					else 
						strNewValue = "Disabled for " + strName;
					AuditEvent(-1, "", nAuditTransactionID, aeiEMRTableRowsAsFields, m_nID, strOldValue, strNewValue, aepLow, aetChanged);
				}
			}
		}

		// LongForm
		{
			CString strLongForm;
			GetDlgItemText(IDC_SENTENCE, strLongForm);
			if (bIsNew || strLongForm != m_strLongForm) {
				arystrFields.Add("LongForm");
				arystrValues.Add("'" + _Q(strLongForm) + "'");

				if(!bIsNew) {
					if(nAuditTransactionID == -1)
						nAuditTransactionID = BeginAuditTransaction();
					AuditEvent(-1, "", nAuditTransactionID, aeiEMRItemSentenceFormat, m_nID, strName + ": " + m_strLongForm, strName + ": " + strLongForm, aepMedium, aetChanged);
				}
			}
		}

		// DataFormat
		{
			long nCurDataFormat;
			if (IsDlgButtonChecked(IDC_DATA_FORMAT_TEXT)) {
				nCurDataFormat = 0;
			} else if (IsDlgButtonChecked(IDC_DATA_FORMAT_BULLET)) {
				nCurDataFormat = 1;
			} else if (IsDlgButtonChecked(IDC_DATA_FORMAT_NUMBER)) {
				nCurDataFormat = 2;
			} else if (IsDlgButtonChecked(IDC_DATA_FORMAT_LIST)) {
				nCurDataFormat = 3;
			} else {
				ThrowNxException("Could not determine currently selected data format!");
			}
			if (bIsNew || nCurDataFormat != m_nDataFormat) {
				arystrFields.Add("DataFormat");
				arystrValues.Add(AsString((long)nCurDataFormat));

				if(!bIsNew) {
					if(nAuditTransactionID == -1)
						nAuditTransactionID = BeginAuditTransaction();
					CString strOldValue, strNewValue;
					switch(m_nDataFormat) {
						case 0:
							strOldValue = strName + ": Text";
							break;
						case 1:
							strOldValue = strName + ": Bullet List";
							break;
						case 2:
							strOldValue = strName + (m_nDataType == 7 ? ": Table" : ": Numbered List");
							break;
						case 3:
							strOldValue = strName + ": List";
							break;
					}
					switch(nCurDataFormat) {
						case 0:
							strNewValue = strName + ": Text";
							break;
						case 1:
							strNewValue = strName + ": Bullet List";
							break;
						case 2:
							strNewValue = strName + (nCurDataType == 7 ? ": Table" : ": Numbered List");
							break;
						case 3:
							strNewValue = strName + ": List";
							break;
					}
					AuditEvent(-1, "", nAuditTransactionID, aeiEMRItemDataFormat, m_nID, strOldValue, strNewValue, aepMedium, aetChanged);
				}
			}
		}

		// DataSeparator
		{
			CString strDataSeparator;
			GetDlgItemText(IDC_DATA_FORMAT_SEPARATOR, strDataSeparator);
			// The m_strDataSeparator can be empty, which means to use the default ", ".  So if strDataSeparator is 
			// different from m_strDataSeparator then we know the value was changed by the user UNLESS m_strDataSeparator 
			// is blank and the user value is ", ".
			//TES 3/28/2006 - This is no longer true, if m_strDataSeparator is empty, it means the user set it that way.
			if (bIsNew || m_strDataSeparator != strDataSeparator) {
				arystrFields.Add("DataSeparator");
				arystrValues.Add("'" + _Q(strDataSeparator) + "'");

				if(!bIsNew) {
					if(nAuditTransactionID == -1)
						nAuditTransactionID = BeginAuditTransaction();
					CString strOldValue, strNewValue;
					strOldValue = strName + ": " + m_strDataSeparator;
					strNewValue = strName + ": " + strDataSeparator;
					AuditEvent(-1, "", nAuditTransactionID, aeiEMRItemDataSeparatorRegular, m_nID, strOldValue, strNewValue, aepLow, aetChanged);
				}
			}
		}

		// (b.cardillo 2005-03-21 15:52) - PLID 15008 - Added saving of the DataSeparatorFinal field, which defaults to 
		// " and ".  It used to be DataSeparator that defaulted to that, but with the advent of DataSeparatorFinal, 
		// DataSeparator now defaults to just ", " without the "and", and the "and" is left for the DataSeparatorFinal.
		// DataSeparatorFinal
		{
			CString strDataSeparatorFinal;
			GetDlgItemText(IDC_DATA_FORMAT_SEPARATOR_FINAL, strDataSeparatorFinal);
			// The m_strDataSeparatorFinal can be empty, which means to use the default " and ".  So if strDataSeparatorFinal is 
			// different from m_strDataSeparatorFinal then we know the value was changed by the user UNLESS m_strDataSeparatorFinal 
			// is blank and the user value is " and ".
			//TES 3/28/2006 - This is no longer true, if m_strDataSeparator is empty, it means the user set it that way.
			if (bIsNew || m_strDataSeparatorFinal != strDataSeparatorFinal) {
				arystrFields.Add("DataSeparatorFinal");
				arystrValues.Add("'" + _Q(strDataSeparatorFinal) + "'");

				if(!bIsNew) {
					if(nAuditTransactionID == -1)
						nAuditTransactionID = BeginAuditTransaction();
					CString strOldValue, strNewValue;
					strOldValue = strName + ": " + m_strDataSeparatorFinal;
					strNewValue = strName + ": " + strDataSeparatorFinal;
					AuditEvent(-1, "", nAuditTransactionID, aeiEMRItemDataSeparatorFinal, m_nID, strOldValue, strNewValue, aepLow, aetChanged);
				}
			}
		}

		
		// DataCodeID
		{
			{
				m_dlEmrDataCode->WaitForRequery(NXDATALIST2Lib::dlPatienceLevelWaitIndefinitely);

				NXDATALIST2Lib::IRowSettingsPtr pRow = m_dlEmrDataCode->GetCurSel();

				if (pRow) {
					nCurrentEmrDataCodeID = VarLong(pRow->GetValue(lcID), -1);
				} else {
					nCurrentEmrDataCodeID = -1;
				}
			}

			// (a.walling 2009-05-28 15:24) - PLID 34389
			if (bIsNew || nCurrentEmrDataCodeID != m_nEmrDataCodeID) {
				arystrFields.Add("DataCodeID");
				if (nCurrentEmrDataCodeID == -1) {
					arystrValues.Add("NULL");
				} else {
					arystrValues.Add("'" + _Q(AsString(nCurrentEmrDataCodeID)) + "'");
				}

				if(!bIsNew) {
					CString strOldDataCode, strNewDataCode;
					if (nCurrentEmrDataCodeID == -1) {
						strNewDataCode = "<None>";
					} else {
						NXDATALIST2Lib::IRowSettingsPtr pRow = m_dlEmrDataCode->FindByColumn(lcID, nCurrentEmrDataCodeID, NULL, VARIANT_FALSE);
						if (pRow) {
							strNewDataCode = VarString(pRow->GetValue(lcCode), "");
						}
					}

					if (m_nEmrDataCodeID == -1) {
						strOldDataCode = "<None>";
					} else {
						NXDATALIST2Lib::IRowSettingsPtr pRow = m_dlEmrDataCode->FindByColumn(lcID, m_nEmrDataCodeID, NULL, VARIANT_FALSE);
						if (pRow) {
							strOldDataCode = VarString(pRow->GetValue(lcCode), "");
						}
					}

					if(nAuditTransactionID == -1)
						nAuditTransactionID = BeginAuditTransaction();
					AuditEvent(-1, "", nAuditTransactionID, aeiEMRItemDataCodeID, m_nID, strName + ": " + strOldDataCode, strName + ": " + strNewDataCode, aepMedium, aetChanged);
				}
			}
		}
		
		// DataUnit
		{
			// (a.walling 2009-05-28 15:24) - PLID 34389
			CString strDataCodeUnit;
			m_nxeditDataUnit.GetWindowText(strDataCodeUnit);
			if (bIsNew || strDataCodeUnit != m_strEmrDataCodeUnit) {
				arystrFields.Add("DataUnit");
				arystrValues.Add("'" + _Q(strDataCodeUnit) + "'");

				if(!bIsNew) {
					if(nAuditTransactionID == -1)
						nAuditTransactionID = BeginAuditTransaction();
					AuditEvent(-1, "", nAuditTransactionID, aeiEMRItemDataUnit, m_nID, strName + ": " + m_strEmrDataCodeUnit, strName + ": " + strDataCodeUnit, aepMedium, aetChanged);
				}
			}
		}

		// BackgroundImageType
		{
			BOOL bImageSpecified;
			BOOL bIs3DImage = FALSE;
			BOOL bWas3DImage = FALSE;
			if (IsDlgButtonChecked(IDC_PROMPT_FOR_IMAGE)) {
				bImageSpecified = FALSE;
			}
			else if (IsDlgButtonChecked(IDC_USE_SELECTED_IMAGE)) {
				bImageSpecified = TRUE;
			}
			// (z.manning 2011-07-22 11:50) - PLID 44676 - Handle 3D images
			else if (IsDlgButtonChecked(IDC_USE_SELECTED_3DIMAGE)) {
				bImageSpecified = TRUE;
				bIs3DImage = TRUE;
			}
			else {
				ThrowNxException("Could not determine currently selected image type!");
			}
			if(m_aryLastSavedHotSpots.Is3DHotSpotArray()) {
				bWas3DImage = TRUE;
			}
			if (bIsNew || (bImageSpecified && !m_bImageSpecified) || (!bImageSpecified && m_bImageSpecified) || (bIs3DImage != bWas3DImage))
			{
				arystrFields.Add("BackgroundImageType");
				arystrValues.Add(bImageSpecified ? "2" : "NULL");

				if(!bIsNew)
				{
					if(nAuditTransactionID == -1) {
						nAuditTransactionID = BeginAuditTransaction();
					}
					CString strOldValue, strNewValue;
					if(m_bImageSpecified) {
						CString strImageType;
						if(bWas3DImage) {
							strImageType = "3D ";
						}
						strOldValue = strName + FormatString(" - Uses Specified %sImage", strImageType);
					}
					else {
						strOldValue = strName + " - Prompts For Image";
					}
					if(bImageSpecified) {
						CString strImageType;
						if(bIs3DImage) {
							strImageType = "3D ";
						}
						strNewValue = strName + FormatString(" - Uses Specified %sImage", strImageType);
					}
					else {
						strNewValue = strName + " - Prompts For Image";
					}
					AuditEvent(-1, "", nAuditTransactionID, aeiEMRItemImageFileType, m_nID, strOldValue, strNewValue, aepLow, aetChanged);
				}
			}
		}

		// BackgroundImageFilePath
		{
			if (bIsNew || m_strCurImagePath != m_strImagePath) {
				arystrFields.Add("BackgroundImageFilePath");
				arystrValues.Add("'" + _Q(m_strCurImagePath) + "'");

				if(!bIsNew) {
					if(nAuditTransactionID == -1)
						nAuditTransactionID = BeginAuditTransaction();
					CString strOldValue, strNewValue;
					strOldValue = strName + ": " + m_strImagePath;
					strNewValue = strName + ": " + m_strCurImagePath;
					AuditEvent(-1, "", nAuditTransactionID, aeiEMRItemImageFilePath, m_nID, strOldValue, strNewValue, aepLow, aetChanged);
				}
			}
		}

		// (z.manning 2010-02-09 14:57) - PLID 37228 - SmartStampsEnabled
		{
			if(bIsNew || (bCurrentEnableSmartStamps != m_bEnableSmartStamps))
			{
				bSomethingCriticalChanged = TRUE;
				arystrFields.Add("SmartStampsEnabled");
				arystrValues.Add(bCurrentEnableSmartStamps ? "1" : "0");

				if(!bIsNew) {
					if(nAuditTransactionID == -1) { nAuditTransactionID = BeginAuditTransaction(); }
					CString strOldValue, strNewValue;
					if(bCurrentEnableSmartStamps) {
						strOldValue = "Disabled";
						strNewValue = "Enabled";
					}
					else {
						strOldValue = "Enabled";
						strNewValue = "Disabled";
					}
					AuditEvent(-1, "", nAuditTransactionID, aeiEMRItemSmartStamps, m_nID, strOldValue, strNewValue, aepMedium, aetChanged);
				}
			}
		}

		// (z.manning 2010-02-09 15:20) - PLID 37228 - ChildEmrInfoMasterID
		{
			if(bIsNew || (varCurrentSmartStampTableMasterID != m_varSmartStampTableMasterID))
			{
				bSomethingCriticalChanged = TRUE;
				arystrFields.Add("ChildEmrInfoMasterID");
				arystrValues.Add(varCurrentSmartStampTableMasterID.vt == VT_NULL ? "NULL" : AsString(VarLong(varCurrentSmartStampTableMasterID)));
				
				if(!bIsNew) {
					if(nAuditTransactionID == -1) { nAuditTransactionID = BeginAuditTransaction(); }
					CString strOldValue, strNewValue;
					if(m_varSmartStampTableMasterID.vt != VT_NULL) {
						NXDATALIST2Lib::IRowSettingsPtr pOldRow = m_pdlSmartStampTable->FindByColumn(sstcMasterID, m_varSmartStampTableMasterID, NULL, VARIANT_FALSE);
						if(pOldRow != NULL) {
							strOldValue = VarString(pOldRow->GetValue(sstcName));
						}
					}
					if(m_pdlSmartStampTable->GetCurSel() != NULL) {
						strNewValue = m_pdlSmartStampTable->GetCurSel()->GetValue(sstcName);
					}
					AuditEvent(-1, "", nAuditTransactionID, aeiEMRItemLinkedSmartStampTable, m_nID, strOldValue, strNewValue, aepMedium, aetChanged);
				}
			}
		}

		// DefaultText
		{
			CString strDefaultText;
			if (IsDlgButtonChecked(IDC_RADIO_NARRATIVE)) {
				strDefaultText = (LPCTSTR)m_RichEditCtrl->RichText;
			} else {
				GetDlgItemText(IDC_DEFAULT_TEXT, strDefaultText);
			}
			if (strDefaultText != m_strDefaultText) {
				arystrFields.Add("DefaultText");
				arystrValues.Add("'" + _Q(strDefaultText) + "'");

				if(!bIsNew) {
					if(nAuditTransactionID == -1)
						nAuditTransactionID = BeginAuditTransaction();
					CString strOldValue, strNewValue;
					strOldValue = strName + ": " + (m_nDataType == 6 ? ConvertTextFormat(m_strDefaultText, tfNxRichText, tfPlainText): m_strDefaultText);
					strNewValue = strName + ": " + (nCurDataType == 6 ? ConvertTextFormat(strDefaultText, tfNxRichText, tfPlainText): strDefaultText);
					AuditEvent(-1, "", nAuditTransactionID, aeiEMRItemDefaultText, m_nID, strOldValue, strNewValue, aepLow, aetChanged);
				}
			}
		}

		// SliderMin
		{
			CString strSliderMin;
			GetDlgItemText(IDC_EMR_MINIMUM, strSliderMin);
			strSliderMin = FormatString("%0.04f", atof(strSliderMin));
			if (bIsNew || strSliderMin != FormatString("%0.04f", m_dblSliderMin)) {
				arystrFields.Add("SliderMin");
				arystrValues.Add(strSliderMin);

				if(!bIsNew) {
					if(nAuditTransactionID == -1)
						nAuditTransactionID = BeginAuditTransaction();
					CString strOldValue, strNewValue;
					strOldValue = strName + ": " + FormatString("%g", m_dblSliderMin);
					strNewValue = strName + ": " + FormatString("%g", atof(strSliderMin));
					AuditEvent(-1, "", nAuditTransactionID, aeiEMRItemSliderMinimum, m_nID, strOldValue, strNewValue, aepLow, aetChanged);
				}
			}
		}

		// SliderMax
		{
			CString strSliderMax;
			GetDlgItemText(IDC_EMR_MAXIMUM, strSliderMax);
			strSliderMax = FormatString("%0.04f", atof(strSliderMax));
			if (bIsNew || strSliderMax != FormatString("%0.04f", m_dblSliderMax)) {
				arystrFields.Add("SliderMax");
				arystrValues.Add(strSliderMax);

				if(!bIsNew) {
					if(nAuditTransactionID == -1)
						nAuditTransactionID = BeginAuditTransaction();
					CString strOldValue, strNewValue;
					strOldValue = strName + ": " + FormatString("%g", m_dblSliderMax);
					strNewValue = strName + ": " + FormatString("%g", atof(strSliderMax));
					AuditEvent(-1, "", nAuditTransactionID, aeiEMRItemSliderMaximum, m_nID, strOldValue, strNewValue, aepLow, aetChanged);
				}
			}
		}

		// SliderInc
		{
			CString strSliderInc;
			GetDlgItemText(IDC_EMR_INCREMENT, strSliderInc);
			strSliderInc = FormatString("%0.04f", atof(strSliderInc));
			if (bIsNew || strSliderInc != FormatString("%0.04f", m_dblSliderInc)) {
				arystrFields.Add("SliderInc");
				arystrValues.Add(strSliderInc);

				if(!bIsNew) {
					if(nAuditTransactionID == -1)
						nAuditTransactionID = BeginAuditTransaction();
					CString strOldValue, strNewValue;
					strOldValue = strName + ": " + FormatString("%g", m_dblSliderInc);
					strNewValue = strName + ": " + FormatString("%g", atof(strSliderInc));
					AuditEvent(-1, "", nAuditTransactionID, aeiEMRItemSliderIncrement, m_nID, strOldValue, strNewValue, aepLow, aetChanged);
				}
			}
		}

		// Disable Table Border
		//m.hancock - 2/28/2006 - PLID 15864 - Allow user to disable border on EMR table items when merging
		//If the data type is Table and the data format is also table (controlled by IDC_DATA_FORMAT_NUMBER), then save the setting.
		if((nCurDataType == 7) && (IsDlgButtonChecked(IDC_DATA_FORMAT_NUMBER)))
		{
			BOOL bTableSelected = IsDlgButtonChecked(IDC_CHECK_DISABLE_TABLE_BORDER) ? TRUE : FALSE;
			if (bIsNew || (bTableSelected && !m_bDisableTableBorder) || (!bTableSelected && m_bDisableTableBorder)) {
				arystrFields.Add("DisableTableBorder");
				arystrValues.Add(bTableSelected ? "1" : "0");

				if(!bIsNew) {
					if(nAuditTransactionID == -1)
						nAuditTransactionID = BeginAuditTransaction();
					CString strOldValue, strNewValue;
					if(m_bDisableTableBorder)
						strOldValue = "Border disabled for " + strName;
					else 
						strOldValue = "Border enabled for " + strName;
					if(bTableSelected)
						strNewValue = "Border disabled for " + strName;
					else 
						strNewValue = "Border enabled for " + strName;
					AuditEvent(-1, "", nAuditTransactionID, aeiEMRItemDisableTableBorder, m_nID, strOldValue, strNewValue, aepLow, aetChanged);
				}
			}
		}

		// (a.walling 2008-06-30 14:48) - PLID 30570 - Preview Pane flags
		//PreviewFlags
		{
			if (IsDlgButtonChecked(IDC_CHECK_HIDE_TITLE_ON_PREVIEW_PANE)) {
				nPreviewFlags |= epfHideTitle;
			} else {
				// (b.cardillo 2012-03-06 15:46) - PLID 48666 - We now initialize to the previous value instead 
				// of 0, so we need to explicitly set this bit to 0.
				nPreviewFlags &= ~((DWORD)epfHideTitle);
			}

			if (IsDlgButtonChecked(IDC_CHECK_HIDE_ITEM_ON_PREVIEW_PANE)) {
				nPreviewFlags |= epfHideItem;
			} else {
				// (b.cardillo 2012-03-06 15:46) - PLID 48666 - We now initialize to the previous value instead 
				// of 0, so we need to explicitly set this bit to 0.
				nPreviewFlags &= ~((DWORD)epfHideItem);
			}

			// (a.walling 2012-07-13 16:38) - PLID 48896
			if (IsDlgButtonChecked(IDC_CHECK_HIDE_IF_INDIRECTLY_ON_NARRATIVE)) {
				nPreviewFlags |= epfHideIfIndirect;
			} else {
				nPreviewFlags &= ~((DWORD)epfHideIfIndirect);
			}

			// (j.armen 2013-01-02 16:38) - PLID 54412 - Added Hide Item on iPad
			if (IsDlgButtonChecked(IDC_CHECK_HIDE_ITEM_ON_IPAD)) {
				nPreviewFlags |= epfHideOnIPad;
			} else {
				nPreviewFlags &= ~((DWORD)epfHideOnIPad);
			}

			if (bIsNew || (nPreviewFlags != m_nPreviewFlags)) {
				arystrFields.Add("PreviewFlags");
				arystrValues.Add(FormatString("%li", nPreviewFlags));

				// (a.walling 2008-08-12 12:37) - PLID 30570 - Audit any changes to preview flags
				if (!bIsNew) {
					if(nAuditTransactionID == -1)
						nAuditTransactionID = BeginAuditTransaction();
					
					CString strOldValue, strNewValue;

					strOldValue.Format("(%lu) - %s", m_nPreviewFlags, GetPreviewFlagsDescriptionForAudit(m_nPreviewFlags));
					strNewValue.Format("(%lu) - %s", nPreviewFlags, GetPreviewFlagsDescriptionForAudit(nPreviewFlags));

					AuditEvent(-1, "", nAuditTransactionID, aeiEMRItemPreviewFlags, m_nID, strOldValue, strNewValue, aepLow, aetChanged);
				}
			}
		}

		// (z.manning 2011-11-15 16:03) - PLID 46485 - InfoFlags
		{
			if (IsDlgButtonChecked(IDC_DONT_SPAWN_WHEN_REMEMBERING) == BST_CHECKED) {
				nInfoFlags |= eifDontSpawnFromRememberedValues;
			} else {
				// (b.cardillo 2012-03-06 15:46) - PLID 48666 - We now initialize to the previous value instead 
				// of 0, so we need to explicitly set this bit to 0.
				nInfoFlags &= ~((long)eifDontSpawnFromRememberedValues);
			}

			// (b.cardillo 2012-03-06 16:35) - PLID 48669 - Save and audit the Required checkbox
			if (IsDlgButtonChecked(IDC_REQUIRED_CHECKBOX) == BST_CHECKED) {
				nInfoFlags |= eifRequired;
			} else {
				nInfoFlags &= ~((long)eifRequired);
			}

			if (bIsNew || (nInfoFlags != m_nInfoFlags))
			{
				arystrFields.Add("InfoFlags");
				arystrValues.Add(FormatString("%li", nInfoFlags));

				if (!bIsNew) {
					if(nAuditTransactionID == -1) { nAuditTransactionID = BeginAuditTransaction(); }
					
					BOOL bOldDontSpawn = ((m_nInfoFlags & eifDontSpawnFromRememberedValues) != 0);
					BOOL bNewDontSpawn = ((nInfoFlags & eifDontSpawnFromRememberedValues) != 0);
					if(bOldDontSpawn != bNewDontSpawn) {
						CString strOldValue, strNewValue;
						strOldValue.Format("Item: %s - %s", strName, bOldDontSpawn ? "Do Not Spawn" : "Do Spawn");
						strNewValue.Format("%s", bNewDontSpawn ? "Do Not Spawn" : "Do Spawn");
						AuditEvent(-1, "", nAuditTransactionID, aeiEmrDontSpawnFromRememberedValues, m_nID, strOldValue, strNewValue, aepMedium, aetChanged);
					}

					// (b.cardillo 2012-03-06 16:35) - PLID 48669 - Save and audit the Required checkbox
					BOOL bOldRequired = ((m_nInfoFlags & eifRequired) == eifRequired);
					BOOL bNewRequired = ((nInfoFlags & eifRequired) == eifRequired);
					if (bOldRequired != bNewRequired) {
						CString strOldValue, strNewValue;
						strOldValue.Format("Item: %s - %s", strName, bOldRequired ? "Required" : "Not Required");
						strNewValue.Format("%s", bNewRequired ? "Required" : "Not Required");
						AuditEvent(-1, "", nAuditTransactionID, aeiEmrItemRequired, m_nID, strOldValue, strNewValue, aepMedium, aetChanged);
					}
				}
			}
		}

		//TES 3/11/2011 - PLID 42757 - Added Glasses Order data
		{
			//TES 4/6/2012 - PLID 49367 - On tables, it's a different checkbox, and we are only associated with Glasses Order data if
			// we are NOT associated with Contact Lens data
			if(IsDlgButtonChecked(IDC_RADIO_TABLE)) {
				bCurHasGlassesOrderData = IsDlgButtonChecked(IDC_ASSOCIATE_WITH_GLASSES_ORDER_OR_CL) && !m_bHasContactLensData;
			}
			else {
				bCurHasGlassesOrderData = IsDlgButtonChecked(IDC_ASSOCIATE_WITH_GLASSES_ORDER);
			}
			CurGlassesOrderLens = golInvalid;
			NXDATALIST2Lib::IRowSettingsPtr pLensRow = m_pdlGlassesOrderLens->CurSel;
			if(pLensRow) {
				CurGlassesOrderLens = (GlassesOrderLens)VarLong(pLensRow->GetValue(golcCode),golInvalid);
			}
			if (bIsNew || (bCurHasGlassesOrderData != m_bHasGlassesOrderData)) {
				arystrFields.Add("HasGlassesOrderData");
				arystrValues.Add(FormatString("%i", bCurHasGlassesOrderData?1:0));

				if (!bIsNew) {
					if(nAuditTransactionID == -1)
						nAuditTransactionID = BeginAuditTransaction();
					
					CString strOldValue, strNewValue;

					strOldValue.Format("%s", m_bHasGlassesOrderData?"Yes":"No");
					strNewValue.Format("%s", bCurHasGlassesOrderData?"Yes":"No");

					AuditEvent(-1, "", nAuditTransactionID, aeiEMRItemHasGlassesOrderData, m_nID, strOldValue, strNewValue, aepLow, aetChanged);
				}
			}

			if(bIsNew || (CurGlassesOrderLens != m_GlassesOrderLens)) {
				arystrFields.Add("GlassesOrderLens");
				arystrValues.Add(CurGlassesOrderLens == golInvalid ? "NULL" : AsString(CurGlassesOrderLens));

				if(!bIsNew) {
					if(nAuditTransactionID == -1)
						nAuditTransactionID = BeginAuditTransaction();

					CString strOldValue, strNewValue;
					strOldValue = GetGlassesOrderLensDescription(m_GlassesOrderLens);
					strNewValue = GetGlassesOrderLensDescription(CurGlassesOrderLens);

					AuditEvent(-1, "", nAuditTransactionID, aeiEMRItemGlassesOrderLens, m_nID, strOldValue, strNewValue, aepLow, aetChanged);
				}
			}

			//TES 4/6/2012 - PLID 49367 - Added HasContactLensData
			if(bIsNew || (m_bSavedHasContactLensData != m_bHasContactLensData)) {
				arystrFields.Add("HasContactLensData");
				arystrValues.Add(FormatString("%i",m_bHasContactLensData?1:0));
				if (!bIsNew) {
					if(nAuditTransactionID == -1)
						nAuditTransactionID = BeginAuditTransaction();
					
					CString strOldValue, strNewValue;

					strOldValue.Format("%s", m_bSavedHasContactLensData?"Yes":"No");
					strNewValue.Format("%s", m_bHasContactLensData?"Yes":"No");

					AuditEvent(-1, "", nAuditTransactionID, aeiEMRItemHasContactLensData, m_nID, strOldValue, strNewValue, aepLow, aetChanged);
				}
			}
		}

		{
			// (r.gonet 08/03/2012) - PLID 51735
			if(IsDlgButtonChecked(IDC_USE_WITH_WOUND_CARE_CALC)) {
				bCurUseWithWoundCareCoding = TRUE;
			} else {
				bCurUseWithWoundCareCoding = FALSE;
			}

			// (r.gonet 08/03/2012) - PLID 51735 - Audit the change of the Use With Wound Care Coding checkbox.
			if(bIsNew || (m_bUseWithWoundCareCoding != bCurUseWithWoundCareCoding)) {
				arystrFields.Add("UseWithWoundCareCoding");
				arystrValues.Add(FormatString("%i",bCurUseWithWoundCareCoding?1:0));
				if (!bIsNew) {
					if(nAuditTransactionID == -1)
						nAuditTransactionID = BeginAuditTransaction();
					
					CString strOldValue, strNewValue;

					strOldValue.Format("%s", m_bUseWithWoundCareCoding?"Yes":"No");
					strNewValue.Format("%s", bCurUseWithWoundCareCoding?"Yes":"No");

					AuditEvent(-1, "", nAuditTransactionID, aeiEMRItemUseWithWoundCareCoding, m_nID, strOldValue, strNewValue, aepLow, aetChanged);
				}
			}
		}

		//EmrInfoMasterID
		// TES 12/6/2006 - PLID 23724 - Fill in this new field, but only if we're new (otherwise, this should never need to change).
		if(bIsNew) {
			arystrFields.Add("EmrInfoMasterID");
			arystrValues.Add("@nEMRInfoMasterID");
		}


		// Now write the statement to the batch
		if (bIsNew) {
			// It's new so we know the arrays are filled
			bSomethingCriticalChanged = TRUE;

			// This is easy because in the sql statement the lists are totally separate (though they 
			// still have corresponding elements of course)
			AddStatementToSqlBatch(strBatchSql, "INSERT INTO EMRInfoT (%s) VALUES (%s)", 
				GenerateDelimitedListFromStringArray(arystrFields, ","), 
				GenerateDelimitedListFromStringArray(arystrValues, ","));

			// (j.armen 2014-01-29 12:06) - PLID 60523 - Idenitate EMRInfoT
			AddStatementToSqlBatch(strBatchSql, "SET @nEMRInfoID = SCOPE_IDENTITY()");

			// Audit the name of the item
			if (nAuditTransactionID == -1)
				nAuditTransactionID = BeginAuditTransaction();
			AuditEvent(-1, "", nAuditTransactionID, aeiEMRItemCreated, m_nID, "", strName, aepMedium, aetCreated);

			// (c.haag 2015-07-07) - PLID 65572 - Audits all of the newly created EMR problem actions for this new EMR item
			AuditNewItemEmrProblemActions(nAuditTransactionID, strName);

			//TES 12/7/2006 - PLID 23724 - Also, if we are new, then we are now the active EMRInfo record.
			AddStatementToSqlBatch(strBatchSql, "UPDATE EmrInfoMasterT SET ActiveEmrInfoID = @nEMRInfoID WHERE ID = @nEMRInfoMasterID");

			//TES 12/13/2006 - PLID 23792 - And apply the master fields.
			if(arystrMasterFields.GetSize()) {
				// Here we have to merge the two lists 
				CString strCombinedUpdateString;
				for (long i=0; i<arystrMasterFields.GetSize(); i++) {
					CString str;
					str.Format("%s = %s, ", arystrMasterFields.GetAt(i), arystrMasterValues.GetAt(i));
					strCombinedUpdateString += str;
				}
				strCombinedUpdateString.Delete(strCombinedUpdateString.GetLength() - 2, 2);
				AddStatementToSqlBatch(strBatchSql, "UPDATE EmrInfoMasterT SET %s WHERE ID = @nEMRInfoMasterID ", strCombinedUpdateString);
			}

		} else if (arystrFields.GetSize() != 0 || arystrMasterFields.GetSize() != 0) {
			// It's not new, but at least one element is in the arrays

			// (j.jones 2006-08-30 14:14) - PLID 22306 - any change will cause the "critical change" boolean to be set
			// UNLESS we only made one change and it was the EMRInfoT.Inactive state
			// (j.jones 2007-08-15 14:10) - PLID 27053 - the above statement is no longer true, as I have
			// added E/M coding information to EMRInfoMasterT and EMRDataGroupsT,
			// both of which do not negatively affect saved EMNs and thus are only minor
			
			BOOL bOnlyMinorInformationChanged = (arystrFields.GetSize() == 0 && arystrMasterFields.GetSize() > 0);			

			if(!bOnlyMinorInformationChanged) {
				bSomethingCriticalChanged = TRUE;
			}
			else {
				bSomethingMinorChanged = TRUE;
			}

			if(arystrFields.GetSize() > 0) {
				// Here we have to merge the two lists 
				CString strCombinedUpdateString;
				for (long i=0; i<arystrFields.GetSize(); i++) {
					CString str;
					str.Format("%s = %s, ", arystrFields.GetAt(i), arystrValues.GetAt(i));
					strCombinedUpdateString += str;
				}
				strCombinedUpdateString.Delete(strCombinedUpdateString.GetLength() - 2, 2);
				AddStatementToSqlBatch(strBatchSql, "UPDATE EMRInfoT SET %s WHERE ID = @nEMRInfoID ", strCombinedUpdateString);
			}
			if(arystrMasterFields.GetSize() > 0) {
				// Here we have to merge the two lists 
				CString strCombinedUpdateString;
				for (long i=0; i<arystrMasterFields.GetSize(); i++) {
					CString str;
					str.Format("%s = %s, ", arystrMasterFields.GetAt(i), arystrMasterValues.GetAt(i));
					strCombinedUpdateString += str;
				}
				strCombinedUpdateString.Delete(strCombinedUpdateString.GetLength() - 2, 2);
				AddStatementToSqlBatch(strBatchSql, "UPDATE EmrInfoMasterT SET %s WHERE ID = @nEMRInfoMasterID ", strCombinedUpdateString);
			}
		} else {
			// Nothing needs to be written to the base record
		}
	}

	// Next deal with the category IDs
	{
		CDWordArray aryIDsToAdd, aryIDsToRemove;
		if (bIsNew) {
			// We know we have to add them all
			aryIDsToAdd.Append(m_arynCurCategoryIDs);
		} else {
			// See which have to be added
			{
				for (long i=0; i<m_arynCurCategoryIDs.GetSize(); i++) {
					DWORD dw = m_arynCurCategoryIDs.GetAt(i);
					if (FindDWordArrayElement(m_arynCategoryIDs, dw) == -1) {
						// This item in the current list wasn't found in the original list, so it needs to be added to data
						aryIDsToAdd.Add(dw);
					}
				}
			}
			// And which need to be removed
			{
				for (long i=0; i<m_arynCategoryIDs.GetSize(); i++) {
					DWORD dw = m_arynCategoryIDs.GetAt(i);
					if (FindDWordArrayElement(m_arynCurCategoryIDs, dw) == -1) {
						// This item in the original list wasn't found in the current list, so it needs to be removed from data
						aryIDsToRemove.Add(dw);
					}
				}
			}
		}
		// Now if we have to make a change, generate the sql statement for the change
		if (aryIDsToRemove.GetSize() > 0) {
			//DRT 8/30/2006 - PLID 22312 - Changing categories counts as data -- must cause a new copy if there are locked/saved items
			bSomethingCriticalChanged = TRUE;
			AddStatementToSqlBatch(strBatchSql, 
				"DELETE EMRInfoCategoryT WHERE EMRInfoID = @nEMRInfoID AND EMRCategoryID IN (%s)",
				GenerateDelimitedListFromLongArray(aryIDsToRemove, ","));

			if(!bIsNew) {

				if(nAuditTransactionID == -1)
					nAuditTransactionID = BeginAuditTransaction();

				_RecordsetPtr rsCategories = CreateRecordset("SELECT Name FROM EMRCategoriesT WHERE ID IN (%s)",
					GenerateDelimitedListFromLongArray(aryIDsToRemove, ","));
				while(!rsCategories->eof) {
					CString strNewValue;
					strNewValue.Format("Removed '%s' from item '%s'", AdoFldString(rsCategories, "Name",""), strName);
					AuditEvent(-1, "", nAuditTransactionID, aeiEMRItemCategoryDeleted, m_nID, "", strNewValue, aepMedium, aetChanged);
					rsCategories->MoveNext();
				}
				rsCategories->Close();
			}
		}
		if (aryIDsToAdd.GetSize() > 0) {
			//DRT 8/30/2006 - PLID 22312 - Changing categories counts as data -- must cause a new copy if there are locked/saved items
			bSomethingCriticalChanged = TRUE;
			AddStatementToSqlBatch(strBatchSql, 
				"EXEC sp_xml_preparedocument @hDoc OUTPUT, N'%s'; "
				"INSERT INTO EMRInfoCategoryT (EMRInfoID, EMRCategoryID) "
				" SELECT @nEMRInfoID, ID FROM OPENXML(@hDoc, '/ROOT/P') WITH (ID INT); "
				"EXEC sp_xml_removedocument @hDoc;", 
				GenerateXMLFromSemiColonDelimitedIDList(GenerateDelimitedListFromLongArray(aryIDsToAdd, ";")));

			if(!bIsNew) {
				if(nAuditTransactionID == -1)
					nAuditTransactionID = BeginAuditTransaction();
				
				_RecordsetPtr rsCategories = CreateRecordset("SELECT Name FROM EMRCategoriesT WHERE ID IN (%s)",
					GenerateDelimitedListFromLongArray(aryIDsToAdd, ","));
				while(!rsCategories->eof) {
					CString strNewValue;
					strNewValue.Format("Added '%s' to item '%s'", AdoFldString(rsCategories, "Name",""), strName);
					AuditEvent(-1, "", nAuditTransactionID, aeiEMRItemCategoryAdded, m_nID, "", strNewValue, aepMedium, aetChanged);
					rsCategories->MoveNext();
				}
				rsCategories->Close();
			}
		}
	}

	// And deal with the item actions
	{
		// Similar to the categories, where we generate a list of ones to remove and ones to 
		// add.  The only difference is that now when we compare we have to compare on two 
		// values instead of just one.

		// We have a separate function for this because the exact same algorithm is used for 
		// data elements' actions below
		if (AddStatementToSqlBatch_EmrActionChanges(strBatchSql, eaoEmrItem, "@nEMRInfoID", m_arActions, m_arCurActions, nAuditTransactionID)) {
			bSomethingCriticalChanged = TRUE;
		}
	}


	//DRT 1/15/2008 - PLID 28602 - Image HotSpots.  These are just like data elements (below), except they're drawn as image regions 
	//	instead of being text.
	{
		//Everything related to image HotSpots can be found in m_aryLastSavedHotSpots (what was loaded from data when this dialog opened), 
		//	m_aryRemovedHotSpots (all hotspots removed since this dialog started), m_aryChangedHotSpots (all hotspots that have changed their
		//	data -- currently just actions -- since this dialog started), and m_aryNewHotSpots (all new hotspots since dialog started).
		//Once the save happens, m_aryLastSavedHotSpots is re-sync'd to be everything, and the others are emptied.
		//At any point in time the following rules must apply:
		//	Nothing that is in "new" can exist in "last saved"
		//	Everything in "removed" must exist in "last saved"
		//	Everything in "changed" must exist in "last saved"

		//1)  Generate queries for everything that is being deleted
		if(m_aryRemovedHotSpots.GetSize() > 0) {
			bSomethingCriticalChanged = TRUE;

			CString strHotSpotIDsToDelete;
			for (long i = 0; i < m_aryRemovedHotSpots.GetSize(); i++) {
				CEMRHotSpot *pSpot = m_aryRemovedHotSpots.GetAt(i);
				strHotSpotIDsToDelete += AsString(pSpot->GetID()) + ",";

				// (z.manning 2011-09-27 14:15) - PLID 44676 - Don't audit 3D hot spots
				if(!pSpot->Is3DHotSpot()) {
					//audit each deleted element
					CString strNewValue = "Deleted Image Hot Spot";
					if(nAuditTransactionID == -1)
						nAuditTransactionID = BeginAuditTransaction();
					AuditEvent(-1, "", nAuditTransactionID, aeiImageHotSpotRemoved, m_nID, "Item:  " + strName, strNewValue, aepHigh, aetDeleted);
				}
			}

			strHotSpotIDsToDelete.Delete(strHotSpotIDsToDelete.GetLength() - 1, 1);

			// Add the necessary statements to the batch
			AddStatementToSqlBatch(strBatchSql, "DELETE FROM EMRHotSpotTemplateSelectT WHERE EMRImageHotSpotID IN (%s)", strHotSpotIDsToDelete);
			AddStatementToSqlBatch(strBatchSql, "UPDATE EmrActionsT SET Deleted = 1 WHERE SourceType = %li AND SourceID IN (%s)", eaoEmrImageHotSpot, strHotSpotIDsToDelete);
			AddStatementToSqlBatch(strBatchSql, "DELETE FROM EMRHotSpotSelectT WHERE EMRImageHotSpotID IN (%s)", strHotSpotIDsToDelete);
			AddStatementToSqlBatch(strBatchSql, "DELETE FROM EMRImageHotSpotsT WHERE ID IN (%s)", strHotSpotIDsToDelete);
		}

		//2)  Generate queries for everything that is being added newly
		if(m_aryNewHotSpots.GetSize() > 0)
		{
			bSomethingCriticalChanged = TRUE;

			long nIDIncrement = 1;
			long nActionIDIncrement = 1;

			CString strXMLData;
			for(long i = 0; i < m_aryNewHotSpots.GetSize(); i++)
			{
				CEMRHotSpot *pSpot = m_aryNewHotSpots.GetAt(i);

				CString strActionXml = GenerateActionXml(pSpot->GetCurrentActionArray(), nActionIDIncrement);

				//TES 2/9/2010 - PLID 37223 - Also need to include the Anatomic Location information in the XML (NULL fields should be
				// ignored).
				CString strLocationID;
				if(pSpot->GetAnatomicLocationID() != -1) {
					strLocationID.Format("AnatomicLocationID=\"%li\"", pSpot->GetAnatomicLocationID());
				}
				CString strQualifierID;
				if(pSpot->GetAnatomicQualifierID() != -1) {
					strQualifierID.Format("AnatomicQualifierID=\"%li\"", pSpot->GetAnatomicQualifierID());
				}
				// (z.manning 2011-07-22 16:12) - PLID 44676 - Handle ImageHotSpotID
				CString str3DHotSpotID;
				if(pSpot->Get3DHotSpotID() != -1) {
					str3DHotSpotID.Format("ImageHotSpotID=\"%li\"", pSpot->Get3DHotSpotID());
				}
				strXMLData += FormatString("<S ArbVal=\"%s\" ID=\"%li\" Data=\"%s\" %s %s AnatomySide=\"%i\" %s>\r\n%s</S>\r\n",
					ConvertToQuotableXMLString(AsString(nIDIncrement++)),
					m_nID, ConvertToQuotableXMLString(pSpot->GetOutputPoints()), 
					strLocationID, strQualifierID, pSpot->GetSide(), str3DHotSpotID,
					strActionXml);

				// (z.manning 2011-09-27 14:12) - PLID 44676 - Don't audit 3D hot spots since those are built into the image file.
				if(!pSpot->Is3DHotSpot()) {
					//audit each newly added element
					CString strNewValue = "Added New Image Hot Spot";
					if(nAuditTransactionID == -1) {
						nAuditTransactionID = BeginAuditTransaction();
					}
					AuditEvent(-1, "", nAuditTransactionID, aeiImageHotSpotAdded, m_nID, "Item:  " + strName, strNewValue, aepMedium, aetCreated);
				}
			}

			if(!strXMLData.IsEmpty()) {
				strXMLData = "<ROOT>\r\n" + strXMLData + "</ROOT>";
			}

			//Now insert the XML
			AddStatementToSqlBatch(strBatchSql, 
				"EXEC sp_xml_preparedocument @hDoc OUTPUT, N'%s'; "
				// (j.dinatale 2010-10-20) - PLID 31160 - now at the top of the entire query since multiple inserts wish to use this variable
				//DRT 1/17/2007 - PLID 24181 - Starting point for EMRAction records
				//"DECLARE @nEMRActionBase INT; "
				// (c.haag 2008-06-23 10:06) - PLID 30465 - Do not use COALESCE(MAX(ID), 0) because
				// it may not be the same as the current identity value of EmrActionsT.ID. Use IDENT_CURRENT
				// instead
				// "SET @nEMRActionBase = (SELECT COALESCE(MAX(ID), 0) FROM EMRActionsT); "
				"SET @nEMRActionBase = IDENT_CURRENT('EmrActionsT'); "

				"DECLARE @nEMRSpotGroupBase INT; "
				"SET @nEMRSpotGroupBase = (SELECT COALESCE(MAX(EmrSpotGroupID), 0) FROM EMRImageHotSpotsT); "

				//DRT 1/15/2008 - PLID 28602 - Starting point for EMRImageHotSpot records
				"DECLARE @nEMRHotSpotBase INT; "
				"SET @nEMRHotSpotBase = (SELECT COALESCE(MAX(ID), 0) FROM EMRImageHotSpotsT); "

				// emr hot spot details
				//TES 2/9/2010 - PLID 37223 - Added Anatomic Location info.
				// (z.manning 2011-07-22 16:11) - PLID 44676 - Added ImageHotSpotID
				"INSERT INTO EMRImageHotSpotsT (ID, EMRInfoID, Data, EmrSpotGroupID, AnatomicLocationID, AnatomicQualifierID, AnatomySide, ImageHotSpotID) "
				" SELECT @nEMRHotSpotBase + ArbVal, @nEMRInfoID, Data, @nEMRSpotGroupBase + ArbVal, AnatomicLocationID, AnatomicQualifierID, AnatomySide, ImageHotSpotID "
				" FROM OPENXML(@hDoc, '/ROOT/S', 1) WITH (ArbVal INT, Data ntext, AnatomicLocationID INT, AnatomicQualifierID INT, AnatomySide INT, ImageHotSpotID smallint) XmlQ "

				// the actions for those data elements
				//TES 1/30/2007 - PLID 24474 - Don't forget SpawnAsChild!
				"INSERT INTO EmrActionsT (SourceType, SourceID, DestType, DestID, SortOrder, Popup, SpawnAsChild) "
				" SELECT %li, @nEMRHotSpotBase + ArbVal, DestType, DestID, SortOrder, Popup, SpawnAsChild "
				" FROM OPENXML(@hDoc, '/ROOT/S/A', 1) WITH (ArbVal INT '../@ArbVal', DestType INT, DestID INT, SortOrder INT, Popup BIT, SpawnAsChild BIT) "
				//DRT 1/17/2007 - PLID 24181 - Added insertion for Charge-specific actions.  This may be no records if there are no charge actions
				"INSERT INTO EmrActionChargeDataT (ActionID, Prompt, DefaultQuantity, Modifier1Number, Modifier2Number, Modifier3Number, Modifier4Number) "
				" SELECT @nEMRActionBase + ArbVal, Prompt, Quantity, Mod1, Mod2, Mod3, Mod4 "
				" FROM OPENXML(@hDoc, '/ROOT/S/A/C', 1) WITH (ArbVal INT '../@ArbVal', Prompt INT, Quantity FLOAT, Mod1 NVARCHAR(10), Mod2 NVARCHAR(10), Mod3 NVARCHAR(10), Mod4 NVARCHAR(10)) "
				// (c.haag 2008-06-20 10:53) - PLID 30221 - Also todos
				"INSERT INTO EmrActionsTodoDataT (ActionID, RemindType, RemindInterval, DeadlineType, DeadlineInterval, Notes, Priority, Task, CategoryID) "
				" SELECT @nEMRActionBase + ArbVal, RemindType, RemindInterval, DeadlineType, DeadlineInterval, Notes, Priority, Task, CategoryID "
				" FROM OPENXML(@hDoc, '/ROOT/S/A/Q', 1) WITH (ArbVal INT '../@ArbVal', RemindType INT, RemindInterval INT, DeadlineType INT, DeadlineInterval INT, Notes NVARCHAR(2000), Priority INT, Task NVARCHAR(50), CategoryID INT) "
				"INSERT INTO EmrActionsTodoAssignToT (ActionID, AssignTo) "
				" SELECT @nEMRActionBase + ArbVal, AssignTo "
				" FROM OPENXML(@hDoc, '/ROOT/S/A/R', 1) WITH (ArbVal INT '../@ArbVal', AssignTo INT) "
				// (c.haag 2008-07-17 16:41) - PLID 30724 - Problem actions
				// (c.haag 2014-07-22) - PLID 62789 - Added SNOMEDCodeID
				// (s.tullis 2015-02-23 17:47) - PLID 64749 
				// (r.gonet 2015-03-10 14:48) - PLID 65013 - Added DoNotShowOnProblemPrompt.
				"INSERT INTO EmrProblemActionsT (EmrActionID, DefaultDescription, DefaultStatus, SpawnToSourceItem, SNOMEDCodeID, DoNotShowOnCCDA, DoNotShowOnProblemPrompt) "
				" SELECT @nEMRActionBase + ArbVal, DefaultDescription, DefaultStatus, SpawnToSourceItem, SNOMEDCodeID, DoNotShowOnCCDA, DoNotShowOnProblemPrompt "
				" FROM OPENXML(@hDoc, '/ROOT/S/A/P', 1) WITH (ArbVal INT '../@ArbVal', DefaultDescription nvarchar(2000), DefaultStatus INT, SpawnToSourceItem BIT, SNOMEDCodeID INT, DoNotShowOnCCDA BIT, DoNotShowOnProblemPrompt BIT) "
				// (b.savon 2014-07-21 16:45) - PLID 62707 - Handle saving the new Diagnosis DestType action to EmrActionsT and EmrActionsDiagnosisDataT
				"INSERT INTO EMRActionDiagnosisDataT (EmrActionID, DiagCodeID_ICD9, DiagCodeID_ICD10) "
				"	SELECT @nEMRActionBase + ArbVal, CASE WHEN DiagCodeID_ICD9 = -1 THEN NULL ELSE DiagCodeID_ICD9 END AS DiagCodeID_ICD9, CASE WHEN DiagCodeID_ICD10 = -1 THEN NULL ELSE DiagCodeID_ICD10 END AS DiagCodeID_ICD10 \r\n"
				"	FROM OPENXML(@hDoc, 'ROOT/S/A/DI', 1) WITH (ArbVal INT '../@ArbVal', DiagCodeID_ICD9 INT, DiagCodeID_ICD10 INT) "
				"EXEC sp_xml_removedocument @hDoc;", strXMLData, eaoEmrImageHotSpot);
		}


		//3)  Generate queries for all spots that are changing their data
		if(m_aryChangedHotSpots.GetSize() > 0)
		{
			CString strXMLData;
			for(int i = 0; i < m_aryChangedHotSpots.GetSize(); i++)
			{
				CEMRHotSpot *pSpot = m_aryChangedHotSpots.GetAt(i);

				//TES 2/9/2010 - PLID 37223 - Need to generate XML for Anatomic Location changes.  First, check whether any of it actually
				// changed.
				if(pSpot->GetAnatomicLocationID() != pSpot->GetOriginalAnatomicLocationID() ||
					pSpot->GetAnatomicQualifierID() != pSpot->GetOriginalAnatomicQualifierID() ||
					pSpot->GetSide() != pSpot->GetOriginalSide()) {
					//TES 2/9/2010 - PLID 37223 - Yup, so we know there's been a critical change.  
					bSomethingCriticalChanged = TRUE;

					//TES 2/9/2010 - PLID 37223 - Now create the XML (ignore NULL values)
					CString strLocationID;
					if(pSpot->GetAnatomicLocationID() != -1) {
						strLocationID.Format("AnatomicLocationID=\"%li\"", pSpot->GetAnatomicLocationID());
					}
					CString strQualifierID;
					if(pSpot->GetAnatomicQualifierID() != -1) {
						strQualifierID.Format("AnatomicQualifierID=\"%li\"", pSpot->GetAnatomicQualifierID());
					}
					strXMLData += FormatString("<S ID=\"%s\" Data=\"%s\" %s %s AnatomySide=\"%i\"></S>\r\n",
						ConvertToQuotableXMLString(AsString(pSpot->GetID())),
						ConvertToQuotableXMLString(pSpot->GetOutputPoints()), 
						strLocationID, strQualifierID, pSpot->GetSide());

					//TES 2/10/2010 - PLID 37296 - We need to audit this change, build strings describing the full anatomic location, both
					// old and new.
					CString strOldValue = pSpot->GetOriginalAnatomicLocationName();
					CString strOldQual = pSpot->GetOriginalAnatomicQualifierName();
					AnatomySide as = pSpot->GetOriginalSide();
					// (z.manning 2010-05-03 09:13) - PLID 37553 - We now have a function for this
					strOldValue = ::FormatAnatomicLocation(strOldValue, strOldQual, as);

					CString strNewValue = pSpot->GetAnatomicLocationName();
					CString strNewQual = pSpot->GetAnatomicQualifierName();
					as = pSpot->GetSide();
					// (z.manning 2010-05-03 09:13) - PLID 37553 - We now have a function for this
					strNewValue = ::FormatAnatomicLocation(strNewValue, strNewQual, as);

					//TES 2/10/2010 - PLID 37296 - Now go ahead and audit (include the name of the item).
					if(nAuditTransactionID == -1)
						nAuditTransactionID = BeginAuditTransaction();
					AuditEvent(-1, "", nAuditTransactionID, aeiImageHotSpotAnatomicLocation, m_nID, strName + " - " + strOldValue, strName + " - " + strNewValue, aepMedium, aetChanged);
				}

				if(AddStatementToSqlBatch_EmrActionChanges(strBatchSql, eaoEmrImageHotSpot, AsString(pSpot->GetID()), *(pSpot->GetOriginalActionArray()), *(pSpot->GetCurrentActionArray()), nAuditTransactionID)) {
					bSomethingCriticalChanged = TRUE;
				}
			}

			//TES 2/9/2010 - PLID 37223 - Now add the XML we generated for the Anatomic Location changes.
			if(!strXMLData.IsEmpty()) {
				strXMLData = "<ROOT>\r\n" + strXMLData + "</ROOT>";
				AddStatementToSqlBatch(strBatchSql, "EXEC sp_xml_preparedocument @hDoc OUTPUT, N'%s'; "
					"UPDATE EmrImageHotSpotsT SET AnatomicLocationID = XmlQ.AnatomicLocationID, AnatomicQualifierID = XmlQ.AnatomicQualifierID, "
					"AnatomySide = XmlQ.AnatomySide FROM EmrImageHotSpotsT INNER JOIN OPENXML(@hDoc, '/ROOT/S') "
					"WITH (ID INT, AnatomicLocationID INT, AnatomicQualifierID INT, AnatomySide INT) XmlQ "
					" ON EmrImageHotSpotsT.ID = XmlQ.ID "
					" WHERE EmrInfoID = @nEMRInfoID "
					"EXEC sp_xml_removedocument @hDoc;", strXMLData);
			}

		}
	}
	//End Image HotSpot updating code

	// (z.manning 2011-10-24 14:37) - PLID 46082 - Save stamp exclusions
	{
		CArray<long,long> arynNewStampIDs, arynRemovedStampIDs;
		m_StampExclusions.FindDifferences(&m_SavedStampExclusions, &arynNewStampIDs, &arynRemovedStampIDs);
		if(arynNewStampIDs.GetCount() > 0 || arynRemovedStampIDs.GetCount() > 0)
		{
			bSomethingMinorChanged = TRUE;
			if(arynRemovedStampIDs.GetCount() > 0) {
				AddStatementToSqlBatch(strBatchSql, "DELETE FROM EmrInfoStampExclusionsT WHERE EmrInfoMasterID = @nEMRInfoMasterID AND StampID IN (%s)", ArrayAsString(arynRemovedStampIDs, false));
			}
			for(int nNewStampIndex = 0; nNewStampIndex < arynNewStampIDs.GetCount(); nNewStampIndex++) {
				const long nStampID = arynNewStampIDs.GetAt(nNewStampIndex);
				AddStatementToSqlBatch(strBatchSql, "INSERT INTO EmrInfoStampExclusionsT (EmrInfoMasterID, StampID) VALUES (@nEMRInfoMasterID, %li)", nStampID);
			}

			if(!bIsNew) {
				if(nAuditTransactionID == -1) { nAuditTransactionID = BeginAuditTransaction(); }
				CString strOldValue = "Item: " + strName + " - " + m_SavedStampExclusions.GetStampText();
				CString strNewValue = m_StampExclusions.GetStampText();
				AuditEvent(-1, "", nAuditTransactionID, aeiEmrItemStampExclusions, m_nID, strOldValue, strNewValue, aepMedium, aetChanged);
			}
		}
	}

	// (c.haag 2011-03-16) - PLID 42813 - Delete from common lists now before the EmrDataID's are deleted, or else we get errors that
	// the EmrDataID is still in use by a doomed common list.
	// B) Deleted lists
	{
		int nLists = m_CommonListCollection.GetDeletedListCount();
		for (int i=0; i < nLists; i++)
		{
			const CEmrInfoCommonList list = m_CommonListCollection.GetDeletedListByIndex(i);
			AddStatementToSqlBatch(strBatchSql,	"DELETE FROM EmrInfoCommonListItemsT WHERE ListID = %d", list.GetID());
			AddStatementToSqlBatch(strBatchSql,	"DELETE FROM EmrInfoCommonListT WHERE ID = %d", list.GetID());
			bSomethingCriticalChanged = TRUE; // Ensure the query is committed

			// (c.haag 2011-03-25) - PLID 42999 - Auditing
			if(nAuditTransactionID == -1) { nAuditTransactionID = BeginAuditTransaction(); }
			AuditEvent(-1, "", nAuditTransactionID, aeiEmrInfoCommonList, m_nID, strName + " - " + list.GetName(), strName + " - <deleted>", aepMedium, aetDeleted);
		}
	}
	// E) Deleted list items
	{
		int nLists = m_CommonListCollection.GetListCount();
		for (int i=0; i < nLists; i++)
		{
			const CEmrInfoCommonList list = m_CommonListCollection.GetListByIndex(i);
			if (list.IsNew()) { continue; } // Skip new lists; we already took care of those

			// Now get the saved equivalent
			const CEmrInfoCommonList savedList = m_SavedCommonListCollection.GetListByID(list.GetID());

			int nItems = savedList.GetItemCount();
			for (int j=0; j < nItems; j++)
			{
				const CEmrInfoCommonListItem savedItem = savedList.GetItemByIndex(j);
				// savedItems are unchanged items, and we therefore must look to the EmrDataID and not a
				// CEmrInfoDataElement object.
				long nEmrDataID = savedItem.GetEmrDataID();
				// If the EMR data item doesn't exist in the current list, then remove it from data
				if (!list.DoesExist(nEmrDataID))	{
					AddStatementToSqlBatch(strBatchSql, "DELETE FROM EmrInfoCommonListItemsT WHERE ID = %d",
						savedItem.GetID());
					bSomethingCriticalChanged = TRUE; // Ensure the query is committed

					// (c.haag 2011-03-25) - PLID 42999 - Auditing
					if(nAuditTransactionID == -1) { nAuditTransactionID = BeginAuditTransaction(); }
					CString strItemName = savedItem.GetData();
					AuditEvent(-1, "", nAuditTransactionID, aeiEmrInfoCommonListItem, m_nID, strName + " - " + savedList.GetName() + " - " + strItemName
						,strName + " - " + savedList.GetName() + " - <deleted>", aepMedium, aetDeleted);
				}
			}
		}
	}

	

	CArray<long,long> arynDropdownToTextDataIDs;

	// Deal with the data elements
	
	// Everything related to the current state of data elements can be found in one or both of these 
	// two arrays: m_aryCurDataElements and m_aryCurDeletedDataElements.  First we just delete from 
	// data the contents of the latter array, m_aryCurDeletedDataElements.  Then we add/update the 
	// elements in the former array, m_aryCurDataElements.

	// Notice we use pointer arrays instead of actual CEmrInfoDataElementArrays; this is because we 
	// don't want to create whole new CEmrInfoDataElementArrays objects, we just want to point to 
	// the existing ones.
	if (bIsNew) {
		// We have to simply add all the elements from the cur array because they all must be new.  
		// But since the logic below does exactly that (it also tried to update any that already 
		// exist in data, but on a new info item there won't be any), we just leave it to that logic.
	}
	else
	{
		// Delete the elements that are in the "deleted" listing
		if (m_aryCurDeletedDataElements.GetSize() > 0)
		{
			// Get the list of ids to delete
			CArray<long,long> arynDataIDsToDelete;
			for (long i = 0; i < m_aryCurDeletedDataElements.GetSize(); i++)
			{
				CEmrInfoDataElement *peide = m_aryCurDeletedDataElements.GetAt(i);
				arynDataIDsToDelete.Add(peide->m_nID);

				//audit each deleted element
				if(!bIsNew) {
					long nItemType = aeiEMRItemListItemDeleted;
					CString strNewValue;
					if(peide->m_nListType == 1) {
						nItemType = aeiEMRItemListItemDeleted;
						strNewValue.Format("Deleted List Item: %s", peide->m_strData);
					}
					else if(peide->m_nListType == 2) {							
						nItemType = aeiEMRItemTableItemDeleted;
						strNewValue.Format("Deleted Table Row: %s", peide->m_strData);
					}
					else if(peide->m_nListType == LIST_TYPE_TEXT) {
						nItemType = aeiEMRItemTableItemDeleted;
						strNewValue.Format("Deleted Table Column (Text): %s", peide->m_strData);
					}
					else if(peide->m_nListType == LIST_TYPE_DROPDOWN) {
						nItemType = aeiEMRItemTableItemDeleted;
						strNewValue.Format("Deleted Table Column (Dropdown): %s", peide->m_strData);
					}
					else if(peide->m_nListType == LIST_TYPE_CHECKBOX) {
						nItemType = aeiEMRItemTableItemDeleted;
						strNewValue.Format("Deleted Table Column (Checkbox): %s", peide->m_strData);
					}
					else if(peide->m_nListType == LIST_TYPE_LINKED) {
						nItemType = aeiEMRItemTableItemDeleted;
						strNewValue.Format("Deleted Table Column (Linked): %s", peide->m_strData);
					}

					if(nAuditTransactionID == -1)
						nAuditTransactionID = BeginAuditTransaction();
					AuditEvent(-1, "", nAuditTransactionID, nItemType, m_nID, "Item: " + strName, strNewValue, aepHigh, aetDeleted);
				}
			}

			// Add the necessary statements to the batch
			bSomethingCriticalChanged = TRUE;
			
			// (z.manning 2013-03-11 11:52) - PLID 55554 - Moved this code to its own function.
			CSqlFragment sqlDeleteEmrData;
			GetDeleteEmrDataSql(CSqlFragment("{INTARRAY}", arynDataIDsToDelete), sqlDeleteEmrData);
			strBatchSql += sqlDeleteEmrData.Flatten();
		}
	}

	// (c.haag 2011-10-28) - PLID 46165 - Using m_aryDataElements.FindDataElement inside a loop is very
	// time consuming because it uses linear traversal. We can substitute it with a map instead for faster
	// traversal times. For large tables, populating the map and using it is faster than the old way of doing things.
	CMap<long,long,long,long> mapDataElements;
	for (int m=0; m < m_aryDataElements.GetSize(); m++)
	{
		mapDataElements[ m_aryDataElements[m]->m_nID ] = m;
	}

	{
		long IDIncrement = 1;
		//DRT 1/17/2007 - PLID 24181 - To allow XML generation of the EMRActionChargeDataT, we need to be able
		//	to generate the ID of the action itself.  This value does not need to be modified in this function, the
		//	generation function will have to increment it, as there can be multiple actions per list item.
		long nActionIDIncrement= 1;

		// Now loop through the data element list.  The ones marked for addition are obvious, we just have to 
		// add them.  However, the ones that already have IDs we have to find the original and compare.
		{
			// First loop through and extract the new ones into xml, and while you're at it see if there are any that need to be
			CString strXmlNewDataElements;
			{
				// (a.walling 2007-11-05 16:08) - PLID 27980 - VS2008 - for() loops
				long i = 0;

				for (i=0; i<m_aryCurDataElements.GetSize(); i++) {
					CEmrInfoDataElement *peide = m_aryCurDataElements.GetAt(i);
					if (peide->m_nID == -1) {
						// It's new so add it to our "new" xml
						strXmlNewDataElements += peide->GenerateXml(AsString(IDIncrement++), nActionIDIncrement);
						if(IsDlgButtonChecked(IDC_RADIO_LIST_SELECT) || IsDlgButtonChecked(IDC_RADIO_LIST_MULTISELECT)) {
							m_bListDataWasAdded = TRUE;
						}

						if(!bIsNew) {
							//audit the element creation, based on the element type it is
							long nItemType = aeiEMRItemListItemCreated;
							CString strNewValue;
							if(peide->m_nListType == 1) {
								nItemType = aeiEMRItemListItemCreated;
								strNewValue.Format("New List Item: %s", peide->m_strData);
							}
							else if(peide->m_nListType == 2) {							
								nItemType = aeiEMRItemTableItemCreated;
								strNewValue.Format("New Table Row: %s", peide->m_strData);
							}
							else {
								//would mean it's a column, which shouldn't be possible
								ASSERT(FALSE);
							}
							if(nAuditTransactionID == -1)
								nAuditTransactionID = BeginAuditTransaction();
							AuditEvent(-1, "", nAuditTransactionID, nItemType, m_nID, "Item: " + strName, strNewValue, aepMedium, aetCreated);
						}

					} else {
						// We're assuming if it wasn't new, it must be existing
						ASSERT(!bIsNew);
						ASSERT(peide->m_nID > 0);
						// So get the original for comparison purposes
						// (c.haag 2011-10-28) - PLID 46165 - FindDataElement does a linear search. Use a map for efficiency.
						long nOrig = -1; //m_aryDataElements.FindDataElement(peide->m_nID, 0);
						mapDataElements.Lookup(peide->m_nID, nOrig);

						if (nOrig != -1) {
							// Compare
							CEmrInfoDataElement *peideOriginal = m_aryDataElements.GetAt(nOrig);
							
							// Basic fields are simmilar to the emrinfot basic fields up above
							CString strUpdateString;
							CString strGroupUpdateString;
							if (peideOriginal->m_strData != peide->m_strData) {
								strUpdateString += FormatString("Data = '%s', ", _Q(peide->m_strData));
								bSomethingCriticalChanged = TRUE;

								if(!bIsNew) {

									//audit the name change						

									long nItemType = aeiEMRItemListItemName;
									CString strOldValue, strNewValue;
									if(peide->m_nListType == 1) {
										nItemType = aeiEMRItemListItemName;
										strOldValue.Format("Item: '%s' - List Item: %s", strName, peideOriginal->m_strData);
										strNewValue.Format("List Item: %s", peide->m_strData);
									}
									else if(peide->m_nListType == 2) {							
										nItemType = aeiEMRItemTableItemName;
										strOldValue.Format("Item: '%s' - Table Row: %s", strName, peideOriginal->m_strData);
										strNewValue.Format("Table Row: %s", peide->m_strData);
									}

									if(nAuditTransactionID == -1)
										nAuditTransactionID = BeginAuditTransaction();
									AuditEvent(-1, "", nAuditTransactionID, nItemType, m_nID, strOldValue, strNewValue, aepHigh, aetChanged);

									// (c.haag 2007-01-30 09:22) - PLID 24423 - If this is the system Current Medications
									// item, we need to also update the name in the drug list table
									// (c.haag 2007-02-02 16:15) - PLID 24561 - The DrugList table no longer has a name field
									//if (IsSystemCurrentMedicationsItem()) {
									//	AddStatementToSqlBatch(strBatchSql, "UPDATE DrugList SET Name = '%s' WHERE EMRDataID = %d",
									//		_Q(peide->m_strData), peide->m_nID);
									//}
								}
							}
							if (peideOriginal->m_nSortOrder != peide->m_nSortOrder) {
								
								strUpdateString += FormatString("SortOrder = %li, ", peide->m_nSortOrder);

								if(!bIsNew) {
									//audit the change

									long nItemType = aeiEMRItemListItemSortOrder;
									CString strOldValue, strNewValue;
									if(peide->m_nListType == 1) {
										nItemType = aeiEMRItemListItemSortOrder;
										strOldValue.Format("Item: '%s' - List Item: %s (Order: %li)", strName, peideOriginal->m_strData, peideOriginal->m_nSortOrder);
										strNewValue.Format("List Item: %s (Order: %li)", peide->m_strData, peide->m_nSortOrder);
									}
									else if(peide->m_nListType == 2) {							
										nItemType = aeiEMRItemTableItemSortOrder;
										strOldValue.Format("Item: '%s' - Table Row: %s (Order: %li)", strName, peideOriginal->m_strData, peideOriginal->m_nSortOrder);
										strNewValue.Format("Table Row: %s (Order: %li)", peide->m_strData, peide->m_nSortOrder);
									}

									if(nAuditTransactionID == -1)
										nAuditTransactionID = BeginAuditTransaction();
									AuditEvent(-1, "", nAuditTransactionID, nItemType, m_nID, strOldValue, strNewValue, aepMedium, aetChanged);
								}
							}
							if ((peideOriginal->m_bIsGrouped && !peide->m_bIsGrouped) || (!peideOriginal->m_bIsGrouped && peide->m_bIsGrouped)) {
								strUpdateString += FormatString("IsGrouped = %li, ", peide->m_bIsGrouped ? 1 : 0);

								if(!bIsNew) {
									if(nAuditTransactionID == -1)
										nAuditTransactionID = BeginAuditTransaction();
									
									CString strOldValue, strNewValue;
									if(peideOriginal->m_bIsGrouped)
										strOldValue.Format("Enabled for Item: '%s' - List Item: '%s'", strName, peideOriginal->m_strData);
									else 
										strOldValue.Format("Disabled for Item: '%s' - List Item: '%s'", strName, peideOriginal->m_strData);
									if(peide->m_bIsGrouped)
										strNewValue.Format("Enabled for Item: '%s' - List Item: '%s'", strName, peide->m_strData);
									else 
										strNewValue.Format("Disabled for Item: '%s' - List Item: '%s'", strName, peide->m_strData);
									AuditEvent(-1, "", nAuditTransactionID, aeiEMRItemDetailIsGrouped, m_nID, strOldValue, strNewValue, aepLow, aetChanged);
								}
							}
							if ((peideOriginal->m_bInactive && !peide->m_bInactive) || (!peideOriginal->m_bInactive && peide->m_bInactive)) {
								strUpdateString += FormatString("Inactive = %li, ", peide->m_bInactive ? 1 : 0);

								if(peide->m_bInactive) {
									// (z.manning, 05/30/2008) - PLID 16443 - Inactive data elements should
									// NOT have formulas.
									ASSERT(peide->m_strFormula.IsEmpty());
								}

								if(!bIsNew) {
									//audit the change

									long nItemType = aeiEMRItemListItemInactive;
									CString strOldValue, strNewValue;
									if(peide->m_nListType == 1) {
										nItemType = aeiEMRItemListItemInactive;
										strOldValue.Format("Item: '%s' - List Item: %s (%s)", strName, peideOriginal->m_strData, peideOriginal->m_bInactive ? "Inactive" : "Active");
										strNewValue.Format("List Item: %s (%s)", peide->m_strData, peide->m_bInactive ? "Inactive" : "Active");
									}
									else if(peide->m_nListType == 2) {							
										nItemType = aeiEMRItemTableItemInactive;
										strOldValue.Format("Item: '%s' - Table Row: %s (%s)", strName, peideOriginal->m_strData, peideOriginal->m_bInactive ? "Inactive" : "Active");
										strNewValue.Format("Table Row: %s (%s)", peide->m_strData, peide->m_bInactive ? "Inactive" : "Active");
									}

									if(nAuditTransactionID == -1)
										nAuditTransactionID = BeginAuditTransaction();
									AuditEvent(-1, "", nAuditTransactionID, nItemType, m_nID, strOldValue, strNewValue, aepMedium, aetChanged);

									// (c.haag 2007-01-30 09:22) - PLID 24423 - If this is the system Current Medications
									// item, we need to also update the Inactive flag for the drug list table
									// (c.haag 2007-02-07 14:00) - PLID 24565 - The DrugList table no longer has an Inactive column
									/*if (IsSystemCurrentMedicationsItem()) {
										AddStatementToSqlBatch(strBatchSql, "UPDATE DrugList SET Inactive = %d WHERE EMRDataID = %d",
											peide->m_bInactive ? 1 : 0, peide->m_nID);
									}*/
								}

							}

							// (j.jones 2007-08-15 14:01) - PLID 27053 - added UseEMCoding
							if((peideOriginal->m_bUseEMCoding && !peide->m_bUseEMCoding) || (!peideOriginal->m_bUseEMCoding && peide->m_bUseEMCoding)) {
								strGroupUpdateString += FormatString("UseEMCoding = %li, ", peide->m_bUseEMCoding ? 1 : 0);

								if(!bIsNew) {
									if(nAuditTransactionID == -1)
										nAuditTransactionID = BeginAuditTransaction();
									CString strNewValue;
									strNewValue.Format("%s E/M status on Item: '%s' - Table Row: '%s'", peide->m_bUseEMCoding ? "Enabled" : "Disabled", strName, peide->m_strData);
									AuditEvent(-1, "", nAuditTransactionID, aeiEMRItemTableItemUseEMCoding, m_nID, "", strNewValue, aepMedium, aetChanged);
								}
							}

							// (j.jones 2011-03-08 12:25) - PLID 42282 - added EMCodeCategoryID
							if(peideOriginal->m_nEMCodeCategoryID != peide->m_nEMCodeCategoryID) {

								strGroupUpdateString += FormatString("EMCodeCategoryID = %s, ", peide->m_nEMCodeCategoryID == -1 ? "NULL" : AsString(peide->m_nEMCodeCategoryID));

								if(!bIsNew) {
									if(nAuditTransactionID == -1) {
										nAuditTransactionID = BeginAuditTransaction();
									}

									CString strOldValue, strOldCategory = "<None Selected>", strNewCategory = "<None Selected>";
									_RecordsetPtr rsEMCodeCats = CreateParamRecordset("SELECT Name FROM EMCodeCategoryT WHERE ID = {INT} \r\n"
										"SELECT Name FROM EMCodeCategoryT WHERE ID = {INT} \r\n", peideOriginal->m_nEMCodeCategoryID, peide->m_nEMCodeCategoryID);
									if(!rsEMCodeCats->eof) {
										strOldCategory = VarString(rsEMCodeCats->Fields->Item["Name"]->Value);
									}
									rsEMCodeCats = rsEMCodeCats->NextRecordset(NULL);
									if(!rsEMCodeCats->eof) {
										strNewCategory = VarString(rsEMCodeCats->Fields->Item["Name"]->Value);
									}
									rsEMCodeCats->Close();

									strOldValue.Format("Item: '%s' - Table Row: %s (E/M Category: %s)", strName, peideOriginal->m_strData, strOldCategory);
									AuditEvent(-1, "", nAuditTransactionID, aeiEMRItemTableItemEMCodeCategoryID, m_nID, strOldValue, strNewCategory, aepMedium, aetChanged);
								}
							}

							// (j.gruber 2010-04-27 08:39) - PLID 38336 - BOLD Code
							if(peideOriginal->m_strBoldCode != peide->m_strBoldCode) {
								strUpdateString += FormatString("BOLDCode = '%s', ", _Q(peide->m_strBoldCode));

								if(!bIsNew) {
									if(nAuditTransactionID == -1) {
										nAuditTransactionID = BeginAuditTransaction();
									}
									//(a.wilson 2011-9-1) PLID 45307 - Reworded from BOLD to Export
									CString strOldValue, strNewValue;
									strOldValue.Format("Export Code for Item: '%s' - List Item: '%s' - %s", strName, peideOriginal->m_strData, peideOriginal->m_strBoldCode);
									strNewValue.Format("Export Code for Item: '%s' - List Item: '%s' - %s", strName, peide->m_strData, peide->m_strBoldCode);
									AuditEvent(-1, "", nAuditTransactionID, aeiEMRItemBOLDCode, m_nID, strOldValue, strNewValue, aepMedium, aetChanged);
								}
							}

							if (peideOriginal->m_nListType != peide->m_nListType) {
								strUpdateString += FormatString("ListType = %li, ", peide->m_nListType);

								//this doesn't need audited because this only changes when the info item
								//data type changes from List to Table or vice versa
							}
							if (peideOriginal->m_strLongForm != peide->m_strLongForm) {
								strUpdateString += FormatString("LongForm = '%s', ", _Q(peide->m_strLongForm));

								if(!bIsNew) {
									if(nAuditTransactionID == -1)
										nAuditTransactionID = BeginAuditTransaction();
									CString strOldValue, strNewValue;
									strOldValue.Format("'%s' for Item: '%s' - List Item: '%s'", peideOriginal->m_strLongForm, strName, peideOriginal->m_strData);
									strNewValue.Format("'%s' for Item: '%s' - List Item: '%s'", peide->m_strLongForm, strName, peide->m_strData);
									AuditEvent(-1, "", nAuditTransactionID, aeiEMRItemDetailSentenceFormat, m_nID, strOldValue, strNewValue, aepMedium, aetChanged);
								}								
							}
							if((peideOriginal->m_bIsLabel && !peide->m_bIsLabel) || (!peideOriginal->m_bIsLabel && peide->m_bIsLabel)) {
								strUpdateString += FormatString("IsLabel = %li, ", peide->m_bIsLabel ? 1 : 0);
								AddStatementToSqlBatch(strBatchSql, "DELETE FROM EmrTemplateSelectT WHERE EmrDataID = %li", peide->m_nID);
								// (z.manning 2010-04-20 11:03) - PLID 29301 - Table rows can also be labels
								AddStatementToSqlBatch(strBatchSql, "DELETE FROM EMRTemplateTableDefaultsT WHERE EmrDataID_X = %li OR EmrDataID_Y = %li", peide->m_nID, peide->m_nID);

								// (j.jones 2008-10-22 17:32) - PLID 31692 - Delete any EMR Analysis details that reference this data item.
								// Do not delete their master records, even if there are no details left in them.
								if(peide->m_bIsLabel) {
									AddStatementToSqlBatch(strBatchSql, "DELETE FROM EMRAnalysisConfigDetailsT WHERE EMRDataGroupID IN (SELECT EMRDataGroupID FROM EMRDataT WHERE ID = %li)", peide->m_nID);
								}

								if(!bIsNew) {
									if(nAuditTransactionID == -1)
										nAuditTransactionID = BeginAuditTransaction();
									CString strNewValue;
									strNewValue.Format("%s Label status on Item: '%s' - List Item: '%s'", peide->m_bIsLabel ? "Enabled" : "Disabled", strName, peide->m_strData);
									AuditEvent(-1, "", nAuditTransactionID, aeiEMRItemDetailIsLabel, m_nID, "", strNewValue, aepLow, aetChanged);
								}
							}
							// (z.manning, 06/02/2008) - PLID 16443 - Formula
							if(peideOriginal->m_strFormula != peide->m_strFormula) {
								strUpdateString += FormatString("Formula = '%s', ", _Q(peide->m_strFormula));

								if(!bIsNew) {
									if(nAuditTransactionID == -1) {
										nAuditTransactionID = BeginAuditTransaction();
									}
									CString strOldValue, strNewValue;
									strOldValue.Format("Formula for Item: '%s' - List Item: '%s' - %s", strName, peideOriginal->m_strData, peideOriginal->m_strFormula);
									strNewValue.Format("Formula for Item: '%s' - List Item: '%s' - %s", strName, peide->m_strData, peide->m_strFormula);
									AuditEvent(-1, "", nAuditTransactionID, aeiEMRItemDetailFormula, m_nID, strOldValue, strNewValue, aepMedium, aetChanged);
								}
							}
							// (z.manning, 06/02/2008) - PLID 16443 - DecimalPlaces
							if(peideOriginal->m_nDecimalPlaces != peide->m_nDecimalPlaces) {
								strUpdateString += FormatString("DecimalPlaces = %li, ", peide->m_nDecimalPlaces);

								if(!bIsNew) {
									if(nAuditTransactionID == -1) {
										nAuditTransactionID = BeginAuditTransaction();
									}
									CString strOldValue, strNewValue;
									strOldValue.Format("Decimal places for Item: '%s' - List Item: '%s' - %li", strName, peideOriginal->m_strData, peideOriginal->m_nDecimalPlaces);
									strNewValue.Format("Decimal places for Item: '%s' - List Item: '%s' - %li", strName, peide->m_strData, peide->m_nDecimalPlaces);
									AuditEvent(-1, "", nAuditTransactionID, aeiEMRItemDetailDecimalPlaces, m_nID, strOldValue, strNewValue, aepMedium, aetChanged);
								}
							}

							// (z.manning 2011-05-26 15:05) - PLID 43865 - DataFlags
							if(peideOriginal->m_nFlags != peide->m_nFlags)
							{
								strUpdateString += FormatString("DataFlags = %li, ", peide->m_nFlags);

								if(!bIsNew) {
									if(nAuditTransactionID == -1) {
										nAuditTransactionID = BeginAuditTransaction();
									}
									CString strOldValue, strNewValue;
									BOOL bOld = ((peideOriginal->m_nFlags & edfFormulaForTransform) != 0);
									BOOL bNew = ((peide->m_nFlags & edfFormulaForTransform) != 0);
									if(bOld != bNew) {
										strOldValue.Format("Item: '%s' - List Item: '%s' - %s", strName, peideOriginal->m_strData, bOld ? "Yes" : "No");
										strNewValue.Format("Item: '%s' - List Item: '%s' - %s", strName, peide->m_strData, bNew ? "Yes" : "No");
										AuditEvent(-1, "", nAuditTransactionID, aeiEmrDataFormulaForTransform, m_nID, strOldValue, strNewValue, aepMedium, aetChanged);
									}
									bOld = ((peideOriginal->m_nFlags & edfShowPlusSign) != 0);
									bNew = ((peide->m_nFlags & edfShowPlusSign) != 0);
									if(bOld != bNew) {
										strOldValue.Format("Item: '%s' - List Item: '%s' - %s", strName, peideOriginal->m_strData, bOld ? "Yes" : "No");
										strNewValue.Format("Item: '%s' - List Item: '%s' - %s", strName, peide->m_strData, bNew ? "Yes" : "No");
										AuditEvent(-1, "", nAuditTransactionID, aeiEmrDataShowPlusSign, m_nID, strOldValue, strNewValue, aepMedium, aetChanged);
									}
								}
							}

							// (z.manning 2009-01-15 15:03) - PLID 32724 - Rows cannot currently have input masks
							ASSERT(peide->m_strInputMask.IsEmpty());

							//TES 3/11/2011 - PLID 42757 - Added Glasses Order data
							bool bAuditGlassesOrder = false;
							if(peideOriginal->m_GlassesOrderDataType != peide->m_GlassesOrderDataType) {
								strUpdateString += FormatString("GlassesOrderDataType = %s, ", peide->m_GlassesOrderDataType == godtInvalid ? "NULL" : AsString((long)peide->m_GlassesOrderDataType));
								bAuditGlassesOrder = true;
							}
							if(peideOriginal->m_nGlassesOrderDataID != peide->m_nGlassesOrderDataID) {
								strUpdateString += FormatString("GlassesOrderDataID = %s, ", peide->m_nGlassesOrderDataID == -1 ? "NULL" : AsString(peide->m_nGlassesOrderDataID));
								bAuditGlassesOrder = true;
							}
							if(bAuditGlassesOrder && !bIsNew) {
								if(nAuditTransactionID == -1) {
									nAuditTransactionID = BeginAuditTransaction();
								}
								CString strOldValue, strNewValue;
								strOldValue.Format("Item: '%s' - List Item: '%s' - %s", strName, peideOriginal->m_strData, GetGlassesOrderRecordDescription(peideOriginal->m_GlassesOrderDataType, peideOriginal->m_nGlassesOrderDataID, true));
								strNewValue.Format("Item: '%s' - List Item: '%s' - %s", strName, peide->m_strData, GetGlassesOrderRecordDescription(peide->m_GlassesOrderDataType, peide->m_nGlassesOrderDataID, true));
								AuditEvent(-1, "", nAuditTransactionID, aeiEMRItemGlassesOrderRecord, m_nID, strOldValue, strNewValue, aepMedium, aetChanged);
							}

							// (z.manning 2011-03-21 10:01) - PLID 23662 - Autofill type
							if(peideOriginal->m_eAutofillType != peide->m_eAutofillType)
							{
								strUpdateString += FormatString("AutofillType = %li, ", peide->m_eAutofillType);

								if(!bIsNew) {
									if(nAuditTransactionID == -1) {
										nAuditTransactionID = BeginAuditTransaction();
									}
									CString strOldValue, strNewValue;
									strOldValue.Format("Item: '%s' - List Item: '%s' - %s", strName, peideOriginal->m_strData, GetAutofillTypeDescription(peideOriginal->m_eAutofillType));
									strNewValue.Format("Item: '%s' - List Item: '%s' - %s", strName, peide->m_strData, GetAutofillTypeDescription(peide->m_eAutofillType));
									AuditEvent(-1, "", nAuditTransactionID, aeiEmrTableAutofillType, m_nID, strOldValue, strNewValue, aepMedium, aetChanged);
								}
							}

							// (z.manning 2011-09-19 13:27) - PLID 41954 - DropdownSeparator
							if(peideOriginal->m_strDropdownSeparator != peide->m_strDropdownSeparator)
							{
								strUpdateString += FormatString("DropdownSeparator = '%s', ", _Q(peide->m_strDropdownSeparator));

								if(!bIsNew) {
									if(nAuditTransactionID == -1) {
										nAuditTransactionID = BeginAuditTransaction();
									}
									CString strOldValue, strNewValue;
									strOldValue.Format("Item: '%s' - List Item: '%s' - %s", strName, peideOriginal->m_strData, peideOriginal->m_strDropdownSeparator);
									strNewValue.Format("Item: '%s' - List Item: '%s' - %s", strName, peide->m_strData, peide->m_strDropdownSeparator);
									AuditEvent(-1, "", nAuditTransactionID, aeiEmrDropdownSeparator, m_nID, strOldValue, strNewValue, aepMedium, aetChanged);
								}
							}

							// (z.manning 2011-09-19 13:27) - PLID 41954 - DropdownSeparatorFinal
							if(peideOriginal->m_strDropdownSeparatorFinal != peide->m_strDropdownSeparatorFinal)
							{
								strUpdateString += FormatString("DropdownSeparatorFinal = '%s', ", _Q(peide->m_strDropdownSeparatorFinal));

								if(!bIsNew) {
									if(nAuditTransactionID == -1) {
										nAuditTransactionID = BeginAuditTransaction();
									}
									CString strOldValue, strNewValue;
									strOldValue.Format("Item: '%s' - List Item: '%s' - %s", strName, peideOriginal->m_strData, peideOriginal->m_strDropdownSeparatorFinal);
									strNewValue.Format("Item: '%s' - List Item: '%s' - %s", strName, peide->m_strData, peide->m_strDropdownSeparatorFinal);
									AuditEvent(-1, "", nAuditTransactionID, aeiEmrDropdownSeparatorFinal, m_nID, strOldValue, strNewValue, aepMedium, aetChanged);
								}
							}

							// (z.manning 2011-11-07 10:51) - PLID 46309 - SpawnedItemsSeparator
							if(peideOriginal->m_strSpawnedItemsSeparator != peide->m_strSpawnedItemsSeparator)
							{
								strUpdateString += FormatString("SpawnedItemsSeparator = '%s', ", _Q(peide->m_strSpawnedItemsSeparator));

								if(!bIsNew) {
									if(nAuditTransactionID == -1) {
										nAuditTransactionID = BeginAuditTransaction();
									}
									CString strOldValue, strNewValue;
									strOldValue.Format("Item: '%s' - List Item: '%s' - %s", strName, peideOriginal->m_strData, peideOriginal->m_strSpawnedItemsSeparator);
									strNewValue.Format("Item: '%s' - List Item: '%s' - %s", strName, peide->m_strData, peide->m_strSpawnedItemsSeparator);
									AuditEvent(-1, "", nAuditTransactionID, aeiEmrSpawnedItemsSeparator, m_nID, strOldValue, strNewValue, aepMedium, aetChanged);
								}
							}
							// (r.gonet 08/03/2012) - PLID 51735 - Audit the change of the Wound Care Data Type assignments.
							if(peideOriginal->m_ewccWoundCareDataType != peide->m_ewccWoundCareDataType)
							{
								strUpdateString += FormatString("WoundCareDataType = %li, ", (long)peide->m_ewccWoundCareDataType);

								if(!bIsNew) {
									if(nAuditTransactionID == -1) {
										nAuditTransactionID = BeginAuditTransaction();
									}
									CString strOldValue, strNewValue;
									strOldValue.Format("Item: '%s' - List Item: '%s' - %s", strName, peideOriginal->m_strData, GetWoundCareDataTypeDescription(peideOriginal->m_ewccWoundCareDataType));
									strNewValue.Format("Item: '%s' - List Item: '%s' - %s", strName, peide->m_strData, GetWoundCareDataTypeDescription(peide->m_ewccWoundCareDataType));
									AuditEvent(-1, "", nAuditTransactionID, aeiEMRItemWoundCareDataType, m_nID, strOldValue, strNewValue, aepMedium, aetChanged);
								}
							}

							// (j.gruber 2014-07-18 14:19) - PLID 62624 - Keyword Saving
							if (peideOriginal->m_bUseKeyword != peide->m_bUseKeyword)
							{
								strUpdateString += FormatString("UseKeyword = %li, ", peide->m_bUseKeyword ? 1 : 0);

								if (!bIsNew)
								{
									if (nAuditTransactionID == -1)
									{
										nAuditTransactionID = BeginAuditTransaction();
									}
									CString strOldValue, strNewValue;
									strOldValue.Format("Item: '%s' - List Item: '%s' - %s", strName, peideOriginal->m_strData, peideOriginal->m_bUseKeyword ? "Checked" : "Unchecked");
									strNewValue.Format("Item: '%s' - List Item: '%s' - %s", strName, peide->m_strData, peide->m_bUseKeyword ? "Checked" : "Unchecked");
									AuditEvent(-1, "", nAuditTransactionID, aeiEMRDataUseKeyword, m_nID, strOldValue, strNewValue, aepMedium, aetChanged);
								}
							}
							
							if (peideOriginal->m_strKeywordOverride != peide->m_strKeywordOverride)
							{
								strUpdateString += FormatString("KeywordOverride = '%s', ", _Q(peide->m_strKeywordOverride));

								if (!bIsNew)
								{
									if (nAuditTransactionID == -1)
									{
										nAuditTransactionID = BeginAuditTransaction();
									}
									CString strOldValue, strNewValue;
									strOldValue.Format("Item: '%s' - List Item: '%s' - %s", strName, peideOriginal->m_strData, peideOriginal->m_strKeywordOverride);
									strNewValue.Format("Item: '%s' - List Item: '%s' - %s", strName, peide->m_strData, peide->m_strKeywordOverride);
									AuditEvent(-1, "", nAuditTransactionID, aeiEMRDataKeywordOverride, m_nID, strOldValue, strNewValue, aepMedium, aetChanged);
								}
							}	

							// (j.gruber 2014-12-05 16:08) - PLID 64289 - search queue - Saving
							if (peideOriginal->m_bUseNameForKeyword != peide->m_bUseNameForKeyword)
							{
								strUpdateString += FormatString("UseNameForKeyword = %li, ", peide->m_bUseNameForKeyword ? 1 : 0);

								if (!bIsNew)
								{
									if (nAuditTransactionID == -1)
									{
										nAuditTransactionID = BeginAuditTransaction();
									}
									CString strOldValue, strNewValue;
									strOldValue.Format("Item: '%s' - List Item: '%s' - %s", strName, peideOriginal->m_strData, peideOriginal->m_bUseNameForKeyword ? "Checked" : "Unchecked");
									strNewValue.Format("Item: '%s' - List Item: '%s' - %s", strName, peide->m_strData, peide->m_bUseNameForKeyword ? "Checked" : "Unchecked");
									AuditEvent(-1, "", nAuditTransactionID, aeiEMRDataUseNameForKeyword, m_nID, strOldValue, strNewValue, aepMedium, aetChanged);
								}
							}

							// Ok, now see if we need to write any of the fields to data
							if (!strUpdateString.IsEmpty()) {
								// Drop off the final comma
								strUpdateString.Delete(strUpdateString.GetLength() - 2, 2);
								// And add the update statement
								bSomethingCriticalChanged = TRUE;
								AddStatementToSqlBatch(strBatchSql, "UPDATE EMRDataT SET %s WHERE ID = %li", strUpdateString, peide->m_nID);
							}

							// (j.jones 2007-08-15 14:06) - PLID 27053 - write to EMRDataGroupsT
							if (!strGroupUpdateString.IsEmpty()) {
								// Drop off the final comma
								strGroupUpdateString.Delete(strGroupUpdateString.GetLength() - 2, 2);
								// And add the update statement
								bSomethingMinorChanged = TRUE;
								AddStatementToSqlBatch(strBatchSql, "UPDATE EMRDataGroupsT SET %s WHERE ID IN (SELECT EMRDataGroupID FROM EMRDataT WHERE ID = %li)", strGroupUpdateString, peide->m_nID);
							}

							if (peideOriginal->m_bDefault && !peide->m_bDefault) {
								AddStatementToSqlBatch(strBatchSql, "DELETE FROM EMRInfoDefaultsT WHERE EMRDataID = %li", peide->m_nID);
								bSomethingCriticalChanged = TRUE;

								if(!bIsNew) {
									if(nAuditTransactionID == -1)
										nAuditTransactionID = BeginAuditTransaction();
									CString strNewValue;
									strNewValue.Format("Removed Default status from Item: '%s' - List Item: '%s'", strName, peide->m_strData);
									AuditEvent(-1, "", nAuditTransactionID, aeiEMRItemDetailIsDefault, m_nID, "", strNewValue, aepMedium, aetChanged);
								}
							}
							
							if (!peideOriginal->m_bDefault && peide->m_bDefault) {
								AddStatementToSqlBatch(strBatchSql, "INSERT INTO EMRInfoDefaultsT (EMRInfoID, EMRDataID) VALUES (%li,%li)", m_nID, peide->m_nID);
								bSomethingCriticalChanged = TRUE;

								if(!bIsNew) {
									if(nAuditTransactionID == -1)
										nAuditTransactionID = BeginAuditTransaction();
									CString strNewValue;
									strNewValue.Format("Added Default status to Item: '%s' - List Item: '%s'", strName, peide->m_strData);
									AuditEvent(-1, "", nAuditTransactionID, aeiEMRItemDetailIsDefault, m_nID, "", strNewValue, aepMedium, aetChanged);
								}
							}

							// (j.gruber 2013-10-02 10:18) - PLID 58674 - Codes on multi and single selects
							if (peide->m_aryCodes.IsDifferent(&peideOriginal->m_aryCodes))
							{
								//we don't want to branch if only the codes changed, since its on the data groupID, so reflect that
								bSomethingMinorChanged = TRUE;

								//something changed in the codes, remove the old ones and add the new ones back in
								AddStatementToSqlBatch(strBatchSql, "DELETE FROM EMRDataGroupCodesT WHERE EMRDataGroupID = %li", peide->m_nDataGroupID);								

								for (int nCodeIndex = 0; nCodeIndex < peide->m_aryCodes.GetSize(); nCodeIndex++) {
									CEMRCode code = peide->m_aryCodes.GetAt(nCodeIndex);
									AddStatementToSqlBatch(strBatchSql, "INSERT INTO EMRDataGroupCodesT (EMRDataGroupID, CodeID) VALUES(%li, %li) ", peide->m_nDataGroupID, code.GetID());
								}

								//now audit
								if(!bIsNew) {
									if(nAuditTransactionID == -1)
										nAuditTransactionID = BeginAuditTransaction();
									CString strNewValue, strOldValue;
									strOldValue.Format("EMR Codes changed on Item: '%s' - List Item: '%s' Codes: %s", strName, peide->m_strData, peideOriginal->m_aryCodes.GetCodeString());
									strNewValue.Format("Codes: %s", peide->m_aryCodes.GetCodeString());
									AuditEvent(-1, "", nAuditTransactionID, aeiEMRTemplateDetailCode, m_nID, strOldValue, strNewValue, aepMedium, aetChanged);
								}
							}

							// And now see about the data elements' actions
							{
								if (AddStatementToSqlBatch_EmrActionChanges(strBatchSql, eaoEmrDataItem, AsString(peide->m_nID), peideOriginal->m_arActions, peide->m_arActions, nAuditTransactionID)) {
									bSomethingCriticalChanged = TRUE;
								}
							}	
						} else {
							// This should be impossible, because if it isn't new, then it has to be in the original list!
							ASSERT(FALSE);
							ThrowNxException("Could not find original data element with ID %li referenced by the current list!", peide->m_nID);
						}
					}
				}

				for (i=0; i<m_aryCurColumnDataElements.GetSize(); i++) {
					CEmrInfoDataElement *peide = m_aryCurColumnDataElements.GetAt(i);
					if (peide->m_nID == -1) {
						// It's new so add it to our "new" xml
						strXmlNewDataElements += peide->GenerateXml(AsString(IDIncrement++), nActionIDIncrement);

						if(!bIsNew) {
							//audit the element creation, based on the element type it is
							CString strNewValue;
							if(peide->m_nListType == LIST_TYPE_TEXT) {
								strNewValue.Format("New Table Column (Text): %s", peide->m_strData);
							}
							else if(peide->m_nListType == LIST_TYPE_DROPDOWN) {
								strNewValue.Format("New Table Column (Dropdown): %s", peide->m_strData);
							}
							else if(peide->m_nListType == LIST_TYPE_CHECKBOX) {
								strNewValue.Format("New Table Column (Checkbox): %s", peide->m_strData);
							}
							else if(peide->m_nListType == LIST_TYPE_LINKED) {
								strNewValue.Format("New Table Column (Linked): %s", peide->m_strData);
							}
							else {
								//would mean it's a row, which shouldn't be possible
								ASSERT(FALSE);
							}

							if(nAuditTransactionID == -1)
								nAuditTransactionID = BeginAuditTransaction();
							AuditEvent(-1, "", nAuditTransactionID, aeiEMRItemTableItemCreated, m_nID, "Item: " + strName, strNewValue, aepMedium, aetCreated);
						}

					} else {
						// We're assuming if it wasn't new, it must be existing
						ASSERT(!bIsNew);
						ASSERT(peide->m_nID > 0);
						// So get the original for comparison purposes
						long nOrig = m_aryColumnDataElements.FindDataElement(peide->m_nID, 0);

						if (nOrig != -1) {
							// Compare
							CEmrInfoDataElement *peideOriginal = m_aryColumnDataElements.GetAt(nOrig);
							
							// Basic fields are simmilar to the emrinfot basic fields up above
							CString strUpdateString;
							CString strGroupUpdateString;
							if (peideOriginal->m_strData != peide->m_strData) {
								strUpdateString += FormatString("Data = '%s', ", _Q(peide->m_strData));
								bSomethingCriticalChanged = TRUE;

								if(!bIsNew) {
									//audit the name change
									
									CString strOldValue, strNewValue;
									strOldValue.Format("Item: '%s' - Table Column: %s", strName, peideOriginal->m_strData);
									strNewValue.Format("Table Column: %s", peide->m_strData);

									if(nAuditTransactionID == -1)
										nAuditTransactionID = BeginAuditTransaction();
									AuditEvent(-1, "", nAuditTransactionID, aeiEMRItemTableItemName, m_nID, strOldValue, strNewValue, aepHigh, aetChanged);
								}
							}
							if (peideOriginal->m_nSortOrder != peide->m_nSortOrder) {
								strUpdateString += FormatString("SortOrder = %li, ", peide->m_nSortOrder);

								if(!bIsNew) {
									//audit the change

									CString strOldValue, strNewValue;
									strOldValue.Format("Item: '%s' - Table Column: %s (Order: %li)", strName, peideOriginal->m_strData, peideOriginal->m_nSortOrder);
									strNewValue.Format("Table Column: %s (Order: %li)", peide->m_strData, peide->m_nSortOrder);

									if(nAuditTransactionID == -1)
										nAuditTransactionID = BeginAuditTransaction();
									AuditEvent(-1, "", nAuditTransactionID, aeiEMRItemTableItemSortOrder, m_nID, strOldValue, strNewValue, aepMedium, aetChanged);
								}
							}

							// (z.manning 2013-04-09 13:24) - PLID 56159 - This code used to reference EmrDataT.Default,
							// and no such field exists. So even though the default option isn't for table columns, I 
							// went ahead and fixed it as weird data could cause it to be hit.
							if (peideOriginal->m_bDefault && !peide->m_bDefault)
							{
								AddStatementToSqlBatch(strBatchSql, "DELETE FROM EMRInfoDefaultsT WHERE EMRDataID = %li", peide->m_nID);
								bSomethingCriticalChanged = TRUE;

								if(!bIsNew) {
									if(nAuditTransactionID == -1)
										nAuditTransactionID = BeginAuditTransaction();
									CString strNewValue;
									strNewValue.Format("Removed Default status from Item: '%s' - Table Column: '%s'", strName, peide->m_strData);
									AuditEvent(-1, "", nAuditTransactionID, aeiEMRItemDetailIsDefault, m_nID, "", strNewValue, aepMedium, aetChanged);
								}
							}
							if (!peideOriginal->m_bDefault && peide->m_bDefault)
							{
								AddStatementToSqlBatch(strBatchSql, "INSERT INTO EMRInfoDefaultsT (EMRInfoID, EMRDataID) VALUES (%li,%li)", m_nID, peide->m_nID);
								bSomethingCriticalChanged = TRUE;

								if(!bIsNew) {
									if(nAuditTransactionID == -1)
										nAuditTransactionID = BeginAuditTransaction();
									CString strNewValue;
									strNewValue.Format("Added Default status to Item: '%s' - Table Column: '%s'", strName, peide->m_strData);
									AuditEvent(-1, "", nAuditTransactionID, aeiEMRItemDetailIsDefault, m_nID, "", strNewValue, aepMedium, aetChanged);
								}
							}

							if ((peideOriginal->m_bIsGrouped && !peide->m_bIsGrouped) || (!peideOriginal->m_bIsGrouped && peide->m_bIsGrouped)) {
								strUpdateString += FormatString("IsGrouped = %li, ", peide->m_bIsGrouped ? 1 : 0);

								if(!bIsNew) {
									if(nAuditTransactionID == -1)
										nAuditTransactionID = BeginAuditTransaction();
									CString strNewValue;
									strNewValue.Format("%s Grouped status on Item: '%s' - Table Column: '%s'", peide->m_bIsGrouped ? "Enabled" : "Disabled", strName, peide->m_strData);
									AuditEvent(-1, "", nAuditTransactionID, aeiEMRItemDetailIsGrouped, m_nID, "", strNewValue, aepMedium, aetChanged);
								}
							}
							if ((peideOriginal->m_bInactive && !peide->m_bInactive) || (!peideOriginal->m_bInactive && peide->m_bInactive)) {
								strUpdateString += FormatString("Inactive = %li, ", peide->m_bInactive ? 1 : 0);

								if(!bIsNew) {
									//audit the change

									CString strOldValue, strNewValue;
									strOldValue.Format("Item: '%s' - Table Column: %s (%s)", strName, peideOriginal->m_strData, peideOriginal->m_bInactive ? "Inactive" : "Active");
									strNewValue.Format("Table Column: %s (%s)", peide->m_strData, peide->m_bInactive ? "Inactive" : "Active");

									if(nAuditTransactionID == -1)
										nAuditTransactionID = BeginAuditTransaction();
									AuditEvent(-1, "", nAuditTransactionID, aeiEMRItemTableItemInactive, m_nID, strOldValue, strNewValue, aepMedium, aetChanged);
								}
							}

							// (j.jones 2007-08-15 14:01) - PLID 27053 - added UseEMCoding
							if((peideOriginal->m_bUseEMCoding && !peide->m_bUseEMCoding) || (!peideOriginal->m_bUseEMCoding && peide->m_bUseEMCoding)) {
								strGroupUpdateString += FormatString("UseEMCoding = %li, ", peide->m_bUseEMCoding ? 1 : 0);

								if(!bIsNew) {
									if(nAuditTransactionID == -1)
										nAuditTransactionID = BeginAuditTransaction();
									CString strNewValue;
									strNewValue.Format("%s E/M status on Item: '%s' - Table Column: '%s'", peide->m_bUseEMCoding ? "Enabled" : "Disabled", strName, peide->m_strData);
									AuditEvent(-1, "", nAuditTransactionID, aeiEMRItemTableItemUseEMCoding, m_nID, "", strNewValue, aepMedium, aetChanged);
								}
							}

							// (j.jones 2011-03-08 12:25) - PLID 42282 - added EMCodeCategoryID
							if(peideOriginal->m_nEMCodeCategoryID != peide->m_nEMCodeCategoryID) {

								strGroupUpdateString += FormatString("EMCodeCategoryID = %s, ", peide->m_nEMCodeCategoryID == -1 ? "NULL" : AsString(peide->m_nEMCodeCategoryID));

								if(!bIsNew) {
									if(nAuditTransactionID == -1) {
										nAuditTransactionID = BeginAuditTransaction();
									}
									
									CString strOldValue, strOldCategory = "<None Selected>", strNewCategory = "<None Selected>";
									_RecordsetPtr rsEMCodeCats = CreateParamRecordset("SELECT Name FROM EMCodeCategoryT WHERE ID = {INT} \r\n"
										"SELECT Name FROM EMCodeCategoryT WHERE ID = {INT} \r\n", peideOriginal->m_nEMCodeCategoryID, peide->m_nEMCodeCategoryID);
									if(!rsEMCodeCats->eof) {
										strOldCategory = VarString(rsEMCodeCats->Fields->Item["Name"]->Value);
									}
									rsEMCodeCats = rsEMCodeCats->NextRecordset(NULL);
									if(!rsEMCodeCats->eof) {
										strNewCategory = VarString(rsEMCodeCats->Fields->Item["Name"]->Value);
									}
									rsEMCodeCats->Close();

									strOldValue.Format("Item: '%s' - Table Column: %s (E/M Category: %s)", strName, peideOriginal->m_strData, strOldCategory);
									AuditEvent(-1, "", nAuditTransactionID, aeiEMRItemTableItemEMCodeCategoryID, m_nID, strOldValue, strNewCategory, aepMedium, aetChanged);
								}
							}

							if (peideOriginal->m_nListType != peide->m_nListType)
							{
								strUpdateString += FormatString("ListType = %li, ", peide->m_nListType);
								ASSERT(peide->m_nListType >= 3);

								// (z.manning 2011-04-28 15:29) - PLID 37604 - We now allow users to change dropdown columns to text
								// columns even if there's data in them so we need to keep track of all such columns.
								if(peideOriginal->m_nListType == LIST_TYPE_DROPDOWN && peide->m_nListType == LIST_TYPE_TEXT) {
									arynDropdownToTextDataIDs.Add(peide->m_nID);
								}

								if(!bIsNew) {
									//audit the change

									CString strOldColumnType, strNewColumnType;
									switch(peideOriginal->m_nListType) {
									case LIST_TYPE_TEXT:
										strOldColumnType = "Text";
										break;
									case LIST_TYPE_DROPDOWN:
										strOldColumnType = "Dropdown";
										break;
									case LIST_TYPE_CHECKBOX:
										strOldColumnType = "Checkbox";
										break;
									case LIST_TYPE_LINKED:
										strOldColumnType = "Linked";
										break;
									}
									switch(peide->m_nListType) {
									case LIST_TYPE_TEXT:
										strNewColumnType = "Text";
										break;
									case LIST_TYPE_DROPDOWN:
										strNewColumnType = "Dropdown";
										break;
									case LIST_TYPE_CHECKBOX:
										strNewColumnType = "Checkbox";
										break;
									case LIST_TYPE_LINKED:
										strNewColumnType = "Linked";
										break;
									}

									CString strOldValue, strNewValue;
									strOldValue.Format("Item: '%s' - Table Column: %s (%s)", strName, peideOriginal->m_strData, strOldColumnType);
									strNewValue.Format("Table Column: %s (%s)", peide->m_strData, strNewColumnType);

									if(nAuditTransactionID == -1)
										nAuditTransactionID = BeginAuditTransaction();
									AuditEvent(-1, "", nAuditTransactionID, aeiEMRItemTableItemColumnType, m_nID, strOldValue, strNewValue, aepHigh, aetChanged);
								}
							}

							// (z.manning 2010-02-11 17:14) - PLID 37324 - ListSubType
							if (peideOriginal->m_nListSubType != peide->m_nListSubType)
							{
								strUpdateString += FormatString("ListSubType = %li, ", peide->m_nListSubType);
								// (z.manning 2010-02-11 17:14) - PLID 37324 - Internal use only so we don't audit
							}

							// (c.haag 2010-02-24 12:51) - PLID 37488 - m_bAutoAlphabetizeDropDown
							if(peideOriginal->m_bAutoAlphabetizeDropDown != peide->m_bAutoAlphabetizeDropDown) {
								strUpdateString += FormatString("AutoAlphabetizeDropDown = %li, ", peide->m_bAutoAlphabetizeDropDown ? 1 : 0);

								if(!bIsNew) {
									if(nAuditTransactionID == -1)
										nAuditTransactionID = BeginAuditTransaction();
									CString strNewValue;
									strNewValue.Format("%s Table DropDown Auto-Alphabetization on Item: '%s' - List Item: '%s'", peide->m_bAutoAlphabetizeDropDown ? "Enabled" : "Disabled", strName, peide->m_strData);
									AuditEvent(-1, "", nAuditTransactionID, aeiEMRItemDetailAutoAlphabetizeDropDown, m_nID, "", strNewValue, aepLow, aetChanged);
								}
							}

							if (peideOriginal->m_strLongForm != peide->m_strLongForm) {
								strUpdateString += FormatString("LongForm = '%s', ", _Q(peide->m_strLongForm));

								if(!bIsNew) {
									if(nAuditTransactionID == -1)
										nAuditTransactionID = BeginAuditTransaction();
									CString strOldValue, strNewValue;
									strOldValue.Format("'%s' for Item: '%s' - Table Column: '%s'", peideOriginal->m_strLongForm, strName, peideOriginal->m_strData);
									strNewValue.Format("'%s' for Item: '%s' - Table Column: '%s'", peide->m_strLongForm, strName, peide->m_strData);
									AuditEvent(-1, "", nAuditTransactionID, aeiEMRItemDetailSentenceFormat, m_nID, strOldValue, strNewValue, aepMedium, aetChanged);
								}
							}
							if ((peideOriginal->m_bIsLabel && !peide->m_bIsLabel) || (!peideOriginal->m_bIsLabel && peide->m_bIsLabel)) {
								strUpdateString += FormatString("IsLabel = %li, ", peide->m_bIsLabel ? 1 : 0);
								// (z.manning 2010-04-20 11:03) - PLID 29301 - Table rows can also be labels
								AddStatementToSqlBatch(strBatchSql, "DELETE FROM EMRTemplateTableDefaultsT WHERE EmrDataID_X = %li OR EmrDataID_Y = %li", peide->m_nID, peide->m_nID);

								if(!bIsNew) {
									if(nAuditTransactionID == -1)
										nAuditTransactionID = BeginAuditTransaction();
									CString strNewValue;
									strNewValue.Format("%s Label status on Item: '%s' - Table Column: '%s'", peide->m_bIsLabel ? "Enabled" : "Disabled", strName, peide->m_strData);
									AuditEvent(-1, "", nAuditTransactionID, aeiEMRItemDetailIsLabel, m_nID, "", strNewValue, aepLow, aetChanged);
								}
							}
							// (z.manning, 06/02/2008) - PLID 16443 - Formula
							if (peideOriginal->m_strFormula != peide->m_strFormula) {
								strUpdateString += FormatString("Formula = '%s', ", _Q(peide->m_strFormula));

								// (z.manning, 05/30/2008) - PLID 16443 - Only text fields should have a formula
								ASSERT(peide->m_strFormula.IsEmpty() || peide->m_nListType == LIST_TYPE_TEXT);

								if(!bIsNew) {
									if(nAuditTransactionID == -1) {
										nAuditTransactionID = BeginAuditTransaction();
									}
									CString strOldValue, strNewValue;
									strOldValue.Format("'%s' for Item: '%s' - Table Column: '%s'", peideOriginal->m_strLongForm, strName, peideOriginal->m_strFormula);
									strNewValue.Format("'%s' for Item: '%s' - Table Column: '%s'", peide->m_strLongForm, strName, peide->m_strFormula);
									AuditEvent(-1, "", nAuditTransactionID, aeiEMRItemDetailFormula, m_nID, strOldValue, strNewValue, aepMedium, aetChanged);
								}
							}
							// (z.manning, 06/02/2008) - PLID 16443 - DecimalPlaces
							if(peideOriginal->m_nDecimalPlaces != peide->m_nDecimalPlaces) {
								strUpdateString += FormatString("DecimalPlaces = %li, ", peide->m_nDecimalPlaces);

								if(!bIsNew) {
									if(nAuditTransactionID == -1) {
										nAuditTransactionID = BeginAuditTransaction();
									}
									CString strOldValue, strNewValue;
									strOldValue.Format("Decimal places for Item: '%s' - List Item: '%s' - %li", strName, peideOriginal->m_strData, peideOriginal->m_nDecimalPlaces);
									strNewValue.Format("Decimal places for Item: '%s' - List Item: '%s' - %li", strName, peide->m_strData, peide->m_nDecimalPlaces);
									AuditEvent(-1, "", nAuditTransactionID, aeiEMRItemDetailDecimalPlaces, m_nID, strOldValue, strNewValue, aepMedium, aetChanged);
								}
							}

							// (z.manning 2011-05-26 15:05) - PLID 43865 - DataFlags
							if(peideOriginal->m_nFlags != peide->m_nFlags)
							{
								strUpdateString += FormatString("DataFlags = %li, ", peide->m_nFlags);

								if(!bIsNew) {
									if(nAuditTransactionID == -1) {
										nAuditTransactionID = BeginAuditTransaction();
									}
									CString strOldValue, strNewValue;
									BOOL bOld = ((peideOriginal->m_nFlags & edfFormulaForTransform) != 0);
									BOOL bNew = ((peide->m_nFlags & edfFormulaForTransform) != 0);
									if(bOld != bNew) {
										strOldValue.Format("Item: '%s' - List Item: '%s' - %s", strName, peideOriginal->m_strData, bOld ? "Yes" : "No");
										strNewValue.Format("Item: '%s' - List Item: '%s' - %s", strName, peide->m_strData, bNew ? "Yes" : "No");
										AuditEvent(-1, "", nAuditTransactionID, aeiEmrDataFormulaForTransform, m_nID, strOldValue, strNewValue, aepMedium, aetChanged);
									}
									bOld = ((peideOriginal->m_nFlags & edfShowPlusSign) != 0);
									bNew = ((peide->m_nFlags & edfShowPlusSign) != 0);
									if(bOld != bNew) {
										strOldValue.Format("Item: '%s' - List Item: '%s' - %s", strName, peideOriginal->m_strData, bOld ? "Yes" : "No");
										strNewValue.Format("Item: '%s' - List Item: '%s' - %s", strName, peide->m_strData, bNew ? "Yes" : "No");
										AuditEvent(-1, "", nAuditTransactionID, aeiEmrDataShowPlusSign, m_nID, strOldValue, strNewValue, aepMedium, aetChanged);
									}
								}
							}

							// (z.manning 2009-01-15 15:00) - PLID 32724 - InputMask
							if(peideOriginal->m_strInputMask != peide->m_strInputMask) {
								strUpdateString += FormatString("InputMask = '%s', ", _Q(peide->m_strInputMask));

								if(!bIsNew) {
									if(nAuditTransactionID == -1) {
										nAuditTransactionID = BeginAuditTransaction();
									}
									CString strOldValue, strNewValue;
									strOldValue.Format("Input mask for Item: '%s' - List Item: '%s' - %s", strName, peideOriginal->m_strData, peideOriginal->m_strInputMask);
									strNewValue.Format("Input mask for Item: '%s' - List Item: '%s' - %s", strName, peide->m_strData, peide->m_strInputMask);
									AuditEvent(-1, "", nAuditTransactionID, aeiEMRItemDetailInputMask, m_nID, strOldValue, strNewValue, aepMedium, aetChanged);
								}
							}

							// (z.manning 2010-08-11 14:22) - PLID 40074 - AutoNumber type
							if(peideOriginal->m_nAutoNumberType != peide->m_nAutoNumberType && peide->m_nListSubType == lstSmartStampAutoNumber)
							{
								CString strAutoNumberType = peide->m_nAutoNumberType == etantInvalid ? "NULL" : AsString(peide->m_nAutoNumberType);
								strUpdateString += FormatString("AutoNumberType = %s, ", strAutoNumberType);

								if(!bIsNew) {
									if(nAuditTransactionID == -1) {
										nAuditTransactionID = BeginAuditTransaction();
									}
									CString strOldValue, strNewValue;
									strOldValue.Format("Auto-number type for Item: '%s' - List Item: '%s' - %s", strName, peideOriginal->m_strData, GetEmrAutoNumberTypeDescription((EEmrTableAutoNumberType)peideOriginal->m_nAutoNumberType));
									strNewValue.Format("Auto-number type for Item: '%s' - List Item: '%s' - %s", strName, peide->m_strData, GetEmrAutoNumberTypeDescription((EEmrTableAutoNumberType)peide->m_nAutoNumberType));
									AuditEvent(-1, "", nAuditTransactionID, aeiEmrItemAutoNumberType, m_nID, strOldValue, strNewValue, aepMedium, aetChanged);
								}
							}

							// (z.manning 2010-08-11 14:22) - PLID 40074 - AutoNumber prefix
							if(peideOriginal->m_strAutoNumberPrefix != peide->m_strAutoNumberPrefix && peide->m_nListSubType == lstSmartStampAutoNumber)
							{
								strUpdateString += FormatString("AutoNumberPrefix = '%s', ", _Q(peide->m_strAutoNumberPrefix));

								if(!bIsNew) {
									if(nAuditTransactionID == -1) {
										nAuditTransactionID = BeginAuditTransaction();
									}
									CString strOldValue, strNewValue;
									strOldValue.Format("Auto-number prefix for Item: '%s' - List Item: '%s' - %s", strName, peideOriginal->m_strData, peideOriginal->m_strAutoNumberPrefix);
									strNewValue.Format("Auto-number prefix for Item: '%s' - List Item: '%s' - %s", strName, peide->m_strData, peide->m_strAutoNumberPrefix);
									AuditEvent(-1, "", nAuditTransactionID, aeiEmrItemAutoNumberPrefix, m_nID, strOldValue, strNewValue, aepMedium, aetChanged);
								}
							}

							//TES 3/11/2011 - PLID 42757 - Added Glasses Order data
							bool bAuditGlassesOrder = false;
							if(peideOriginal->m_GlassesOrderDataType != peide->m_GlassesOrderDataType) {
								strUpdateString += FormatString("GlassesOrderDataType = %s, ", peide->m_GlassesOrderDataType == godtInvalid ? "NULL" : AsString((long)peide->m_GlassesOrderDataType));
								bAuditGlassesOrder = true;
							}
							if(peideOriginal->m_nGlassesOrderDataID != peide->m_nGlassesOrderDataID) {
								strUpdateString += FormatString("GlassesOrderDataID = %s, ", peide->m_nGlassesOrderDataID == -1 ? "NULL" : AsString(peide->m_nGlassesOrderDataID));
								bAuditGlassesOrder = true;
							}
							if(bAuditGlassesOrder && !bIsNew) {
								if(nAuditTransactionID == -1) {
									nAuditTransactionID = BeginAuditTransaction();
								}
								CString strOldValue, strNewValue;
								strOldValue.Format("Item: '%s' - List Item: '%s' - %s", strName, peideOriginal->m_strData, GetGlassesOrderRecordDescription(peideOriginal->m_GlassesOrderDataType, peideOriginal->m_nGlassesOrderDataID, true));
								strNewValue.Format("Item: '%s' - List Item: '%s' - %s", strName, peide->m_strData, GetGlassesOrderRecordDescription(peide->m_GlassesOrderDataType, peide->m_nGlassesOrderDataID, true));
								AuditEvent(-1, "", nAuditTransactionID, aeiEMRItemGlassesOrderRecord, m_nID, strOldValue, strNewValue, aepMedium, aetChanged);
							}

							// (z.manning 2011-03-21 10:01) - PLID 23662 - Autofill type
							if(peideOriginal->m_eAutofillType != peide->m_eAutofillType)
							{
								strUpdateString += FormatString("AutofillType = %li, ", peide->m_eAutofillType);

								if(!bIsNew) {
									if(nAuditTransactionID == -1) {
										nAuditTransactionID = BeginAuditTransaction();
									}
									CString strOldValue, strNewValue;
									strOldValue.Format("Item: '%s' - List Item: '%s' - %s", strName, peideOriginal->m_strData, GetAutofillTypeDescription(peideOriginal->m_eAutofillType));
									strNewValue.Format("Item: '%s' - List Item: '%s' - %s", strName, peide->m_strData, GetAutofillTypeDescription(peide->m_eAutofillType));
									AuditEvent(-1, "", nAuditTransactionID, aeiEmrTableAutofillType, m_nID, strOldValue, strNewValue, aepMedium, aetChanged);
								}
							}

							// (z.manning 2011-09-19 13:27) - PLID 41954 - DropdownSeparator
							if(peideOriginal->m_strDropdownSeparator != peide->m_strDropdownSeparator)
							{
								strUpdateString += FormatString("DropdownSeparator = '%s', ", _Q(peide->m_strDropdownSeparator));

								if(!bIsNew) {
									if(nAuditTransactionID == -1) {
										nAuditTransactionID = BeginAuditTransaction();
									}
									CString strOldValue, strNewValue;
									strOldValue.Format("Item: '%s' - List Item: '%s' - %s", strName, peideOriginal->m_strData, peideOriginal->m_strDropdownSeparator);
									strNewValue.Format("Item: '%s' - List Item: '%s' - %s", strName, peide->m_strData, peide->m_strDropdownSeparator);
									AuditEvent(-1, "", nAuditTransactionID, aeiEmrDropdownSeparator, m_nID, strOldValue, strNewValue, aepMedium, aetChanged);
								}
							}

							// (z.manning 2011-09-19 13:27) - PLID 41954 - DropdownSeparatorFinal
							if(peideOriginal->m_strDropdownSeparatorFinal != peide->m_strDropdownSeparatorFinal)
							{
								strUpdateString += FormatString("DropdownSeparatorFinal = '%s', ", _Q(peide->m_strDropdownSeparatorFinal));

								if(!bIsNew) {
									if(nAuditTransactionID == -1) {
										nAuditTransactionID = BeginAuditTransaction();
									}
									CString strOldValue, strNewValue;
									strOldValue.Format("Item: '%s' - List Item: '%s' - %s", strName, peideOriginal->m_strData, peideOriginal->m_strDropdownSeparatorFinal);
									strNewValue.Format("Item: '%s' - List Item: '%s' - %s", strName, peide->m_strData, peide->m_strDropdownSeparatorFinal);
									AuditEvent(-1, "", nAuditTransactionID, aeiEmrDropdownSeparatorFinal, m_nID, strOldValue, strNewValue, aepMedium, aetChanged);
								}
							}

							// (z.manning 2011-11-07 10:51) - PLID 46309 - SpawnedItemsSeparator
							if(peideOriginal->m_strSpawnedItemsSeparator != peide->m_strSpawnedItemsSeparator)
							{
								strUpdateString += FormatString("SpawnedItemsSeparator = '%s', ", _Q(peide->m_strSpawnedItemsSeparator));

								if(!bIsNew) {
									if(nAuditTransactionID == -1) {
										nAuditTransactionID = BeginAuditTransaction();
									}
									CString strOldValue, strNewValue;
									strOldValue.Format("Item: '%s' - List Item: '%s' - %s", strName, peideOriginal->m_strData, peideOriginal->m_strSpawnedItemsSeparator);
									strNewValue.Format("Item: '%s' - List Item: '%s' - %s", strName, peide->m_strData, peide->m_strSpawnedItemsSeparator);
									AuditEvent(-1, "", nAuditTransactionID, aeiEmrSpawnedItemsSeparator, m_nID, strOldValue, strNewValue, aepMedium, aetChanged);
								}
							}

							// (r.gonet 08/03/2012) - PLID 51735 - Audit the change of the wound care data type assignments.
							if(peideOriginal->m_ewccWoundCareDataType != peide->m_ewccWoundCareDataType)
							{
								strUpdateString += FormatString("WoundCareDataType = %li, ", (long)peide->m_ewccWoundCareDataType);

								if(!bIsNew) {
									if(nAuditTransactionID == -1) {
										nAuditTransactionID = BeginAuditTransaction();
									}
									CString strOldValue, strNewValue;
									strOldValue.Format("Item: '%s' - List Item: '%s' - %s", strName, peideOriginal->m_strData, GetWoundCareDataTypeDescription(peideOriginal->m_ewccWoundCareDataType));
									strNewValue.Format("Item: '%s' - List Item: '%s' - %s", strName, peide->m_strData, GetWoundCareDataTypeDescription(peide->m_ewccWoundCareDataType));
									AuditEvent(-1, "", nAuditTransactionID, aeiEMRItemWoundCareDataType, m_nID, strOldValue, strNewValue, aepMedium, aetChanged);
								}
							}

							// (j.gruber 2013-10-21 09:11) - PLID 59101 - codes on columns							
							if (peide->m_aryCodes.IsDifferent(&peideOriginal->m_aryCodes))
							{
								//we don't want to branch if only the codes changed, since its on the data groupID, so reflect that
								bSomethingMinorChanged = TRUE;

								//something changed in the codes, remove the old ones and add the new ones back in
								AddStatementToSqlBatch(strBatchSql, "DELETE FROM EMRDataGroupCodesT WHERE EMRDataGroupID = %li", peide->m_nDataGroupID);								

								for (int nCodeIndex = 0; nCodeIndex < peide->m_aryCodes.GetSize(); nCodeIndex++) {
									CEMRCode code = peide->m_aryCodes.GetAt(nCodeIndex);
									AddStatementToSqlBatch(strBatchSql, "INSERT INTO EMRDataGroupCodesT (EMRDataGroupID, CodeID) VALUES(%li, %li) ", peide->m_nDataGroupID, code.GetID());
								}

								//now audit
								if(!bIsNew) {
									if(nAuditTransactionID == -1)
										nAuditTransactionID = BeginAuditTransaction();
									CString strNewValue, strOldValue;
									strOldValue.Format("EMR Codes changed on Item: '%s' - List Item: '%s' Codes: %s", strName, peide->m_strData, peideOriginal->m_aryCodes.GetCodeString());
									strNewValue.Format("Codes: %s", peide->m_aryCodes.GetCodeString());
									AuditEvent(-1, "", nAuditTransactionID, aeiEMRTemplateDetailCode, m_nID, strOldValue, strNewValue, aepMedium, aetChanged);
								}
							}

							// (j.gruber 2014-07-18 14:19) - PLID 62624 - Keyword Saving
							if (peideOriginal->m_bUseKeyword != peide->m_bUseKeyword)
							{
								strUpdateString += FormatString("UseKeyword = %li, ", peide->m_bUseKeyword ? 1 : 0);

								if (!bIsNew)
								{
									if (nAuditTransactionID == -1)
									{
										nAuditTransactionID = BeginAuditTransaction();
									}
									CString strOldValue, strNewValue;
									strOldValue.Format("Item: '%s' - List Item: '%s' - %s", strName, peideOriginal->m_strData, peideOriginal->m_bUseKeyword ? "Checked" : "Unchecked");
									strNewValue.Format("Item: '%s' - List Item: '%s' - %s", strName, peide->m_strData, peide->m_bUseKeyword ? "Checked" : "Unchecked");
									AuditEvent(-1, "", nAuditTransactionID, aeiEMRDataUseKeyword, m_nID, strOldValue, strNewValue, aepMedium, aetChanged);
								}
							}

							if (peideOriginal->m_strKeywordOverride != peide->m_strKeywordOverride)
							{
								strUpdateString += FormatString("KeywordOverride = '%s', ", _Q(peide->m_strKeywordOverride));

								if (!bIsNew)
								{
									if (nAuditTransactionID == -1)
									{
										nAuditTransactionID = BeginAuditTransaction();
									}
									CString strOldValue, strNewValue;
									strOldValue.Format("Item: '%s' - List Item: '%s' - %s", strName, peideOriginal->m_strData, peideOriginal->m_strKeywordOverride);
									strNewValue.Format("Item: '%s' - List Item: '%s' - %s", strName, peide->m_strData, peide->m_strKeywordOverride);
									AuditEvent(-1, "", nAuditTransactionID, aeiEMRDataKeywordOverride, m_nID, strOldValue, strNewValue, aepMedium, aetChanged);
								}
							}

							// (j.gruber 2014-12-05 16:08) - PLID 64289 - search queue - Saving
							if (peideOriginal->m_bUseNameForKeyword != peide->m_bUseNameForKeyword)
							{
								strUpdateString += FormatString("UseNameForKeyword = %li, ", peide->m_bUseNameForKeyword ? 1 : 0);

								if (!bIsNew)
								{
									if (nAuditTransactionID == -1)
									{
										nAuditTransactionID = BeginAuditTransaction();
									}
									CString strOldValue, strNewValue;
									strOldValue.Format("Item: '%s' - List Item: '%s' - %s", strName, peideOriginal->m_strData, peideOriginal->m_bUseNameForKeyword ? "Checked" : "Unchecked");
									strNewValue.Format("Item: '%s' - List Item: '%s' - %s", strName, peide->m_strData, peide->m_bUseNameForKeyword ? "Checked" : "Unchecked");
									AuditEvent(-1, "", nAuditTransactionID, aeiEMRDataUseNameForKeyword, m_nID, strOldValue, strNewValue, aepMedium, aetChanged);
								}
							}


							// Ok, now see if we need to write any of the fields to data
							if (!strUpdateString.IsEmpty()) {
								// Drop off the final comma
								strUpdateString.Delete(strUpdateString.GetLength() - 2, 2);
								// And add the update statement
								bSomethingCriticalChanged = TRUE;
								AddStatementToSqlBatch(strBatchSql, "UPDATE EMRDataT SET %s WHERE ID = %li", strUpdateString, peide->m_nID);
							}

							// (j.jones 2007-08-15 14:06) - PLID 27053 - write to EMRDataGroupsT
							if (!strGroupUpdateString.IsEmpty()) {
								// Drop off the final comma
								strGroupUpdateString.Delete(strGroupUpdateString.GetLength() - 2, 2);
								// And add the update statement
								bSomethingMinorChanged = TRUE;
								AddStatementToSqlBatch(strBatchSql, "UPDATE EMRDataGroupsT SET %s WHERE ID IN (SELECT EMRDataGroupID FROM EMRDataT WHERE ID = %li)", strGroupUpdateString, peide->m_nID);
							}

							{
								//update the dropdown list
								if (AddStatementToSqlBatch_EmrTableDropDownChanges(strBatchSql, AsString(peide->m_nID), *peideOriginal, *peide, nAuditTransactionID)) {
									bSomethingCriticalChanged = TRUE;
								}
							}

							// And now see about the data elements' actions
							{
								if (AddStatementToSqlBatch_EmrActionChanges(strBatchSql, eaoEmrDataItem, AsString(peide->m_nID), peideOriginal->m_arActions, peide->m_arActions, nAuditTransactionID)) {
									bSomethingCriticalChanged = TRUE;
								}
							}
						} else {
							// This should be impossible, because if it isn't new, then it has to be in the original list!
							ASSERT(FALSE);
							ThrowNxException("Could not find original data element with ID %li referenced by the current list!", peide->m_nID);
						}
					}
				}
			}

			// Add any that need to be added
			if (!strXmlNewDataElements.IsEmpty()) {
				// Make it into a full xml document
				CString strXml = "<ROOT>\r\n" + strXmlNewDataElements + "</ROOT>";
				// Generate the insert statement
				bSomethingCriticalChanged = TRUE;

				// (c.haag 2007-01-30 09:58) - PLID 24423 - If this is a Current Medications item, we need to add any new medications
				// to the DrugList table as well
				// (c.haag 2007-02-02 16:16) - PLID 24561 - The DrugList table no longer has a Name field
				// (c.haag 2007-02-07 13:59) - PLID 24565 - The DrugList table no longer has an Active field
				CString strDrugListUpdate = "";
				if (IsSystemCurrentMedicationsItem()) {
					// (d.thompson 2008-12-01) - PLID 32174 - DefaultPills is now DefaultQuantity, Description is now PatientInstructions
					strDrugListUpdate =
						"INSERT INTO DrugList (ID, PatientInstructions, DefaultRefills, DefaultQuantity, EmrDataID) "
						"SELECT @nDrugListTableBase + ArbVal, '', '0', '0', @nEMRInfoDataElementBase + ArbVal "
						"FROM OPENXML(@hDoc, '/ROOT/D', 1) WITH (ArbVal INT, ListType INT) XmlQ "
						"WHERE ListType = 2 \r\n";
				}
				// (c.haag 2007-04-03 09:29) - PLID 25468 - Add new allergy table records
				CString strAllergiesUpdate = "";
				if (IsSystemAllergiesItem()) {
					strAllergiesUpdate = 
						"INSERT INTO AllergyT (ID, EmrDataID) "
						"SELECT @nAllergyTableBase + ArbVal, @nEMRInfoDataElementBase + ArbVal "
						"FROM OPENXML(@hDoc, '/ROOT/D', 1) WITH (ArbVal INT, ListType INT) XmlQ "
						"WHERE ListType = 2 \r\n";
				}

				CString strTableUpdate = "";

				//TES 12/7/2006 - PLID 23766 - Initialize new EmrDataT and EmrTableDropdownInfoT records with an arbitrary
				// EmrDataGroupID/DropdownGroupID.  This will tie future copies of these items together.
				//
				// (a.walling 2007-08-29 12:00) - PLID 27223 - The DropdownGroupID is no longer arbirtary;
				// links to EmrTableDropdownGroupsT
				//
				//DRT 1/17/2007 - While implementing PLID 24181, I had to figure out how this works.  It's not very well
				//	documented, so this is my attempt at it.  Keep in mind this is all evidence from modifying how this
				//	works, I hope it's all accurate.
				//
				//First, an XML statement is generated which holds all the data for the emr list items, defaults, table info, 
				//	actions, etc being generated (all the tables in the query below).  This looks something like:
				//<ROOT> <D ID="1" moredatahere...>
				//	<A ID="1" moredatahere ...>
				//		<C ID="1" moredatahere... />
				//	</A>
				//</D></ROOT>
				//
				//The letters are arbitrary and reference what type they are -- D is EMRDataT, A is EMRActionsT, C is 
				//	EMRActionChargeDataT, T is EMRTableDropdownInfoT, Q is for EmrActionsTodoDataT and R is for EmrActionsTodoAssignToT.
				//  ArbVal is another confusing point -- it is an "arbitrary" (but actually sequential starting at 1) value given to each 
				//  record.  This is used to account for identity fields.  So you'll have 1 EMRDataT record and 3 EMRActionT
				//  records.  Each of those EMRActionT records references the same EMRDataT record, but since it was just created,
				//  they don't know what the ID was.  So at the start of the query below, we get the last used value for all 
				//	of our tables (the DECLARE ... statements).  Then in writing, we add the ArbVal on that.  You can 
				//	see the ArbVal's being generated as the parameters to CEmrInfoDataElement::GenerateXml.  Note that 
				//	in the XML structure above there are "levels" of data.  The query below takes advantage of that
				//	hierarchy to get the ArbVal of the parent.  The statement "WITH (ArbVal INT '../@ArbVal'..." in the
				//	EMRActionChargeDataT section tells the query to look to its parent (../) - which is level C, for 
				//	the ArbVal value, and adds it to the base.  If you had 5 actions to save, each would have a 
				//	sequential ArbVal from 1 to 5 that is added to the base value for the table.  Note also that since
				//	these XML is in a hierarchy, the OPENXML statement needs it's full "path" -- for example, 
				//	EMRActionChargeDataT records are at the C level, so you must specify 'ROOT/D/A/C', because they are
				//	at level C, under parent A, which is under parent D, under parent ROOT.
				// (c.haag 2008-07-17 16:43) - P is now reserved for EMR problem actions
				AddStatementToSqlBatch(strBatchSql, 
					"EXEC sp_xml_preparedocument @hDoc OUTPUT, N'%s'; "
					"DECLARE @nEMRInfoDataElementBase INT;\r\n "
					"SET @nEMRInfoDataElementBase = (SELECT COALESCE(MAX(ID), 0) + 1 FROM EMRDataT);\r\n "
					"DECLARE @nEMRTableDropdownInfoBase INT;\r\n "
					// (a.walling 2007-08-29 13:11) - PLID 27231 - Don't add one to the base id; we will already add 'TableArbVal'
					// which starts at 1. C.haag's noticed this as well.
					"SET @nEMRTableDropdownInfoBase = (SELECT COALESCE(MAX(ID), 0) FROM EMRTableDropdownInfoT);\r\n "
					"DECLARE @nEMRDataGroupBase INT;\r\n "
					"SET @nEMRDataGroupBase = (SELECT COALESCE(MAX(ID), 0) + 1 FROM EMRDataGroupsT);\r\n "
					"DECLARE @nEMRTableDropdownGroupBase INT;\r\n "
					// (a.walling 2007-08-29 12:02) - PLID 27223 - use EmrTableDropdownGroupsT
					// (a.walling 2007-08-29 13:11) - PLID 27231 - Don't add one to the base id; we will already add 'TableArbVal'
					// which starts at 1. C.haag's noticed this as well.
					"SET @nEMRTableDropdownGroupBase = (SELECT COALESCE(MAX(ID), 0) FROM EmrTableDropdownGroupsT);\r\n "
					// (c.haag 2007-01-30 10:02) - PLID 24423 - Starting point for Drug List records. Unlike the above queries, I am
					// not adding a "+ 1" because all it does is skip an ID on generation
					"DECLARE @nDrugListTableBase INT;\r\n "
					"SET @nDrugListTableBase = (SELECT COALESCE(MAX(ID), 0) FROM DrugList);\r\n "
					// (c.haag 2007-04-03 09:32) - PLID 25468 - Starting point for Allergy records. Unlike the above queries, I am
					// not adding a "+ 1" because all it does is skip an ID on generation
					"DECLARE @nAllergyTableBase INT;\r\n "
					"SET @nAllergyTableBase = (SELECT COALESCE(MAX(ID), 0) FROM AllergyT);\r\n "
					// (j.dinatale 2010-10-20) - PLID 31160 - now at the top of the entire query since multiple inserts wish to use this variable
					//DRT 1/17/2007 - PLID 24181 - Starting point for EMRAction records
					//"DECLARE @nEMRActionBase INT;\r\n "
					// (c.haag 2008-06-23 10:06) - PLID 30465 - Do not use COALESCE(MAX(ID), 0) because
					// it may not be the same as the current identity value of EmrActionsT.ID. Use IDENT_CURRENT
					// instead
					// "SET @nEMRActionBase = (SELECT COALESCE(MAX(ID), 0) FROM EMRActionsT);\r\n "
					"SET @nEMRActionBase = IDENT_CURRENT('EmrActionsT');\r\n"
					// (j.jones 2007-08-14 16:02) - PLID 27053 - added EMRDataGroupsT
					// (j.jones 2011-03-08 12:25) - PLID 42282 - added EMCodeCategoryID
					"INSERT INTO EMRDataGroupsT (ID, UseEMCoding, EMCodeCategoryID) SELECT @nEMRDataGroupBase + ArbVal, UseEMCoding, "
					" CASE WHEN EMCodeCategoryID = -1 THEN NULL ELSE EMCodeCategoryID END "
					" FROM OPENXML(@hDoc, '/ROOT/D', 1) WITH (ArbVal INT, UseEMCoding BIT, EMCodeCategoryID INT)\r\n "
					// emr data elements
					// (z.manning, 06/02/2008) - PLID 16443 - Added Formula and DecimalPlaces
					// (z.manning 2009-01-15 17:05) - PLID 32724 - Added InputMask
					// (z.manning 2010-02-11 17:15) - PLID 37324 - ListSubType
					// (c.haag 2010-02-24 09:24) - PLID 37488 - AutoAlphabetizeDropDown
					// (j.gruber 2010-04-27 08:56) - PLID 38336 - BOLD Code
					// (z.manning 2010-08-11 15:48) - PLID 40074 - AutoNumber fields
					//TES 3/11/2011 - PLID 42757 - Added Glasses Order data
					// (z.manning 2011-03-21 10:09) - PLID 23662 - Added autofill type
					// (z.manning 2011-05-26 15:10) - PLID 43865 - DataFlags
					// (z.manning 2011-09-19 13:49) - PLID 41954 - Dropdown separators
					// (a.walling 2011-10-17 17:09) - PLID 36090 - REPLACE to use CRLF line breaks instead of normalized LF that XML requires
					// (z.manning 2011-11-07 10:53) - PLID 46309 - SpawnedItemsSeparator
					// (r.gonet 08/03/2012) - PLID 51735 - WoundCareDataType
					// (j.gruber 2014-07-18 14:19) - PLID 62624 - Keyword Saving							
					// (j.gruber 2014-12-05 16:17) - PLID 64289 - search queue - UseNameForKeyword Saving
					"INSERT INTO EMRDataT (ID, EMRInfoID, Data, SortOrder, Inactive, ListType, IsGrouped, LongForm, IsLabel, Formula, DecimalPlaces, InputMask, EmrDataGroupID, ListSubType, AutoAlphabetizeDropDown, BOLDCode, AutoNumberType, AutoNumberPrefix, GlassesOrderDataType, GlassesOrderDataID, AutofillType, DataFlags, DropdownSeparator, DropdownSeparatorFinal, SpawnedItemsSeparator, WoundCareDataType, UseKeyword, KeywordOverride, UseNameForKeyword) "
					" SELECT @nEMRInfoDataElementBase + ArbVal, @nEMRInfoID, Data, SortOrder, Inactive, ListType, IsGrouped, REPLACE(LongForm, CHAR(10), CHAR(13) + CHAR(10)) AS FixedLongForm, IsLabel, Formula, DecimalPlaces, InputMask, @nEMRDataGroupBase +ArbVal, ListSubType, AutoAlphabetizeDropDown, BOLDCode, AutoNumberType, AutoNumberPrefix, GlassesOrderDataType, GlassesOrderDataID, AutofillType, DataFlags, DropdownSeparator, DropdownSeparatorFinal, SpawnedItemsSeparator, WoundCareDataType, UseKeyword, KeywordOverride, UseNameForKeyword "
					// (a.walling 2011-07-01 16:14) - PLID 36090 - LongForm is now CDATA, which must be in an element, not an attribute
					" FROM OPENXML(@hDoc, '/ROOT/D', 1) WITH (ArbVal INT, Data NVARCHAR(2000), SortOrder INT, Inactive BIT, ListType INT, IsGrouped BIT, LongForm NVARCHAR(2000) 'LongForm', IsLabel BIT, Formula NVARCHAR(255), DecimalPlaces TINYINT, InputMask NVARCHAR(100), ListSubType TINYINT, AutoAlphabetizeDropDown BIT, BOLDCode nVarChar(50), AutoNumberType tinyint, AutoNumberPrefix nvarchar(100), GlassesOrderDataType INT, GlassesOrderDataID INT, AutofillType tinyint, DataFlags int, WoundCareDataType int, DropdownSeparator nvarchar(20) 'DropdownSeparator', DropdownSeparatorFinal nvarchar(20) 'DropdownSeparatorFinal', SpawnedItemsSeparator nvarchar(20) 'SpawnedItemsSeparator', UseKeyword bit, KeywordOverride nVarChar(150), UseNameForKeyword bit) XmlQ \r\n"
					// the defaults for those data elements
					"INSERT INTO EMRInfoDefaultsT (EMRInfoID, EMRDataID) SELECT @nEMRInfoID, @nEMRInfoDataElementBase + ArbVal "
					" FROM OPENXML(@hDoc, '/ROOT/D', 1) WITH (ArbVal INT, [Default] BIT) "
					" WHERE [Default] = 1 \r\n"
					// the table dropdown groups for those data elements (a.walling 2007-08-29 12:03) - PLID 27223
					"INSERT INTO EMRTableDropdownGroupsT (ID) "
					" SELECT @nEMRTableDropdownGroupBase + TableArbVal "
					" FROM OPENXML(@hDoc, '/ROOT/D/T', 1) WITH (TableArbVal INT); \r\n"
					// the table dropdown info for those data elements
					//TES 3/15/2011 - PLID 42757 - Added GlassesOrderDataID
					// (j.gruber 2014-07-22 13:11) - PLID 62627 - added keyword columns
					"INSERT INTO EMRTableDropdownInfoT (ID, EMRDataID, Data, Inactive, SortOrder, GlassesOrderDataID, DropdownGroupID, UseKeyword, KeywordOverride) "
					" SELECT @nEMRTableDropdownInfoBase + TableArbVal, @nEMRInfoDataElementBase + ArbVal, Data, Inactive, SortOrder, GlassesOrderDataID, @nEMRTableDropdownGroupBase + TableArbVal, UseKeyword, KeywordOverride "
					" FROM OPENXML(@hDoc, '/ROOT/D/T', 1) WITH (TableArbVal INT, ArbVal INT '../@ArbVal', Data NVARCHAR(2000), Inactive BIT, SortOrder INT, GlassesOrderDataID INT, DropdownGroupID INT, UseKeyword BIT, KeywordOverride nVarChar(150)) \r\n"
					// (z.manning 2011-09-29 11:10) - PLID 45742 - Handle dropdown stamp filter
					"INSERT INTO EmrTableDropdownStampFilterT (EmrTableDropdownInfoID, StampID) \r\n"
					" SELECT @nEMRTableDropdownInfoBase + TableArbVal, StampID \r\n"
					" FROM OPENXML(@hDoc, '/ROOT/D/T/SF', 1) WITH (TableArbVal INT '../@TableArbVal', StampID INT) \r\n"
					// (j.jones 2012-11-26 15:06) - PLID 53144 - added EMRTableDropdownStampDefaultsT
					"INSERT INTO EMRTableDropdownStampDefaultsT (EmrTableDropdownInfoID, StampID) \r\n"
					" SELECT @nEMRTableDropdownInfoBase + TableArbVal, StampID \r\n"
					" FROM OPENXML(@hDoc, '/ROOT/D/T/SD', 1) WITH (TableArbVal INT '../@TableArbVal', StampID INT) \r\n"
					// (c.haag 2010-07-10 11:19) - PLID 39467 - Any time we potentially modify the sort order of EMRTableDropdownInfoT,
					// we have to do validation to ensure we did not create multiple values for a dropdown with the same sort order.
					"IF EXISTS(SELECT EMRDataID, SortOrder FROM EMRTableDropdownInfoT WHERE EMRDataID IN (SELECT @nEMRInfoDataElementBase + ArbVal FROM OPENXML(@hDoc, '/ROOT/D/T', 1) WITH (ArbVal INT) ) GROUP BY EMRDataID, SortOrder HAVING Count(SortOrder) > 1) \r\n"
					"BEGIN RAISERROR('Duplicate SortOrder values detected in EMRTableDropdownInfoT!', 16, 1) ROLLBACK TRAN RETURN END \r\n"
					// the actions for those data elements
					//TES 1/30/2007 - PLID 24474 - Don't forget SpawnAsChild!
					"INSERT INTO EmrActionsT (SourceType, SourceID, DestType, DestID, SortOrder, Popup, SpawnAsChild) "
					" SELECT %li, @nEMRInfoDataElementBase + ArbVal, DestType, DestID, SortOrder, Popup, SpawnAsChild "
					" FROM OPENXML(@hDoc, '/ROOT/D/A', 1) WITH (ArbVal INT '../@ArbVal', DestType INT, DestID INT, SortOrder INT, Popup BIT, SpawnAsChild BIT) \r\n"
					//DRT 1/17/2007 - PLID 24181 - Added insertion for Charge-specific actions.  This may be no records if there are no charge actions
					"INSERT INTO EmrActionChargeDataT (ActionID, Prompt, DefaultQuantity, Modifier1Number, Modifier2Number, Modifier3Number, Modifier4Number) "
					" SELECT @nEMRActionBase + ArbVal, Prompt, Quantity, Mod1, Mod2, Mod3, Mod4 "
					" FROM OPENXML(@hDoc, '/ROOT/D/A/C', 1) WITH (ArbVal INT '../@ArbVal', Prompt INT, Quantity FLOAT, Mod1 NVARCHAR(10), Mod2 NVARCHAR(10), Mod3 NVARCHAR(10), Mod4 NVARCHAR(10)) \r\n"
					// (c.haag 2008-06-20 10:57) - PLID 30221 - Added insertion for todo actions
					"INSERT INTO EmrActionsTodoDataT (ActionID, RemindType, RemindInterval, DeadlineType, DeadlineInterval, Notes, Priority, Task, CategoryID) "
					" SELECT @nEMRActionBase + ArbVal, RemindType, RemindInterval, DeadlineType, DeadlineInterval, Notes, Priority, Task, CategoryID "
					" FROM OPENXML(@hDoc, '/ROOT/D/A/Q', 1) WITH (ArbVal INT '../@ArbVal', RemindType INT, RemindInterval INT, DeadlineType INT, DeadlineInterval INT, Notes NVARCHAR(2000), Priority INT, Task NVARCHAR(50), CategoryID INT) \r\n"
					// Todo assignments
					"INSERT INTO EmrActionsTodoAssignToT (ActionID, AssignTo) "
					" SELECT @nEMRActionBase + ArbVal, AssignTo "
					" FROM OPENXML(@hDoc, '/ROOT/D/A/R', 1) WITH (ArbVal INT '../@ArbVal', AssignTo INT) \r\n"
					// (c.haag 2008-07-17 16:44) - PLID 30724 - Emr problem actions
					// (c.haag 2014-07-22) - PLID 62789 - Added SNOMEDCodeID
					// (s.tullis 2015-02-23 17:47) - PLID 64749 
					// (r.gonet 2015-03-10 14:48) - PLID 65013 - Added DoNotShowOnProblemPrompt.
					"INSERT INTO EmrProblemActionsT (EmrActionID, DefaultDescription, DefaultStatus, SpawnToSourceItem, SNOMEDCodeID, DoNotShowOnCCDA, DoNotShowOnProblemPrompt) "
					" SELECT @nEMRActionBase + ArbVal, DefaultDescription, DefaultStatus, SpawnToSourceItem, SNOMEDCodeID, DoNotShowOnCCDA, DoNotShowOnProblemPrompt "
					" FROM OPENXML(@hDoc, '/ROOT/D/A/P', 1) WITH (ArbVal INT '../@ArbVal', DefaultDescription nvarchar(2000), DefaultStatus INT, SpawnToSourceItem BIT, SNOMEDCodeID INT, DoNotShowOnCCDA BIT, DoNotShowOnProblemPrompt BIT) "
					"\r\n"
					// (b.savon 2014-07-21 16:45) - PLID 62707 - Handle saving the new Diagnosis DestType action to EmrActionsT and EmrActionsDiagnosisDataT
					"INSERT INTO EMRActionDiagnosisDataT (EmrActionID, DiagCodeID_ICD9, DiagCodeID_ICD10) "
					"	SELECT @nEMRActionBase + ArbVal, CASE WHEN DiagCodeID_ICD9 = -1 THEN NULL ELSE DiagCodeID_ICD9 END AS DiagCodeID_ICD9, CASE WHEN DiagCodeID_ICD10 = -1 THEN NULL ELSE DiagCodeID_ICD10 END AS DiagCodeID_ICD10 \r\n"
					"	FROM OPENXML(@hDoc, 'ROOT/D/A/DI', 1) WITH (ArbVal INT '../@ArbVal', DiagCodeID_ICD9 INT, DiagCodeID_ICD10 INT) "
					// (z.manning 2009-02-11 16:12) - PLID 33029 - Table dropdown item actions
					"INSERT INTO EmrActionsT (SourceType, SourceID, DestType, DestID, SortOrder, Popup, SpawnAsChild) "
					" SELECT %li, @nEMRTableDropdownInfoBase + TableArbVal, DestType, DestID, SortOrder, Popup, SpawnAsChild "
					" FROM OPENXML(@hDoc, '/ROOT/D/T/A', 1) WITH (TableArbVal INT '../@TableArbVal', DestType INT, DestID INT, SortOrder INT, Popup BIT, SpawnAsChild BIT) \r\n"
					//DRT 1/17/2007 - PLID 24181 - Added insertion for Charge-specific actions.  This may be no records if there are no charge actions
					"INSERT INTO EmrActionChargeDataT (ActionID, Prompt, DefaultQuantity, Modifier1Number, Modifier2Number, Modifier3Number, Modifier4Number) "
					" SELECT @nEMRActionBase + ArbVal, Prompt, Quantity, Mod1, Mod2, Mod3, Mod4 "
					" FROM OPENXML(@hDoc, '/ROOT/D/T/A/C', 1) WITH (ArbVal INT '../@ArbVal', Prompt INT, Quantity FLOAT, Mod1 NVARCHAR(10), Mod2 NVARCHAR(10), Mod3 NVARCHAR(10), Mod4 NVARCHAR(10)) \r\n"
					// (c.haag 2008-06-20 10:57) - PLID 30221 - Added insertion for todo actions
					"INSERT INTO EmrActionsTodoDataT (ActionID, RemindType, RemindInterval, DeadlineType, DeadlineInterval, Notes, Priority, Task, CategoryID) "
					" SELECT @nEMRActionBase + ArbVal, RemindType, RemindInterval, DeadlineType, DeadlineInterval, Notes, Priority, Task, CategoryID "
					" FROM OPENXML(@hDoc, '/ROOT/D/T/A/Q', 1) WITH (ArbVal INT '../@ArbVal', RemindType INT, RemindInterval INT, DeadlineType INT, DeadlineInterval INT, Notes NVARCHAR(2000), Priority INT, Task NVARCHAR(50), CategoryID INT) \r\n"
					// Todo assignments
					"INSERT INTO EmrActionsTodoAssignToT (ActionID, AssignTo) "
					" SELECT @nEMRActionBase + ArbVal, AssignTo "
					" FROM OPENXML(@hDoc, '/ROOT/D/T/A/R', 1) WITH (ArbVal INT '../@ArbVal', AssignTo INT) \r\n"
					// (c.haag 2008-07-17 16:44) - PLID 30724 - Emr problem actions
					// (c.haag 2014-07-22) - PLID 62789 - Added SNOMEDCodeID
					// (r.gonet 2015-03-10 14:48) - PLID 65013 - Added DoNotShowOnProblemPrompt.
					"INSERT INTO EmrProblemActionsT (EmrActionID, DefaultDescription, DefaultStatus, SpawnToSourceItem, SNOMEDCodeID, DoNotShowOnCCDA, DoNotShowOnProblemPrompt) "
					" SELECT @nEMRActionBase + ArbVal, DefaultDescription, DefaultStatus, SpawnToSourceItem, SNOMEDCodeID, DoNotShowOnCCDA, DoNotShowOnProblemPrompt "
					" FROM OPENXML(@hDoc, '/ROOT/D/T/A/P', 1) WITH (ArbVal INT '../@ArbVal', DefaultDescription nvarchar(2000), DefaultStatus INT, SpawnToSourceItem BIT, SNOMEDCodeID INT, DoNotShowOnCCDA BIT, DoNotShowOnProblemPrompt BIT) "
					"\r\n"
					// (b.savon 2014-07-21 16:45) - PLID 62707 - Handle saving the new Diagnosis DestType action to EmrActionsT and EmrActionsDiagnosisDataT
					"INSERT INTO EMRActionDiagnosisDataT (EmrActionID, DiagCodeID_ICD9, DiagCodeID_ICD10) "
					"	SELECT @nEMRActionBase + ArbVal, CASE WHEN DiagCodeID_ICD9 = -1 THEN NULL ELSE DiagCodeID_ICD9 END AS DiagCodeID_ICD9, CASE WHEN DiagCodeID_ICD10 = -1 THEN NULL ELSE DiagCodeID_ICD10 END AS DiagCodeID_ICD10 \r\n"
					"	FROM OPENXML(@hDoc, 'ROOT/D/T/A/DI', 1) WITH (ArbVal INT '../@ArbVal', DiagCodeID_ICD9 INT, DiagCodeID_ICD10 INT) "
					// (j.gruber 2013-10-01 14:50) - PLID 58674 - EMR Data Codes
					" INSERT INTO EMRDataGroupCodesT (EMRDataGroupID, CodeID) \r\n"
					" SELECT @nEMRDataGroupBase + ArbVal, CodeID \r\n"
					" FROM OPENXML(@hDoc, '/ROOT/D/DCD', 1) WITH (ArbVal INT '../@ArbVal', CodeID INT) \r\n"
					//any updates to tables on existing templates
					"%s "
					"%s "
					"%s "
					"EXEC sp_xml_removedocument @hDoc;"
					, strXml, eaoEmrDataItem, eaoEmrTableDropDownItem
					, strDrugListUpdate, strAllergiesUpdate, strTableUpdate);

				// (c.haag 2007-04-19 09:27) - PLID 24695 - It's possible with OPENXML to create empty list names because it trims whitespaces.
				// Make sure that it's impossible to write empty list names to data by running this additional update query.
				// (c.haag 2007-09-26 15:42) - The decision to do this has been reversed now that the importer supports it and
				// by request from the EMR group
				// (c.haag 2007-09-26 15:56) - I infer from an e-mail today by a.walling that this query wouldn't work anyway.
				//AddStatementToSqlBatch(strBatchSql, "UPDATE EmrDataT SET Data = ' ' WHERE DATALENGTH(Data) = 0 AND EMRInfoID = @nEMRInfoID");
			}

			if (-1 != m_nID) {
				for (int i=0; i < m_aryChangedCols.GetSize(); i++) {
					long nDataID = m_aryChangedCols[i]->m_nID;
					// (a.walling 2009-03-12 14:47) - PLID 33486 - Since we don't store empty values anymore, and we used to simply
					// update them with the 'empty' sentinel value based on the type, we now can simply remove them.
					
					// Clear our template data
					AddStatementToSqlBatch(strBatchSql, "DELETE FROM EMRTemplateTableDefaultsT "
						"WHERE (EMRDataID_X = %d OR EMRDataID_Y = %d) "
						"AND EMRTemplateDetailID IN (SELECT ID FROM EMRTemplateDetailsT WHERE EmrInfoMasterID = %d)",
						nDataID, nDataID, m_nEmrInfoMasterID);
				}

				// (a.walling 2009-03-12 14:47) - PLID 33486 - We no longer store empty values in the database
			}
		}
	}

	// (c.haag 2011-03-16) - PLID 42813 - Save common lists. This can get sticky because lists may have been added, changed, deleted;
	// and the contents of the lists themselves added or deleted. So lets test for the following:
	//
	//	A. List created: Just audit the creation of the list; no need to audit the individual selections
	//	B. List deleted: Audit the deletion of the list
	//	C. List property (name/color) modified: Audit the property and value
	//	D. List item added: Audit the list item if the list itself was not created in this session (or if the list was deleted in this session)
	//	E. List item removed: Audit the list item if the list itself was not created in this session (or if the list was deleted in this session)
	//
	// We'll just build our data changes in strBatchSql.
	//
	// Note: We're intentionally called after the part of the batch that adds EmrDataT records.
	//
	{
		// A) New lists
		int i = 0;
		int nLists = m_CommonListCollection.GetListCount();
		BOOL bHasVariable_NewCmnListID = FALSE;
		for (i=0; i < nLists; i++)
		{
			const CEmrInfoCommonList list = m_CommonListCollection.GetListByIndex(i);
			if (list.IsNew())
			{
				// Declare any variables once and only once
				if (!bHasVariable_NewCmnListID) {
					AddStatementToSqlBatch(strBatchSql, "DECLARE @NewCmnListID INT");
					bHasVariable_NewCmnListID = TRUE;
				}

				// Save the new list
				// (c.haag 2011-04-11) - PLID 43234 - Also include GroupOnPreviewPane
				AddStatementToSqlBatch(strBatchSql,
					"INSERT INTO EmrInfoCommonListT (EmrInfoID, Name, Color, OrderID, Inactive, GroupOnPreviewPane) "
					"VALUES (@nEMRInfoID, '%s', %d, %d, %d, %d) "
					"\r\nSET @NewCmnListID = SCOPE_IDENTITY();"
					,_Q(list.GetName()), list.GetColor(), list.GetOrderID(), list.IsInactive() ? 1 : 0, list.GetGroupOnPreviewPane() ? 1 : 0);

				// (c.haag 2011-03-25) - PLID 42999 - Auditing
				if(nAuditTransactionID == -1) { nAuditTransactionID = BeginAuditTransaction(); }
				AuditEvent(-1, "", nAuditTransactionID, aeiEmrInfoCommonList, m_nID, "", strName + " - " + list.GetName(), aepMedium, aetCreated);

				// Save the items in the list. Because this is a completely new list, every single item
				// must have a CEmrInfoDataElement object assigned to it.
				const int nItems = list.GetItemCount();
				CString strEmrDataID;
				for (int j=0; j < nItems; j++)
				{
					const CEmrInfoCommonListItem item = list.GetItemByIndex(j);
					CEmrInfoDataElement* pItemElement = item.GetEmrInfoDataElement();
					if (-1 == pItemElement->m_nID) {
						// If we get here, it means the user added this row while editing this EMR info item's list.
						// It also means we have to get the new Emr Data ID from the query; and to do that
						// we must utilize variables that already exist in the query.
						//
						// The variable @nEMRInfoDataElementBase is the max ID in EmrDataT. Whenever a new
						// element is saved, it is assigned an "arbitrary" value when the XML save string is generated.
						// We used to not track this value in memory, but now we do.
						//
						// There could be a better way to do this; but I'm not aware of any other place where we
						// have an object dependent on EmrDataT that was not a "child object" of it.
						strEmrDataID.Format("@nEMRInfoDataElementBase + %s", pItemElement->m_strArbitraryGeneratedXmlValue);
					}
					else {
						// Existing EmrDataID record
						strEmrDataID.Format("%d", pItemElement->m_nID);
					}
					AddStatementToSqlBatch(strBatchSql,
						"INSERT INTO EmrInfoCommonListItemsT (ListID, EmrDataID) "
						"VALUES (@NewCmnListID, %s)"
						,strEmrDataID);

					// (c.haag 2011-03-25) - PLID 42999 - Do not audit the addition of new rows for a brand new list just added to data

				} // for (int j=0; j < nItems; j++)

				bSomethingCriticalChanged = TRUE; // Ensure the query is committed

			} // if (list.IsNew())
		} // for (i=0; i < nLists; i++)
		
		// B) Deleting lists were handled earlier on

		// C) Modified lists
		nLists = m_CommonListCollection.GetListCount();
		for (i=0; i < nLists; i++)
		{
			const CEmrInfoCommonList list = m_CommonListCollection.GetListByIndex(i);
			if (list.IsNew()) { continue; } // Skip new lists; we already took care of those

			// Now get the saved equivalent
			const CEmrInfoCommonList savedList = m_SavedCommonListCollection.GetListByID(list.GetID());
			
			// Now go through the list-level fields for comparison
			if (list.GetName() != savedList.GetName())
			{
				AddStatementToSqlBatch(strBatchSql, "UPDATE EmrInfoCommonListT SET Name = '%s' WHERE ID = %d", _Q(list.GetName()), list.GetID());
				bSomethingCriticalChanged = TRUE; // Ensure the query is committed
				// (c.haag 2011-03-25) - PLID 42999 - Auditing
				if(nAuditTransactionID == -1) { nAuditTransactionID = BeginAuditTransaction(); }
				AuditEvent(-1, "", nAuditTransactionID, aeiEmrInfoCommonList, m_nID, strName + " Common List Name - " + savedList.GetName(), list.GetName(), aepMedium, aetChanged);
			}
			if (list.GetColor() != savedList.GetColor())
			{
				AddStatementToSqlBatch(strBatchSql, "UPDATE EmrInfoCommonListT SET Color = %d WHERE ID = %d", list.GetColor(), list.GetID());
				bSomethingCriticalChanged = TRUE; // Ensure the query is committed
				// (c.haag 2011-03-25) - PLID 42999 - Auditing
				if(nAuditTransactionID == -1) { nAuditTransactionID = BeginAuditTransaction(); }
				AuditEvent(-1, "", nAuditTransactionID, aeiEmrInfoCommonList, m_nID, strName + " Common List Color - " + savedList.GetName(), AsString(list.GetColor()), aepMedium, aetChanged);
			}
			if (list.GetOrderID() != savedList.GetOrderID())
			{
				AddStatementToSqlBatch(strBatchSql, "UPDATE EmrInfoCommonListT SET OrderID = %d WHERE ID = %d", list.GetOrderID(), list.GetID());
				bSomethingCriticalChanged = TRUE; // Ensure the query is committed
				// (c.haag 2011-03-25) - PLID 42999 - Auditing
				if(nAuditTransactionID == -1) { nAuditTransactionID = BeginAuditTransaction(); }
				AuditEvent(-1, "", nAuditTransactionID, aeiEmrInfoCommonList, m_nID, strName + " Common List Order - " + savedList.GetName(), AsString(list.GetOrderID()), aepMedium, aetChanged);
			}
			if (list.IsInactive() != savedList.IsInactive())
			{
				AddStatementToSqlBatch(strBatchSql, "UPDATE EmrInfoCommonListT SET Inactive = %d WHERE ID = %d", list.IsInactive() ? 1 : 0, list.GetID());
				bSomethingCriticalChanged = TRUE; // Ensure the query is committed
				// (c.haag 2011-03-25) - PLID 42999 - Auditing
				if(nAuditTransactionID == -1) { nAuditTransactionID = BeginAuditTransaction(); }
				AuditEvent(-1, "", nAuditTransactionID, aeiEmrInfoCommonList, m_nID, strName + " Common List Inactive - " + savedList.GetName(), list.IsInactive() ? "Yes" : "No", aepMedium, aetChanged);
			}
			// (c.haag 2011-04-11) - PLID 43234 - GroupOnPreviewPane
			if (list.GetGroupOnPreviewPane() != savedList.GetGroupOnPreviewPane())
			{
				AddStatementToSqlBatch(strBatchSql, "UPDATE EmrInfoCommonListT SET GroupOnPreviewPane = %d WHERE ID = %d", list.GetGroupOnPreviewPane() ? 1 : 0, list.GetID());
				bSomethingCriticalChanged = TRUE; // Ensure the query is committed
				if(nAuditTransactionID == -1) { nAuditTransactionID = BeginAuditTransaction(); }
				AuditEvent(-1, "", nAuditTransactionID, aeiEmrInfoCommonList, m_nID, strName + " Common List Group On Preview Pane - " + savedList.GetName(), list.GetGroupOnPreviewPane() ? "Yes" : "No", aepMedium, aetChanged);
			}

			// D) Added list items
			int j;
			int nItems = list.GetItemCount();
			for (j=0; j < nItems; j++)
			{
				const CEmrInfoCommonListItem item = list.GetItemByIndex(j);
				// Every item added to a list must have a CEmrInfoDataElement object assigned to it; but items
				// not added to a list may not have that object. So, we need to test pItemElement for NULL.
				CEmrInfoDataElement* pItemElement = item.GetEmrInfoDataElement();
				// If the EMR data item doesn't exist in the saved list, then add it to data
				if (NULL != pItemElement && !savedList.DoesExist(pItemElement))	
				{
					CString strEmrDataID;
					if (-1 == pItemElement->m_nID) {
						// If we get here, it means the user added this row while editing this EMR info item's list.
						// It also means we have to get the new Emr Data ID from the query; and to do that
						// we must utilize variables that already exist in the query.
						//
						// The variable @nEMRInfoDataElementBase is the max ID in EmrDataT. Whenever a new
						// element is saved, it is assigned an "arbitrary" value when the XML save string is generated.
						// We used to not track this value in memory, but now we do.
						//
						// There could be a better way to do this; but I'm not aware of any other place where we
						// have an object dependent on EmrDataT that was not a "child object" of it.
						strEmrDataID.Format("@nEMRInfoDataElementBase + %s", pItemElement->m_strArbitraryGeneratedXmlValue);
					}
					else {
						// Existing EmrDataID record
						strEmrDataID.Format("%d", pItemElement->m_nID);
					}
					AddStatementToSqlBatch(strBatchSql, "INSERT INTO EmrInfoCommonListItemsT (ListID, EmrDataID) VALUES (%d, %s)",
						list.GetID(), strEmrDataID);

					// (c.haag 2011-04-07) - PLID 42999 - Auditing
					if(nAuditTransactionID == -1) { nAuditTransactionID = BeginAuditTransaction(); }
					AuditEvent(-1, "", nAuditTransactionID, aeiEmrInfoCommonListItem, m_nID, "", strName + " - " + list.GetName() + " - " + pItemElement->m_strData, aepMedium, aetCreated);

					bSomethingCriticalChanged = TRUE; // Ensure the query is committed
				}
			}

			// E) Deleted list items were handled earlier on

		} // for (i=0; i < nLists; i++)

	} // End Common List saving code

	// (j.gruber 2013-09-23 11:37) - PLID 58676 - Table Cell Codes
	{
		CEMRTableCellCodes mapAdded, mapChanged, mapDeleted;
		if (m_TableCellCodes.SplitIntoChangedLists(&m_SavedCellCodes, &mapAdded, &mapChanged, &mapDeleted)) {
			//we know something changed
			bSomethingMinorChanged = TRUE;

			//loop through the deleted 
			CEMRTableCellCodeIterator itDeleted;
			for (itDeleted = mapDeleted.begin(); itDeleted != mapDeleted.end(); itDeleted++)
			{
				CEMRCellPair pDeleted = itDeleted->first;
				//make a cell from the pair
				CEMRTableCell cell(pDeleted.first, pDeleted.second);
				CString strRowID = cell.GetRowDataID(&m_aryCurDataElements);
				CString strColID = cell.GetColDataID(&m_aryCurColumnDataElements);
				// (j.gruber 2014-01-20 10:32) - PLID 60395 - reverse the X and Y
				AddStatementToSqlBatch(strBatchSql, "DELETE FROM EmrTableDataGroupCodesT WHERE EMRDataGroupID_Y = %s AND EMRDataGroupID_X = %s ", strColID, strRowID);

				//audit
				if(!bIsNew) {
					if(nAuditTransactionID == -1) { nAuditTransactionID = BeginAuditTransaction(); }
					CString strOldValue = "Item: " + strName + " - " + cell.GetText();
					CString strNewValue = "Deleted";
					AuditEvent(-1, "", nAuditTransactionID, aeiEMRTemplateTableCellCode, m_nID, strOldValue, strNewValue, aepMedium, aetChanged);
				}
			}
			
			//now the added 
			CEMRTableCellCodeIterator itAdded;
			for (itAdded = mapAdded.begin(); itAdded != mapAdded.end(); itAdded++)
			{
				CEMRCellPair pAdded = itAdded->first;
				CEMRTableCell cell(pAdded.first, pAdded.second);
				CString strRowID = cell.GetRowDataID(&m_aryCurDataElements);
				CString strColID = cell.GetColDataID(&m_aryCurColumnDataElements);
				CEMRCodeArray *pAry = itAdded->second;

				//now we have to loop through the array
				for(int i=0; i < pAry->GetCount(); i++) 
				{
					CEMRCode code = pAry->GetAt(i);
					// (j.gruber 2014-01-20 10:33) - PLID 60395 - reverse the X and Y
					AddStatementToSqlBatch(strBatchSql, "INSERT INTO EmrTableDataGroupCodesT (EMRDataGroupID_Y, EMRDataGroupID_X, CodeID) VALUES (%s, %s, %li)" , strColID, strRowID, code.GetID());
				}
				//audit
				if(!bIsNew) {
					if(nAuditTransactionID == -1) { nAuditTransactionID = BeginAuditTransaction(); }
					CString strOldValue = "Item: " + strName + " - " + cell.GetText();
					CString strNewValue = "Codes Added: "  + m_TableCellCodes.GetCodeString(cell);
					AuditEvent(-1, "", nAuditTransactionID, aeiEMRTemplateTableCellCode, m_nID, strOldValue, strNewValue, aepMedium, aetChanged);
				}
			}

			//now the changed
			CEMRTableCellCodeIterator itChanged;
			for (itChanged = mapChanged.begin(); itChanged != mapChanged.end(); itChanged++)
			{
				//first, get rid of all the entries for this cell
				CEMRCellPair pChanged = itChanged->first;
				CEMRTableCell cell(pChanged.first, pChanged.second);
				CString strRowID = cell.GetRowDataID(&m_aryCurDataElements);
				CString strColID = cell.GetColDataID(&m_aryCurColumnDataElements);				
				// (j.gruber 2014-01-20 10:33) - PLID 60395 - reverse the X and Y
				AddStatementToSqlBatch(strBatchSql, "DELETE FROM EmrTableDataGroupCodesT WHERE EMRDataGroupID_Y = %s AND EMRDataGroupID_X = %s", strColID, strRowID);

				//now loop through the array and add in the changed ones
				CEMRCodeArray *pAry = itChanged->second;

				//now we have to loop through the array
				for(int i=0; i < pAry->GetCount(); i++) 
				{
					CEMRCode code = pAry->GetAt(i);
					// (j.gruber 2014-01-20 10:34) - PLID 60395 - reverse the X and Y
					AddStatementToSqlBatch(strBatchSql, "INSERT INTO EmrTableDataGroupCodesT (EMRDataGroupID_Y, EMRDataGroupID_X, CodeID) VALUES (%s, %s, %li)" , strColID, strRowID, code.GetID());
				}

				//audit
				if(!bIsNew) {
					if(nAuditTransactionID == -1) { nAuditTransactionID = BeginAuditTransaction(); }
					CString strOldValue = "Item: " + strName + " - " + cell.GetText() + "Codes: " + m_SavedCellCodes.GetCodeString(cell);
					CString strNewValue = "Codes: " + m_TableCellCodes.GetCodeString(cell);
					AuditEvent(-1, "", nAuditTransactionID, aeiEMRTemplateTableCellCode, m_nID, strOldValue, strNewValue, aepMedium, aetChanged);
				}

			}
		}

		//since we are done with our split out arrays, let's get rid of them
		mapAdded.Clear();
		mapDeleted.Clear();
		mapChanged.Clear();
		
	}

	// (j.jones 2012-09-20 10:24) - PLID 52316 - Added support for ParentLabelID,
	// which links EMRDataT records to others in the same list. This has to be done
	// after the initial save so we can update ParentLabelID to real values, in the
	// event that a row's parent label hadn't been saved yet.
	if(IsDlgButtonChecked(IDC_RADIO_LIST_SELECT) || IsDlgButtonChecked(IDC_RADIO_LIST_MULTISELECT)) {
		for(int i = 0; i < m_aryCurDataElements.GetSize(); i++) {
			CEmrInfoDataElement *peide = m_aryCurDataElements.GetAt(i);

			//get the ID
			CString strEMRDataID;
			if (peide->m_nID == -1) {
				//this is a new row, use the arbitrary value
				strEMRDataID.Format("@nEMRInfoDataElementBase + %s", peide->m_strArbitraryGeneratedXmlValue);
			}
			else {
				//this is an existing row, just use its ID
				strEMRDataID.Format("%li", peide->m_nID);
			}
			
			//get the ParentLabelID
			CString strParentLabelID = "NULL";
			if(peide->m_peideParentLabelPtr != NULL) {
				//this may have a real ID, or it may be new
				if(peide->m_peideParentLabelPtr->m_nID != -1) {
					//we have a real ID, just save it
					strParentLabelID.Format("%li", peide->m_peideParentLabelPtr->m_nID);
				}
				else {
					//the parent label is a new row, use the arbitrary value
					strParentLabelID.Format("@nEMRInfoDataElementBase + %s", peide->m_peideParentLabelPtr->m_strArbitraryGeneratedXmlValue);
				}
			}

			long nOrig = -1; //m_aryDataElements.FindDataElement(peide->m_nID, 0);
			mapDataElements.Lookup(peide->m_nID, nOrig);
			CEmrInfoDataElement *peideOriginal = NULL;
			if(nOrig != -1) {
				peideOriginal = m_aryDataElements.GetAt(nOrig);
			}

			//We can't compare original pointers and current pointers, because the original
			//in m_aryDataElements has no m_peideParentLabelPtr. We know we have to save
			//something if:
			//- there is a parent selected, and either this info item is new or just the row is new
			//- the old row didn't have a parent label ID, and the row now has a parent pointer
			//- the old row's parent label ID doesn't match the new row's parent label ID (at that point, -1 was already handled)
			BOOL bSomethingChanged = FALSE;
			if((bIsNew || peideOriginal == NULL) && peide->m_peideParentLabelPtr != NULL) {
				//the row is new, and has a parent label chosen
				bSomethingChanged = TRUE;
			}
			else if(peideOriginal != NULL) {
				//if we have an old row, compare the contents
				if(peideOriginal->m_nParentLabelID == -1 && peide->m_peideParentLabelPtr != NULL) {
					//the old row had no label, the new one does
					bSomethingChanged = TRUE;
				}
				else if(peideOriginal->m_nParentLabelID != -1 && peide->m_peideParentLabelPtr == NULL) {
					//the old row had a label, the new one does not
					bSomethingChanged = TRUE;
				}
				else if(peideOriginal->m_nParentLabelID != peide->m_nParentLabelID) {
					//The old row had a label, but the new one changed to a different one.
					//It's ok if the new row's label ID is -1 but pointing to a (new) label,
					//because the old row's label ID would never be -1 if a label was in use before,
					//so just comparing IDs is fine.
					bSomethingChanged = TRUE;
				}
			}

			if(bSomethingChanged) {
				//only save if something changed
				AddStatementToSqlBatch(strBatchSql, "UPDATE EMRDataT SET ParentLabelID = %s WHERE ID = %s", strParentLabelID, strEMRDataID);

				bSomethingCriticalChanged = TRUE; // Ensure the query is committed

				//only audit if this isn't a new item (like all the rest of our auditing)
				if(!bIsNew) {					
					CString strOldValue, strNewValue;
					if(peideOriginal) {
						if(peideOriginal->m_nParentLabelID != -1) {
							strOldValue.Format("Item: '%s' - List Item: '%s' - Parent: '%s'", strName, peideOriginal->m_strData, peideOriginal->m_strOldParentLabelName);
						}
						else {
							strOldValue.Format("Item: '%s' - List Item: '%s' - Parent: <No Parent>", strName, peideOriginal->m_strData);
						}
					}
					if(peide->m_peideParentLabelPtr) {
						strNewValue.Format("Item: '%s' - List Item: '%s' - Parent: '%s'", strName, peide->m_strData, peide->m_peideParentLabelPtr->m_strData);
					}
					else {
						strNewValue.Format("Item: '%s' - List Item: '%s' - Parent: <No Parent>", strName, peide->m_strData);
					}

					//If this assert fires, then it would suggest that the logic
					//for bSomethingChanged is causing saves to occur unnecessarily.
					//(A valid reason would be if we renamed items in such a way that
					//we really did change a parent, but the names happened to be identical.)
					ASSERT(strOldValue != strNewValue);

					if(nAuditTransactionID == -1) {
						nAuditTransactionID = BeginAuditTransaction();
					}
					AuditEvent(-1, "", nAuditTransactionID, aeiEMRItemDetailParentLabel, m_nID, strOldValue, strNewValue, aepLow, aetChanged);
				}
			}
		}
	}

	if (bSomethingCriticalChanged || bSomethingMinorChanged) {

		//
		// (c.haag 2007-03-19 15:02) - PLID 24695 - All list items must have non-blank names
		// (c.haag 2007-09-26 15:42) - The decision to do this has been reversed now that the importer supports it and
		// by request from the EMR group
		//
		/*if (IsDlgButtonChecked(IDC_RADIO_LIST_SELECT) || IsDlgButtonChecked(IDC_RADIO_LIST_MULTISELECT)) {
			const int nDataElements = m_aryCurDataElements.GetSize();
			int i;
			for (i=0; i < nDataElements; i++) {
				CEmrInfoDataElement *peide = m_aryCurDataElements.GetAt(i);
				if (peide && peide->m_strData.IsEmpty()) {
					AfxMessageBox("You cannot have a list item with no name. Please ensure that all list items have names before saving.", MB_OK | MB_ICONHAND);
					return FALSE;
				}
			}
		}*/

		//
		// (c.haag 2007-03-19 15:02) - PLID 24695 - All table items must have non-blank names
		// (c.haag 2007-09-26 15:42) - The decision to do this has been reversed now that the importer supports it and
		// by request from the EMR group
		//
		/*if (IsDlgButtonChecked(IDC_RADIO_TABLE)) {
			const int nDataElements = m_aryCurDataElements.GetSize();
			const int nColumnElements = m_aryCurColumnDataElements.GetSize();
			int i;
			for (i=0; i < nDataElements; i++) {
				CEmrInfoDataElement *peide = m_aryCurDataElements.GetAt(i);
				if (peide && peide->m_strData.IsEmpty()) {
					AfxMessageBox("You cannot have a table row with no name. Please ensure that all table rows have names before saving.", MB_OK | MB_ICONHAND);
					return FALSE;
				}
			}
			for (i=0; i < nColumnElements; i++) {
				CEmrInfoDataElement *peide = m_aryCurColumnDataElements.GetAt(i);
				if (peide && peide->m_strData.IsEmpty()) {
					AfxMessageBox("You cannot have a table column with no name. Please ensure that all table columns have names before saving.", MB_OK | MB_ICONHAND);
					return FALSE;
				}
			}
		}*/

		BOOL bUsedInUnlockedEMNs = FALSE;

		// (z.manning 2011-05-02 11:18) - PLID 37604 - We have never counted editing unsaved details on the fly as being
		// in use because if that is the case then that item is going to reflect any changed made here anyway. However,
		// now that we support changing dropdown columns to text columns we must make a copy of a table if we had any
		// such column type changes so that we have two different versions of the item that we can use when later mapping
		// the dropdown contents to text data.
		if(arynDropdownToTextDataIDs.GetSize() > 0 && m_pCalledFromDetail != NULL && m_pCalledFromDetail->m_EMRInfoType == eitTable)
		{
			for(int nTableElementIndex = 0; nTableElementIndex < m_pCalledFromDetail->GetTableElementCount(); nTableElementIndex++)
			{
				TableElement te;
				if(m_pCalledFromDetail->GetTableElementByIndex(nTableElementIndex, te)) {
					if(!te.IsEmpty() && IsIDInArray(te.m_pColumn->nID, arynDropdownToTextDataIDs)) {
						bUsedInUnlockedEMNs = TRUE;
						break;
					}
				}
			}
		}

		// (c.haag 2006-02-24 15:52) - Determine whether this info ID is used in locked
		// or unlocked EMN's
		//
		// (a.walling 2010-10-19 09:45) - PLID 40965 - Use ReturnsRecordsParam
		BOOL bUsedInLockedEMNs = (m_nID == -1) ? FALSE : ReturnsRecordsParam(
			"SELECT 1 FROM EMRDetailsT WHERE Deleted = 0 AND EMRInfoID = {INT} AND EMRID IN "
			"(SELECT ID FROM EMRMasterT WHERE Deleted = 0 AND Status = 2) ", m_nID);

		// (a.walling 2010-10-19 09:45) - PLID 40965 - Use ReturnsRecordsParam
		if(m_nID != -1 && !bUsedInUnlockedEMNs) {
			bUsedInUnlockedEMNs = ReturnsRecordsParam(
				"SELECT 1 FROM EMRDetailsT WHERE Deleted = 0 AND EMRInfoID = {INT} AND EMRID IN "
				"(SELECT ID FROM EMRMasterT WHERE Deleted = 0 AND Status <> 2) ", m_nID);
		}

		BOOL bOnlyInactiveFlagChanged = (arystrMasterFields.GetSize() == 1 && arystrMasterFields[0] == "Inactive") ? TRUE : FALSE;

		// (j.jones 2006-05-04 10:18) - PLID 20432 - ignore if only a "Minor" change

		if (bSomethingCriticalChanged && (bUsedInUnlockedEMNs || bUsedInLockedEMNs))
		{
			// If we get here:
			// - lock-critical information changed, and the item is on locked EMNs
			// - all-critical information changed, and the item is on any saved EMN
			
			// So, we need to save our changes to a new Info item, and make all
			// templates use the new item, and if something lock-critical,
			// but not all-critical, changed, then all unlocked EMNs would also
			// use the new item.
			//
			// Here is the result set:
			//
			// m_nID = Current Info ID = nLockedInfoID = Kept by all locked EMN's and in some cases, unlocked EMNs
			// nUnlockedInfoID = New ID = Inherited by templates and in some cases, unlocked EMNs
			//
			const long nLockedInfoID = m_nID;
			long nUnlockedInfoID;

			//this message is used if bSomethingCriticalAllChanged && (bUsedInLockedEMNs || bUsedInUnlockedEMNs),
			//so just make it the default message
			CString strMessage = "This item is associated with saved patient EMNs, and these changes cannot be applied for those EMNs.\n\n"
					"Do you wish to make a copy of the item with your changes? Any EMN Templates will use the new item.";

			//if we're allowing a change to one detail, tell the user this
			if(bUsedInUnlockedEMNs && GetCalledFromDetailID() != -1) {
				strMessage = "This item is associated with saved patient EMNs, and these changes cannot be applied for those EMNs.\n\n"
					"Do you wish to make a copy of the item with your changes? Any EMN Templates will use the new item.\n"
					"Also, since you are editing a saved detail, that detail will use the new item, while other saved details will use the old item.";
			}
			else if(bUsedInLockedEMNs && !bUsedInUnlockedEMNs) {
				strMessage = "This item is associated only with locked EMN's, and cannot be changed.\n\n"
					"Do you wish to make a copy of the item with your changes? Any EMN Templates will use the new item.";
			}

			//now save the changes to the new item separately, because our current batched sql is no longer valid

			//TES 5/2/2008 - PLID 28992 - Moved this up here, before anything that might return (without rolling back the audit
			// transaction).
			//clear our sql
			strBatchSql = "";
			//undo the pending audits
			if(nAuditTransactionID != -1) {
				RollbackAuditTransaction(nAuditTransactionID);
			}

			// (z.manning 2010-02-12 12:14) - PLID 37320 - Do not show this message if we are not displaying
			// this dialog. (I personally don't see the point of ever dispalying this message.)
			if(m_Behavior != eEmrItemEntryDlgBehavior_OpenInvisibleAndSave) {
				if (IDNO == MsgBox(MB_YESNO, strMessage)) {
					//TES 10/28/2010 - PLID 41174 - Special logging
					if (IsSystemCurrentMedicationsItem()) {
						Log_CurrentMedicationsEdit("Returning FALSE (user cancelled)");
					}
					return FALSE;
				}
			}

			//now we need to copy this item, reassign templates to use the new copy,
			//and repopulate the IDs on this dialog to apply the changes to the new item
			//if we have a passed in detail ID, and thus are editing on the fly, we'll update that item too

			//first create the copy and generate our map of IDs from old to new
			if(!PrepareToReassignEmrInfoItem(nLockedInfoID, nUnlockedInfoID)) {
				//TES 10/28/2010 - PLID 41174 - Special logging
				if (IsSystemCurrentMedicationsItem()) {
					Log_CurrentMedicationsEdit("Returning FALSE (PrepareToReassignEmrInfoItem() failed");
				}
				return FALSE;
			}

			//now re-Apply() from scratch, regenerating the save sql and audits
			//send TRUE that we will ignore the item's presense on unlocked EMNs this time,
			//incase we did allow migration for one detail
			if(!Apply()) {
				//TES 10/28/2010 - PLID 41174 - Special logging
				if (IsSystemCurrentMedicationsItem()) {
					Log_CurrentMedicationsEdit("Returning FALSE (Apply() failed)");
				}
				return FALSE;
			}

			//now reassign the appropriate items (template details, on-the-fly edited details) using our map
			if(!ReassignEmrInfoItem(nLockedInfoID, nUnlockedInfoID)) {
				//TES 10/28/2010 - PLID 41174 - Special logging
				if (IsSystemCurrentMedicationsItem()) {
					Log_CurrentMedicationsEdit("Returning FALSE (ReassignEmrInfoItem() failed)");
				}
				return FALSE;
			}

			//now finish the reassignment
			//TES 10/28/2010 - PLID 41174 - Special logging
			if (IsSystemCurrentMedicationsItem()) {
				Log_CurrentMedicationsEdit(FormatString("calling CopyEmrInfoItemRelationships(%li, %li)", nLockedInfoID, nUnlockedInfoID));
			}
			if (!CopyEmrInfoItemRelationships(nLockedInfoID, nUnlockedInfoID)) {
				//TES 10/28/2010 - PLID 41174 - Special logging
				if (IsSystemCurrentMedicationsItem()) {
					Log_CurrentMedicationsEdit("Returning FALSE (CopyEmrInfoItemRelationships() failed)");
				}
				return FALSE;
			}

			//TES 12/14/2006 - PLID 23792 - This is no longer necessary, the fact that we will set this item as the ActiveEmrInfoID
			// for the EmrInfoMasterT record will be enough to identify which EmrInfoT record is active.
			/*// Inactivate the old EMR Info record
			if (!InactivateEmrInfoItem(nLockedInfoID))
				return FALSE;

			// (j.jones 2006-09-11 12:50) - we discussed this, and decided that even if they
			// edit an inactive item and this process makes a new item, it should indeed activate it

			// Make sure our new EMR Info record is active
			if (!ActivateEmrInfoItem(nUnlockedInfoID))
				return FALSE;*/

			//we are done and do not need to save any more, leave now
			//TES 10/28/2010 - PLID 41174 - Special logging
			if (IsSystemCurrentMedicationsItem()) {
				Log_CurrentMedicationsEdit("Returning TRUE");
			}
			return TRUE;
		}

#ifdef _DEBUG
		// For debugging purposes at the moment we tell the user the exact statement we're about to execute
		//(e.lally 2008-04-10) - changed this to an OK|CANCEL CMsgBox
		CMsgBox dlg(this);
		dlg.msg = strBatchSql;
		dlg.m_bAllowCancel = TRUE;
		UINT result = dlg.DoModal();
		if (result != IDOK) { 
			AfxMessageBox("Save is cancelled.");
			if(nAuditTransactionID != -1) {
				RollbackAuditTransaction(nAuditTransactionID);
			}
			return FALSE;
		}
#endif

		BOOL bRememberForPatient = (IsDlgButtonChecked(IDC_REMEMBER_FOR_PATIENT) && eistCurrentMedicationsTable != m_DataSubType && eistAllergiesTable != m_DataSubType) ? TRUE : FALSE;
		BOOL bRememberForEMR = (IsDlgButtonChecked(IDC_REMEMBER_FOR_EMR) && eistCurrentMedicationsTable != m_DataSubType && eistAllergiesTable != m_DataSubType) ? TRUE : FALSE;

		// (z.manning 2010-02-12 11:43) - PLID 37320 - Before we save we need to check and see if smart
		// stamps are enabled and if they changed the smart stamp table to use.
		// (j.jones 2010-02-26 08:56) - PLID 37231 - also change the table if we changed our "remember" settings
		if((bCurrentEnableSmartStamps && varCurrentSmartStampTableMasterID.vt != VT_NULL &&
			(!m_bEnableSmartStamps || varCurrentSmartStampTableMasterID != m_varSmartStampTableMasterID))
			|| (bCurrentEnableSmartStamps && bRememberForPatient != m_bRememberForPatient)
			|| (bCurrentEnableSmartStamps && bRememberForEMR != m_bRememberForEMR))
		{
			CEmrItemEntryDlg dlgSmartStampTable(this);
			OpenItemEntryDialogForSmartStampTable(VarLong(varCurrentSmartStampTableMasterID), eEmrItemEntryDlgBehavior_OpenInvisibleAndSave);
		}
 
		// We're good to go, run the statement (normally we'd call ExecuteSqlBatch() but we need the returned 
		// recordset and we want no recordsets for the non-select statements, so we put it in a transactiion 
		// and add the select statement ourselves, and call CreateRecordset())
		//TES 10/28/2010 - PLID 41174 - Special logging
		if (IsSystemCurrentMedicationsItem()) {
			Log_CurrentMedicationsEdit("Executing " + strBatchSql);
		}
		_RecordsetPtr prs = CreateRecordset(
			"SET NOCOUNT ON \r\n"
			"BEGIN TRAN \r\n"
			"%s\r\n"
			"COMMIT TRAN \r\n"
			"SET NOCOUNT OFF \r\n"
			"SELECT @nEMRInfoID AS EMRInfoID, @nEMRInfoMasterID AS EmrInfoMasterID\r\n", strBatchSql);

		//TES 12/7/2006 - PLID 23724 - If this was a new Master record, get that ID.
		if(m_nEmrInfoMasterID == -1) {
			m_nEmrInfoMasterID = AdoFldLong(prs->GetFields(), "EmrInfoMasterID");
		}
		// If this was a new info, then we need to grab the emr info ID back out of the returned records
		if (m_nID == -1) {
			m_nID = AdoFldLong(prs->GetFields(), "EMRInfoID");
		}

		// (a.walling 2013-07-18 10:04) - PLID 57629 - Ensure NxCache is up to date
		Nx::Cache::Checkpoint();

		if(nAuditTransactionID != -1) {

			// (j.jones 2006-08-28 16:55) - PLID 22192 - if we have a nAuditTransactionID, then
			// it means we have audits and thus we need to commit the transaction, but before we
			// do that, we need to audit every template this item exists on

			_RecordsetPtr rsTemplates = CreateRecordset("SELECT ID, Name FROM EMRTemplateT "
				"WHERE ID IN (SELECT TemplateID FROM EMRTemplateDetailsT WHERE EMRInfoMasterID = %li) "
				"AND Deleted = 0 ORDER BY Name", m_nEmrInfoMasterID);
			while(!rsTemplates->eof) {

				long nID = AdoFldLong(rsTemplates, "ID");
				CString strTemplateName = AdoFldString(rsTemplates, "Name");
				
				CString strItemName;
				GetDlgItemText(IDC_ITEM_NAME, strItemName);
				strItemName.TrimLeft();
				strItemName.TrimRight();

				CString strNewValue;
				strNewValue.Format("Item '%s' changed on template '%s'", strItemName, strTemplateName);

				if(nAuditTransactionID == -1)
					nAuditTransactionID = BeginAuditTransaction();
				AuditEvent(-1, "", nAuditTransactionID, aeiEMNTemplateDetailChangedInAdmin, nID, "", strNewValue, aepMedium, aetChanged);

				rsTemplates->MoveNext();
			}
			rsTemplates->Close();

			//and now commit all of the audits
			CommitAuditTransaction(nAuditTransactionID);
		}

		{
			//TES 12/12/2006 - PLID 22321 - Now that we know the data has been saved, update our EMN with any variables it needs
			// (at the moment, just which actions to revoke, and then only if it's a template).  Note that we don't clear this list,
			// we just append to it, because another CEmrItemEntryDlg (like, if we edited from an action) might have already put
			// some values in there.
			if(m_pCurrentEMN && m_pCurrentEMN->IsTemplate()) {
				for(int i = 0; i < m_arActionsToRevoke.GetSize(); i++) {
					m_pCurrentEMN->m_arActionsToRevoke.Add(m_arActionsToRevoke[i]);
				}
			}
			//Now that we've done that, clear our local list (probably unnecessary, since we're probably about to be destroyed, but
			// might as well).
			m_arActionsToRevoke.RemoveAll();
		}

		// Also now that we've successfully committed, we'll want to update the internal variables to 
		// reflect the new state.
		{
			// Get the name
			GetDlgItemText(IDC_ITEM_NAME, m_strName);
			m_strName.TrimLeft();
			m_strName.TrimRight();

			// Get the long form
			GetDlgItemText(IDC_SENTENCE, m_strLongForm);
			// (a.walling 2007-06-13 09:55) - PLID 26295 - There is no reason to Trim here if we are not Trimming what we save.
			// For example, the item name is trimmed before saving, so it must be consistent. The long form can make good use
			// of spaces before and after.
			/*m_strLongForm.TrimLeft();
			m_strLongForm.TrimRight();*/

			if (IsDlgButtonChecked(IDC_DATA_FORMAT_TEXT)) {
				m_nDataFormat = 0;
			}else if (IsDlgButtonChecked(IDC_DATA_FORMAT_BULLET)) {
				m_nDataFormat = 1;
			}else if (IsDlgButtonChecked(IDC_DATA_FORMAT_NUMBER)) {
				m_nDataFormat = 2;
			}else if (IsDlgButtonChecked(IDC_DATA_FORMAT_LIST)) {
				m_nDataFormat = 3;
			}else {
				m_nDataFormat = 0;
			}

			GetDlgItemText(IDC_DATA_FORMAT_SEPARATOR, m_strDataSeparator);
			GetDlgItemText(IDC_DATA_FORMAT_SEPARATOR_FINAL, m_strDataSeparatorFinal);

			m_nDataType = nCurDataType;

			// (a.walling 2009-05-28 15:18) - PLID 34389 - Update the member variables
			m_nxeditDataUnit.GetWindowText(m_strEmrDataCodeUnit);
			m_nEmrDataCodeID = nCurrentEmrDataCodeID;

			// (z.manning 2010-02-09 15:11) - PLID 37228 - Update smart stamp member
			m_bEnableSmartStamps = bCurrentEnableSmartStamps;

			// (j.jones 2007-08-14 16:58) - PLID 27052 - added E/M Category
			m_nEMCodeCategoryID = nCurEMCodeCategoryID;
			// (j.jones 2011-03-08 12:25) - PLID 42282 - added m_eEMCodeUseTableCategories
			m_eEMCodeUseTableCategories = eCurEMCodeUseTableCategories;
			// (j.jones 2007-08-14 16:58) - PLID 27053 - added E/M Code Type
			m_bUseEMCoding = bCurUseEMCoding;
			m_emctEMCodingType = emctCurEMCodingType;

			m_varSmartStampTableMasterID = varCurrentSmartStampTableMasterID; // (z.manning 2010-03-22 14:08) - PLID 37228

			//TES 3/11/2011 - PLID 42757 - Added Glasses Order data
			m_bHasGlassesOrderData = bCurHasGlassesOrderData;
			m_GlassesOrderLens = CurGlassesOrderLens;
			//TES 4/6/2012 - PLID 49367 - Added Contact Lens data
			m_bSavedHasContactLensData = m_bHasContactLensData;

			// (r.gonet 08/03/2012) - PLID 51735
			m_bUseWithWoundCareCoding = bCurUseWithWoundCareCoding;

			// (c.haag 2006-03-07 10:22) - PLID 19581 - If this is a table item, and we changed a column
			// type, and we also edited this from an open EMR, we need to make sure that all the elements
			// in that column for every detail with a matching EmrInfoID are cleared out. If we don't
			// do this, then we have a situation, for example, where a column that was changed from
			// a dropdown to a text box would wind up full of 0's and -1's.
			//
			// To clear them out, we rebuild the detail state, only we omit elements that belonged
			// to the column in question
			//
			// (c.haag 2007-08-25 09:26) - PLID 26579 - The previous algorithm did not properly handle
			// text cells with semi-colons in them. Additionally, it assumed that every table cell existed
			// in the state. Since that is no longer true, we must create the new state string by doing
			// two things in order:
			//
			//	1. Add all of the entries which do not correspond to the changed column from the old state
			//	to the new state.
			//
			//	2. If the new column style is a dropdown or a checkbox, add a "0" data element for every
			//	table row to the new state. While we no longer require empty spaces for text and linked details,
			//	we do require "0"'s for empty dropdown and checkbox cells.
			//
			//	Note: The legacy code here made no attempt to remove state information for deleted rows, or
			//  add state information for new rows...so neither will we.
			//
			//
			for (int i=0; i < m_apCurrentTableDetails.GetSize(); i++) {
				CEMNDetail* pDetail = m_apCurrentTableDetails[i];
				const int nOldTableRows = pDetail->GetRowCount();

				for (int j=0; j < m_aryChangedCols.GetSize(); j++) {
					CString str = VarString(pDetail->GetState(), "");
					CString strNewState;
					CEmrInfoDataElement *peideChangedCol = m_aryChangedCols[j];
					long nNewDataID = peideChangedCol->m_nID;
					long nOldDataID = -1;

					// (c.haag 2007-08-25 10:57) - PLID 27183 - If the column is not new, we must get its old
					// data ID because the detail state still uses the old data ID
					EMRInfoChangedData *picd = NULL;
					if (-1 != nNewDataID) {
						if (NULL != m_pChangedIDMap) {
							const int nChangedDataIDs = m_pChangedIDMap->aryChangedDataIDs.GetSize();
							for (int iChange=0; iChange < nChangedDataIDs && -1 == nOldDataID; iChange++) {
								picd = m_pChangedIDMap->aryChangedDataIDs[iChange];
								if (nNewDataID == picd->nNewDataID) {
									nOldDataID = picd->nOldDataID;	
								}
							}
							// If this assertion is fired, it means that the new data ID has no old counterpart!
							// Something else in the saving is bugged if we get here.
							ASSERT(-1 != nOldDataID);
						} else {
							// It's not a new column, but it's not in the changed ID map. That can only happen
							// if you changed a column for an EMR item that does not exist for any existing
							// patient charts. Ergo, there is no "old ID" for this Emr Data element.
						}
					}

					// (c.haag 2007-08-24 17:29) - PLID 26579 - This legacy body of code rebuilds the
					// detail state with the column elements "blanked out." We used to improperly traverse
					// through the state in that we did not consider formatted semi-colons. We
					// now do this by simply using the iterator utility function.
					//

					//
					// 1. Add all of the entries which do not correspond to the changed column from the old state
					// to the new state.
					//
					CEmrTableStateIterator etsi(str);
					long X,Y,nEmrDetailImageStampID,nEmrDetailImageStampPointer,nStampID;
					CString strData;
					// (z.manning 2010-02-18 09:47) - PLID 37427 - Added EmrDetailImageStampID
					while (etsi.ReadNextElement(X,Y,strData,nEmrDetailImageStampID,nEmrDetailImageStampPointer,nStampID)) {						
						if (Y != nOldDataID && Y != nNewDataID) {
							// If the columns do not match, append the element to the new state
							AppendTableStateWithUnformattedElement(strNewState, X, Y, strData, nEmrDetailImageStampID, nEmrDetailImageStampPointer, nStampID);
						}
						else if (picd != NULL) {
							// (z.manning 2011-05-02 11:04) - PLID 37604 - Also, if this was a dropdown column that was changed
							// to text let's go ahead and keep the dropdown data because we now support this column change type.
							// The actualy text value will be set on any EMN details in SyncContentAndStateWithChangedInfo.
							if(picd->nOldListType == LIST_TYPE_DROPDOWN && peideChangedCol->m_nListType == LIST_TYPE_TEXT) {
								AppendTableStateWithUnformattedElement(strNewState, X, Y, strData, nEmrDetailImageStampID, nEmrDetailImageStampPointer, nStampID);
							}
						}
						else {
							// If the columns do match, do NOT append the element to the state.
							// If we need to, that will be done in the next loop.
						}
					}
					// 2. If the new style is a dropdown or a checkbox, we need to add one '0' data element
					// for every old table row. Here is a snippet from the old code that explains the sentinel
					// empty value for each column type:
					//
					// Text: <empty string>
					// Dropdown: 0
					// Checkbox: 0
					// Linked detail: <empty string>
					//
					// This only applies to columns that already exist in the table for the purpose of clearing
					// them out. New columns don't do this.
					//
					long iRow;
					switch (m_aryChangedCols[j]->m_nListType) {
					case 4: // Dropdown
					case 5: // Checkbox
						for (iRow=0; iRow < nOldTableRows; iRow++) {
							TableRow* pRow = pDetail->GetRowPtr(iRow);
							// (c.haag 2012-10-26) - PLID 53440 - Use the new getter functions
							AppendTableStateWithUnformattedElement(strNewState, pRow->m_ID.nDataID, nOldDataID, "0", pRow->m_ID.GetDetailImageStampID(), (long)pRow->m_ID.GetDetailImageStampObject(), pRow->m_ID.GetImageStampID());
						}
						break;
					default:
						break;
					}

					pDetail->SetState((LPCTSTR)strNewState);
				}
			}

			// (a.walling 2008-10-22 12:16) - PLID 31794 - check for changed values in preview flags
			try {
				if (m_nPreviewFlags != nPreviewFlags) {
					CString strMessage = "You have %s the flag to %s this item in the preview. "
							"This change will only affect new copies of this item added into templates.\r\n\r\n"
							"Do you want to update this item on all existing templates?";

					DWORD dwAddedFlags = 0;
					DWORD dwRemovedFlags = 0;

					// epfHideTitle
					if ( (m_nPreviewFlags & epfHideTitle) != (nPreviewFlags & epfHideTitle) ) {
						CString strPrompt;
						strPrompt.Format(strMessage, (nPreviewFlags & epfHideTitle) ? "added" : "removed", "hide the title of");
						if (IDYES == MessageBox(strPrompt, NULL, MB_YESNO|MB_ICONQUESTION)) {
							if (nPreviewFlags & epfHideTitle) {
								// add flag
								dwAddedFlags |= epfHideTitle;
							} else {
								// remove flag
								dwRemovedFlags |= epfHideTitle;
							}
						}
					}

					// epfHideItem
					if ( (m_nPreviewFlags & epfHideItem) != (nPreviewFlags & epfHideItem) ) {
						CString strPrompt;
						strPrompt.Format(strMessage, (nPreviewFlags & epfHideItem) ? "added" : "removed", "hide");
						if (IDYES == MessageBox(strPrompt, NULL, MB_YESNO|MB_ICONQUESTION)) {
							if (nPreviewFlags & epfHideItem) {
								// add flag
								dwAddedFlags |= epfHideItem;
							} else {
								// remove flag
								dwRemovedFlags |= epfHideItem;
							}
						}
					}

					// epfHideIfIndirect
					// (a.walling 2012-07-13 16:38) - PLID 48896
					if ( (m_nPreviewFlags & epfHideIfIndirect) != (nPreviewFlags & epfHideIfIndirect) ) {
						CString strPrompt;
						strPrompt.Format(strMessage, (nPreviewFlags & epfHideIfIndirect) ? "added" : "removed", "allow hide if indirectly included on a narrative");
						if (IDYES == MessageBox(strPrompt, NULL, MB_YESNO|MB_ICONQUESTION)) {
							if (nPreviewFlags & epfHideIfIndirect) {
								// add flag
								dwAddedFlags |= epfHideIfIndirect;
							} else {
								// remove flag
								dwRemovedFlags |= epfHideIfIndirect;
							}
						}
					}


					CString strUpdatePreviewFlagsSql = UpdatePreviewFlagsOnTemplates(dwAddedFlags, dwRemovedFlags);
					ExecuteSqlStd(strUpdatePreviewFlagsSql);
				}
			} NxCatchAll("Failed to update existing preview flags");

			// (a.walling 2008-06-30 17:23) - PLID 30570
			m_nPreviewFlags = nPreviewFlags;
			
			// (b.cardillo 2004-11-18 12:42) - Really we should do all the rest of the variables but 
			// for now there's no need, since this Apply() truly is an "OK" in the sense that the 
			// dialog closes immediately upon success whenever this is called.  Someday we'll probably 
			// make it a true "Apply" and when that day comes we'll have to update the rest of the 
			// variables here.  Notice, right now there are only two public "Get" member functions, 
			// they are the GetID() and GetName(), which you'll see are the only two variables that 
			// we update here after the save.
		}
	}
	//TES 10/28/2010 - PLID 41174 - Special logging
	if (IsSystemCurrentMedicationsItem()) {
		Log_CurrentMedicationsEdit("Returning TRUE (2)");
	}
	return TRUE;
}

// (z.manning 2010-02-12 12:17) - PLID 37320 - Function to combine the the validate and save logic
BOOL CEmrItemEntryDlg::ValidateSaveAndClose()
{
	//TES 10/28/2010 - PLID 41174 - Special logging
	if (IsSystemCurrentMedicationsItem()) {
		Log_CurrentMedicationsEdit("Calling ValidateSaveAndClose()");
	}
	CWaitCursor wc;
	// First make sure the current state is saveable
	if (Validate()) {
		try {
			// Then apply and close (the apply throws exceptions on failure)
			//TES 10/28/2010 - PLID 41174 - Special logging
			if (IsSystemCurrentMedicationsItem()) {
				Log_CurrentMedicationsEdit("Calling Apply()");
			}
			if (Apply()) {
				//TES 10/28/2010 - PLID 41174 - Special logging
				if (IsSystemCurrentMedicationsItem()) {
					Log_CurrentMedicationsEdit("Apply() succeeded");
				}
				// Send network code
				CClient::RefreshTable(NetUtils::EMRInfoT, m_nID);
				//TES 12/8/2006 - PLID 23790 - Details that were up to date may not be any more.
				CClient::RefreshTable(NetUtils::EmrInfoMasterT, m_nEmrInfoMasterID);

				// (c.haag 2007-02-07 13:49) - PLID 24422 - This function will pop up an exception message if,
				// for some unexpected reason, a record exists in DrugList with a bad EmrDataID, or a record exists
				// in EmrDataT for the active Current Medications item that does not correspond to DrugList
				// (c.haag 2007-02-08 16:09) - PLID 24423 - Call this function outside Apply() because Apply()
				// actually calls itself. The PLID above (24422) is actually the incorrect number for this
				// feature (and the PL notes prove it).
				if (IsSystemCurrentMedicationsItem()) {
					WarnEmrDataDiscrepanciesWithDrugList();
				}
				// (c.haag 2007-04-03 09:34) - PLID 25468 - Do the same safety check for allergies, too.
				if (IsSystemAllergiesItem()) {
					WarnEmrDataDiscrepanciesWithAllergyT();
				}

				// We're done, close the window
				CDialog::OnOK();
				//TES 10/28/2010 - PLID 41174 - Special logging
				if (IsSystemCurrentMedicationsItem()) {
					Log_CurrentMedicationsEdit("Dialog closed");
				}
				return TRUE;
			}
		} 
		catch (_com_error& e) {
			// (a.walling 2009-06-30 15:38) - PLID 34759 - Warn the user that another user edited this, then exit out of here.
			BOOL bHandledException = FALSE;
			CSQLErrorInfo eSqlError;
			if (GetSQLErrorInfo(e, eSqlError) && eSqlError.IsNxRaisedError()) {
				if (eSqlError.nState == 41) {
					// revision is out of date
					MessageBox("This item could not be saved; it has been modified by another user since it was initially opened.\r\n\r\nYou must bring this item up to date before editing.", NULL, MB_ICONHAND);
					CDialog::OnCancel();
					return FALSE;
				}
			}

			throw e;
		}
	}

	return FALSE;
}

void CEmrItemEntryDlg::OnOK() 
{
	try {

		ValidateSaveAndClose();

	} NxCatchAll("CEmrItemEntryDlg::OnOK");
}

void CEmrItemEntryDlg::OnBtnPreviewTable()
{
	try
	{
		PreviewTable(&m_aryCurDataElements, &m_aryCurColumnDataElements);

	}NxCatchAll("CEmrItemEntryDlg::OnBtnPreviewTable");
}

// (z.manning 2008-06-09 17:20) - PLID 30145 - Added public function to preview the table
void CEmrItemEntryDlg::PreviewTable(CEmrInfoDataElementArray *paryRows, CEmrInfoDataElementArray *paryColumns) 
{
	try {

		if(!AtLeastOneActiveRowAndColumn()) {
			return;
		}

		CEMRItemAdvPopupDlg dlg(this);
		//Create a temporary EMR.
		CEMR emr;
		emr.CreateNew(-1, TRUE);
		// (z.manning 2009-03-16 17:32) - PLID 33138 - Ignore actions on the table preview.
		emr.m_bIgnoreActions = TRUE;
		SourceActionInfo saiBlank; // (z.manning 2009-03-04 15:39) - PLID 33338
		//TES 4/15/2010 - PLID 24692 - Pass in -1 for the topic ID.
		// (a.walling 2013-01-22 10:00) - PLID 54762 - Emr Appointment linking
		CEMRTopic *pTopic = emr.AddEMNFromTemplate(-1, saiBlank, NULL, -1)->AddTopic("", -1);
		//Create a temporary EMN Detail.
		// (a.walling 2009-10-23 09:23) - PLID 36046 - Track construction in initial reference count
		CEMNDetail *pDetail = CEMNDetail::CreateDetail(pTopic, "EMR item entry preview detail");		
		// (c.haag 2007-05-22 12:52) - PLID 26095 - Don't increment the reference count.
		// Only the topic should be responsible for maintaining the detail before this
		// function loses scope
		pTopic->AddDetail(pDetail, FALSE, FALSE);
	

		pDetail->m_nEMRInfoID = m_nID;
		pDetail->m_nEMRInfoMasterID = m_nEmrInfoMasterID;
		pDetail->m_EMRInfoType = eitTable;
		// (c.haag 2008-10-21 16:02) - PLID 31708 - Carry over the flipped table flag
		pDetail->m_bTableRowsAsFields = IsDlgButtonChecked(IDC_TABLE_ROWS_AS_FIELDS) ? TRUE : FALSE;
		CString strName;
		GetDlgItemText(IDC_ITEM_NAME, strName);
		pDetail->SetLabelText(strName);
		pDetail->SetState("");

		//TES 3/14/2011 - PLID 42784 - Converted to datalist2
		NXDATALIST2Lib::IRowSettingsPtr pRow = m_pdlDataElementList->GetFirstRow();
		int nRowIndex = 0;
		while(pRow) {

			_variant_t var = pRow->GetValue( delcInactive);
			
			if(!VarBool(var)) {

				long nRowID = VarLong(pRow->GetValue(delcID));
				CString strRowName = VarString(pRow->GetValue(delcData));
				long nSortOrder = VarLong(pRow->GetValue(delcSortOrder));

				CEmrInfoDataElement *pRowData = NULL;
				for(int nRow = 0; nRow < paryRows->GetSize() && pRowData == NULL; nRow++) {
					CEmrInfoDataElement *pTemp = paryRows->GetAt(nRow);
					if(pTemp->m_nSortOrder == nSortOrder) {
						pRowData = pTemp;
					}
				}

				//add to the detail

				// (j.jones 2006-08-08 13:32) - PLID 21851 - the detail doesn't support
				// -1 IDs so we need to give it a unique ID for the purposes of previewing
				if(nRowID == -1) {
					nRowID = -1 * nRowIndex;
				}
				
				//(e.lally 2011-12-08) PLID 46471
				BOOL bIsCurrentMedOrAllergy = ((pDetail->IsCurrentMedicationsTable() || pDetail->IsAllergiesTable()) ? TRUE : FALSE);
				// (z.manning 2009-02-24 14:07) - PLID 33141 - Added -1 for group ID
				//TES 3/17/2010 - PLID 37530 - Need to specify the stamp ID and index (obviously they're -1 here).
				// (z.manning 2010-04-13 16:19) - PLID 38175 - Handled IsLabel parameter
				// (j.jones 2011-03-09 09:05) - PLID 42283 - send -1 for nEMCodeCategoryID
				//TES 3/17/2011 - PLID 41108 - Added GlassesOrderDataType and GlassesOrderDataID
				// (c.haag 2011-05-31) - PLID 43875 - We now specify ordering
				//(e.lally 2011-12-08) PLID 46471 - Specify if this is for a Current Medication or Allergies detail. The value shouldn't matter in this case though.
				// (a.walling 2013-03-21 09:49) - PLID 55804 - EM coding stuff unused
				pDetail->AddRow(TableRowID(nRowID,-1,NULL,-1,-1), strRowName, pRowData->m_strFormula, pRowData->m_nDecimalPlaces, -1, pRowData->m_bIsLabel, pRowData->m_GlassesOrderDataType, pRowData->m_nGlassesOrderDataID, pRowData->m_nFlags, CEMNDetail::aroSequential, -1, bIsCurrentMedOrAllergy);
			}
			else {
				Sleep(0);
			}
			pRow = pRow->GetNextRow();
			nRowIndex++;
		}

		// (z.manning 2011-05-04 15:41) - PLID 43560 - If this table doesn't have any formulas then we probably haven't
		// set the visible indices, so we must do that now before we preview the table.
		if(!m_bHasFormulas) {
			UpdateVisibleIndices(TRUE);
		}

		//TES 3/14/2011 - PLID 42784 - Converted to datalist2
		NXDATALIST2Lib::IRowSettingsPtr pColRow = m_pdlColumnDataElementList->GetFirstRow();
		long nColRowIndex = 0;
		while(pColRow) {

			if(!VarBool(pColRow->GetValue(cdelcInactive))) {

				long nColumnID = VarLong(pColRow->GetValue(cdelcID));
				CString strColumnName = VarString(pColRow->GetValue(cdelcData));
				long nListType = VarLong(pColRow->GetValue(cdelcType));
				BOOL bIsGrouped = VarBool(pColRow->GetValue(cdelcIsGrouped));
				long nSortOrder = VarLong(pColRow->GetValue(cdelcSortOrder));

				CEmrInfoDataElement *pColumnData = NULL;
				for(int nCol = 0; nCol < paryColumns->GetSize() && pColumnData == NULL; nCol++) {
					CEmrInfoDataElement *pTemp = paryColumns->GetAt(nCol);
					if(pTemp->m_nSortOrder == nSortOrder) {
						pColumnData = pTemp;
					}
				}

				//add to the dialog

				// (j.jones 2006-08-08 13:32) - PLID 21851 - the detail doesn't support
				// -1 IDs so we need to give it a unique ID for the purposes of previewing
				if(nColumnID == -1) {
					nColumnID = -1*nColRowIndex;
				}

				//(e.lally 2011-12-08) PLID 46471 - We don't have all the information we need to know whether or not this is the usage column for current medication or allergy table details.
				// Because it is just a table preview, the flag value should not matter in this case.
				BOOL bIsCurrentMedOrAllergyUsageCol = FALSE;

				//DRT 7/10/2007 - PLID 24105 - No longer requires a width
				// (z.manning 2009-01-15 15:11) - PLID 32724 - Added InputMask
				// (z.manning 2010-02-16 14:32) - PLID 37230 - Added sub type parameter
				// (c.haag 2010-02-24 15:33) - PLID 21301 - AutoAlphabetizeDropdown
				// (z.manning 2010-04-13 16:19) - PLID 38175 - Handled IsLabel parameter
				// (z.manning 2010-07-29 15:22) - PLID 36150 - Added sentence format
				// (j.jones 2010-08-11 15:52) - PLID 39496 - added AutoNumberType and AutoNumberPrefix
				// (j.jones 2011-03-09 09:05) - PLID 42283 - send -1 for nEMCodeCategoryID
				// (z.manning 2011-03-14) - PLID 42778 - Set bHasDropdownElements to true
				//TES 3/17/2011 - PLID 41108 - Added GlassesOrderDataType and GlassesOrderDataID
				// (z.manning 2011-03-21 12:02) - PLID 30608 - Added a param for autofill type
				//(e.lally 2011-12-08) PLID 46471 - added bIsCurrentMedOrAllergyUsageCol
				// (r.gonet 08/03/2012) - PLID 51735 - Added WoundCareDataType
				// (a.walling 2013-03-21 09:49) - PLID 55804 - EM coding stuff unused
				pDetail->AddColumn(nColumnID, strColumnName, nListType, bIsGrouped, pColumnData->m_strFormula, pColumnData->m_nDecimalPlaces, pColumnData->m_strInputMask, pColumnData->m_nListSubType, pColumnData->m_bAutoAlphabetizeDropDown, pColumnData->m_bIsLabel, pColumnData->m_strLongForm, (EEmrTableAutoNumberType)pColumnData->m_nAutoNumberType, pColumnData->m_strAutoNumberPrefix, TRUE, TRUE, pColumnData->m_GlassesOrderDataType, pColumnData->m_nGlassesOrderDataID, pColumnData->m_eAutofillType, pColumnData->m_nFlags, pColumnData->m_strDropdownSeparator, pColumnData->m_strDropdownSeparatorFinal, pColumnData->m_strSpawnedItemsSeparator, bIsCurrentMedOrAllergyUsageCol, pColumnData->m_ewccWoundCareDataType);


				// (z.manning 2011-03-09) - PLID 42722 - Also do this for text columns
				if(nListType == LIST_TYPE_DROPDOWN || nListType == LIST_TYPE_TEXT)
				{
					//calculate the combo sql
					CString strComboSql = "";
					long nIndex = GetCurDataElementArrayIndex(VarLong(pColRow->GetValue(cdelcSortOrder)), TRUE);
					if(nIndex != -1) {
						// (j.jones 2008-06-03 17:22) - PLID 27232 - this needs to pass in the fields ID, Data, Active, and SortOrder,
						// because newer code recalculates these fields later and needs to access them by name
						// (a.walling 2014-06-30 10:21) - PLID 62497
						for(const auto& pddi : m_aryCurColumnDataElements.GetAt(nIndex)->m_arypEMRDropDownList) {
							CString strName = pddi->strData;
							// (z.manning 2008-06-10 09:39) - PLID 30145 - We need to pass in the actual ID
							// instead of an arbitrary index so that calculations work correctly.
							long nID = pddi->nID;
							BOOL bInactive = pddi->bInactive;
							if(nID > 0) {
								CString str;
								// (z.manning 2009-03-19 15:26) - PLID 33576 - Renamed active to visible to be
								// consistent with everywhere else.
								// (j.jones 2009-12-22 08:58) - PLID 31028 - handle Inactive dropdown items
								// (j.jones 2011-04-28 14:39) - PLID 43122 - handle IsFloated
								// (z.manning 2011-10-26 12:57) - PLID 42061 - Added StampID
								// (j.jones 2012-12-04 16:15) - PLID 53144 - split StampID into FilterStampID and DefaultStampID
								str.Format(" UNION SELECT %li AS ID, '%s' AS Data, %li AS Visible, -1 AS DropdownGroupID, Convert(bit,0) AS IsFloated",
									nID, _Q(strName), bInactive ? 0 : 1);
								strComboSql += str;
							}
							else {
								// (z.manning 2008-06-26 10:45) - This must be a newly entered dropdown element.  Add it as an
								// extra value since it can't be loaded from data.
								// (z.manning 2008-09-23 11:57) - PLID 31356 - The detail only contains active
								// columns so use the visible index instead of the raw index.
								TableColumn *ptc = pDetail->GetColumnPtr(m_aryCurColumnDataElements.GetAt(nIndex)->m_nVisibleIndex - 1);
								if(ptc != NULL) {
									// (j.jones 2009-12-22 08:58) - PLID 31028 - handle Inactive dropdown items
									ptc->AddEmbeddedComboValue(strName, !bInactive);
								}
							}
						}
						if(!strComboSql.IsEmpty()) {
							// (j.jones 2011-04-28 14:39) - PLID 43122 - handle IsFloated
							// (z.manning 2011-10-26 12:57) - PLID 42061 - Added StampID
							// (j.jones 2012-12-04 16:15) - PLID 53144 - split StampID into FilterStampID and DefaultStampID
							strComboSql = "SELECT -1 AS ID, '' AS Data, 1 AS Visible, -1 AS DropdownGroupID, Convert(bit,0) AS IsFloated " + strComboSql;							
						}
					}

					//account for having no options
					if(strComboSql.IsEmpty()) {
						// (j.jones 2011-04-28 14:39) - PLID 43122 - handle IsFloated
						// (z.manning 2011-10-26 12:57) - PLID 42061 - Added StampID
						// (j.jones 2012-12-04 16:15) - PLID 53144 - split StampID into FilterStampID and DefaultStampID
						// (j.jones 2013-03-04 15:51) - PLID 55422 - actions, stamp filters, and stamp defaults are now their own queries,
						// but they should return empty recordsets
						strComboSql = "SELECT -1 AS ID, '' AS Data, 1 AS Visible, -1 AS DropdownGroupID, Convert(bit,0) AS IsFloated";
					}

					// (j.jones 2013-03-04 15:51) - PLID 55422 - stamp filters and stamp defaults are now their own queries,
					// but they should return empty recordsets
					strComboSql += "\r\n"
						"SELECT NULL AS EMRTableDropdownInfoID, NULL AS StampID WHERE 1=0 \r\n"		//stamp filters
						"SELECT NULL AS EMRTableDropdownInfoID, NULL AS StampID WHERE 1=0 \r\n";	//stamp defaults

					// (z.manning 2011-10-10 18:00) - PLID 42061 - This now takes a SQL fragment
					pDetail->SetColumnSql(nColumnID, CSqlFragment(strComboSql));
				}
			}
			pColRow = pColRow->GetNextRow();
			nColRowIndex++;
		}
		// (c.haag 2006-04-05 09:27) - PLID 19883 - If this flag is set when we open the
		// dialog, then it will cause the table to be empty in the preview. There is no
		// need to reload content because we just filled it.
		pDetail->SetNeedContentReload(FALSE);
		pDetail->UpdateTableCalculatedFields(); // (z.manning 2012-07-16 17:16) - PLID 33710

		//TES 4/6/2007 - PLID 25456 - Pass in TRUE, to tell the dialog that this detail is an independent copy.
		// (a.walling 2008-01-18 12:18) - PLID 14982 - Pass NULL as the real detail
		dlg.SetDetail(pDetail, TRUE, NULL);
		//Give it a blank linked detail.
		dlg.m_strLinkedItemList = "; ;";

		dlg.DoModal();

	}NxCatchAll("Error previewing table.");
}

void CEmrItemEntryDlg::OnBtnEditTableDropdownData()
{
	try {
		//TES 3/14/2011 - PLID 42784 - Converted to datalist2
		NXDATALIST2Lib::IRowSettingsPtr pCurSel = m_pdlColumnDataElementList->CurSel;
		if(pCurSel == NULL) {
			AfxMessageBox("Please select an item from the column list before editing its dropdown data.");
			return;
		}

		long nColumnID = VarLong(pCurSel->GetValue(cdelcID));
		long nSortOrder = VarLong(pCurSel->GetValue(cdelcSortOrder));

		BOOL bAllowEdit = TRUE;

		// (j.jones 2005-05-06 14:17) - PLID 15791 - re-worked this so you can always edit the list,
		// but you may not be able to change contents once inside the list
		/*
		if(nColumnID != -1) {
			//do the standard warning for table usage

			//if it is used on an EMN, but not filled in, you may change it
			//if it is used on a template, and no defaults are selected, you may change it
			//otherwise, you cannot change it

			long nEMNUsed = 0;
			long nEMNFilled = 0;
			long nTemplateUsed = 0;
			long nTemplateFilled = 0;

			_RecordsetPtr prs = CreateRecordset("SELECT "
				"(SELECT COUNT(DISTINCT EMRID) FROM EMRDetailsT WHERE EMRInfoID = %li) AS EMNUsed, "
				"(SELECT COUNT(DISTINCT TemplateID) FROM EMRTemplateDetailsT WHERE EMRInfoID = %li) AS TemplateUsed, "
				"(SELECT COUNT(DISTINCT EMRID) FROM EMRDetailsT WHERE EMRInfoID = %li AND ID IN (SELECT EMRDetailID FROM EMRDetailTableDataT WHERE EMRDataID_Y = %li)) AS EMNFilled, "
				"(SELECT COUNT(DISTINCT TemplateID) FROM EMRTemplateDetailsT WHERE EMRInfoID = %li AND ID IN (SELECT EMRDetailID FROM EMRDetailTableDataT WHERE EMRDataID_Y = %li)) AS TemplateFilled ",
				m_nID, m_nID, m_nID, nColumnID, m_nID, nColumnID);
			if (!prs->eof) {
				FieldsPtr pflds = prs->GetFields();
				nEMNUsed = AdoFldLong(pflds, "EMNUsed");
				nEMNFilled = AdoFldLong(pflds, "EMNFilled");
				nTemplateUsed = AdoFldLong(pflds, "TemplateUsed");
				nTemplateFilled = AdoFldLong(pflds, "TemplateFilled");
			} else {
				// This should be impossible
				ASSERT(FALSE);
				nEMNUsed = nEMNFilled = nTemplateUsed = nTemplateFilled = -1;
			}

			CString strWarning;

			if ((nEMNUsed != 0 || nTemplateUsed != 0) && nEMNFilled == 0 && nTemplateFilled == 0) {
				//it exists on an EMN or a Template
				strWarning.Format(
					"This table exists on %s EMNs and %s EMN Templates. However, no data has been entered for this column in any of these tables.\n"
					"If you change column dropdown data, the column will be changed on all existing EMNs and EMN Templates.\n\n"
					"Are you SURE you wish to change the column dropdown data?\n\n"
					"(If 'No', you will still be able to view the data.)",
					nEMNUsed == -1 ? "an unknown number of" : AsString(nEMNUsed), 
					nTemplateUsed == -1 ? "an unknown number of" : AsString(nTemplateUsed));

				int nResult = MessageBox(strWarning,"Practice",MB_YESNOCANCEL|MB_ICONEXCLAMATION);
				if(nResult == IDCANCEL)
					return;
				else if(nResult == IDNO)
					bAllowEdit = FALSE;
			}
			else if ((nEMNFilled != 0 || nTemplateFilled != 0) && ((nEMNUsed != 0 || nTemplateUsed != 0))) {
				strWarning.Format(
					"This table exists on %s EMNs and %s EMN Templates. In addition, data has been entered for this column on %s EMNs and %s EMN Templates.\n"
					"You will not be allowed to change this column dropdown data until you first remove the table from these EMNs and/or EMN Templates.",
					nEMNUsed == -1 ? "an unknown number of" : AsString(nEMNUsed), 
					nTemplateUsed == -1 ? "an unknown number of" : AsString(nTemplateUsed),
					nEMNFilled == -1 ? "an unknown number of" : AsString(nEMNFilled), 
					nTemplateFilled == -1 ? "an unknown number of" : AsString(nTemplateFilled));

				AfxMessageBox(strWarning);
				bAllowEdit = FALSE;
			}
		}
		*/

		//if we're still here, we're allowed to edit the list
		{

			// (z.manning 2009-02-10 14:49) - PLID 33026 - We need to pass this dialog in as the
			// dropdown editor's parent.
			CEMRTableDropdownEditorDlg dlg(this);

			dlg.m_nDataID = VarLong(pCurSel->GetValue(cdelcID));			
			//TES 3/15/2011 - PLID 42757 - Tell the dialog what type of Glasses Order field to link entries to.
			dlg.m_GlassesOrderDataType = (GlassesOrderDataType)VarLong(pCurSel->GetValue(cdelcGlassesOrderDataType),(long)godtInvalid);
			dlg.m_strColumnName = VarString(pCurSel->GetValue(cdelcData));
			dlg.m_bAllowEdit = bAllowEdit;
			// (c.haag 2006-03-13 15:05) - PLID 19689 - We now check the open EMR as well
			dlg.m_bMaintainCurrentTable = m_bMaintainCurrentTable;
			dlg.m_bIsCurrentDetailTemplate = m_bIsCurrentDetailTemplate;
			for (int i=0; i < m_apCurrentTableDetails.GetSize(); i++) {
				dlg.m_apCurrentTableDetails.Add( m_apCurrentTableDetails[i] );
			}
			// (c.haag 2008-01-22 10:03) - PLID 28686 - If the user wants to add a new item
			// on the fly, have the dialog "press the button for the user"
			if (eEmrItemEntryDlgBehavior_AddNewDropdownColumnSelection == m_Behavior) {
				dlg.m_bAutoAddNew = TRUE;
			}

			long nIndex = GetCurDataElementArrayIndex(nSortOrder,TRUE);
			CEmrInfoDataElement *peide = m_aryCurColumnDataElements.GetAt(nIndex);

			dlg.m_arypEMRDropDownList.AppendCopy(peide->m_arypEMRDropDownList);
			dlg.m_arypEMRDropDownDeleted.AppendCopy(peide->m_arypEMRDropDownDeleted);
			// (c.haag 2010-02-24 09:27) - PLID 37488 - Assign the AutoAlphabetizeDropDown flag
			dlg.m_bAutoAlphabetizeDropDown = peide->m_bAutoAlphabetizeDropDown;
			// (z.manning 2011-03-17 09:18) - PLID 42722 - We need to tell it the column type.
			dlg.m_nColumnType = peide->m_nListType;
			// (z.manning 2011-09-19 14:01) - PLID 41954 - Dropdown separators
			dlg.m_strDropdownSeparator = peide->m_strDropdownSeparator;
			dlg.m_strDropdownSeparatorFinal = peide->m_strDropdownSeparatorFinal;

			// (j.gruber 2014-08-05 11:03) - PLID 63164 - When you have the keyword checkbox checked for a drop down, default all new drop down items in that list to have a checked keyword.   Same for unchecked.
			dlg.m_bDefaultKeyword = peide->m_bUseKeyword;

			if(IDOK == dlg.DoModal() && bAllowEdit) {
				peide->m_arypEMRDropDownList.clear();
				peide->m_arypEMRDropDownDeleted.clear();
				peide->m_arypEMRDropDownList.AppendCopy(dlg.m_arypEMRDropDownList);
				peide->m_arypEMRDropDownDeleted.AppendCopy(dlg.m_arypEMRDropDownDeleted);
				// (c.haag 2010-02-24 12:45) - PLID 37488 - Save the AutoAlphabetizeDropDown flag
				peide->m_bAutoAlphabetizeDropDown = dlg.m_bAutoAlphabetizeDropDown;
				// (z.manning 2011-09-19 14:02) - PLID 41954 - Dropdown separators
				peide->m_strDropdownSeparator = dlg.m_strDropdownSeparator;
				peide->m_strDropdownSeparatorFinal = dlg.m_strDropdownSeparatorFinal;
			}
		}

	}NxCatchAll("Error editing dropdown data.");	
}

void CEmrItemEntryDlg::OnBtnEditEmrDataCodes()
{
	// (a.walling 2009-05-28 15:47) - PLID 34389
	try {
		long nCurrentID = -1;
		{
			NXDATALIST2Lib::IRowSettingsPtr pRow = m_dlEmrDataCode->GetCurSel();

			if (pRow) {
				nCurrentID = VarLong(pRow->GetValue(lcID), -1);
			}
		}

		// (j.armen 2012-06-06 15:51) - PLID 49856 - Refactored CEditComboBox
		CEditComboBox(this, 69, "Edit Combo Box").DoModal();

		m_dlEmrDataCode->Requery();
		{
			NXDATALIST2Lib::IRowSettingsPtr pRow = m_dlEmrDataCode->GetNewRow();

			pRow->PutValue(lcID, (long)-1);
			pRow->PutValue(lcCode, " <None>");
			pRow->PutValue(lcDescription, g_cvarNull);
			pRow->PutValue(lcDefaultUnit, g_cvarNull);
			pRow->PutValue(lcVital, g_cvarNull);

			m_dlEmrDataCode->AddRowSorted(pRow, NULL);
		}

		m_dlEmrDataCode->WaitForRequery(NXDATALIST2Lib::dlPatienceLevelWaitIndefinitely);
		m_dlEmrDataCode->SetSelByColumn(lcID, nCurrentID);
		NXDATALIST2Lib::IRowSettingsPtr pCurrentDataCodeRow = m_dlEmrDataCode->GetCurSel();
		if (pCurrentDataCodeRow == NULL) {
			_RecordsetPtr prsDataCode = CreateParamRecordset("SELECT * FROM EmrDataCodesT WHERE ID = {INT}", m_nEmrDataCodeID);
			if (!prsDataCode->eof) { 
				pCurrentDataCodeRow = m_dlEmrDataCode->GetNewRow();

				pCurrentDataCodeRow->PutValue(lcID, nCurrentID);
				pCurrentDataCodeRow->PutValue(lcCode, prsDataCode->Fields->Item["Code"]->Value);
				pCurrentDataCodeRow->PutValue(lcDescription, prsDataCode->Fields->Item["Description"]->Value);
				pCurrentDataCodeRow->PutValue(lcDefaultUnit, prsDataCode->Fields->Item["DefaultUnit"]->Value);
				pCurrentDataCodeRow->PutValue(lcVital, prsDataCode->Fields->Item["Vital"]->Value);

				m_dlEmrDataCode->PutCurSel(m_dlEmrDataCode->AddRowSorted(pCurrentDataCodeRow, NULL));
			}
		}

	} NxCatchAll("Error editing EMR data codes")
}

void CEmrItemEntryDlg::OnKillfocusDataLongform() 
{
	
		
}

void CEmrItemEntryDlg::OnChangeDataLongform() 
{
	//TES 3/14/2011 - PLID 42784 - Converted to datalist2
	NXDATALIST2Lib::IRowSettingsPtr pCurSel = m_pdlDataElementList->CurSel;
	if(pCurSel) {
		long nIndex = GetCurDataElementArrayIndex(VarLong(pCurSel->GetValue(delcSortOrder)), FALSE);
		// Update the array in memory
		CString strNewLongForm;
		GetDlgItemText(IDC_DATA_LONGFORM, strNewLongForm);
		m_aryCurDataElements.GetAt(nIndex)->m_strLongForm = strNewLongForm;
	}
	
}

void CEmrItemEntryDlg::OnInsertEmrDataField() 
{
	try
	{
		CMenu mnu;
		mnu.CreatePopupMenu();

		mnu.AppendMenu(MF_ENABLED|MF_STRING|MF_BYPOSITION, 1, DATA_FIELD);
		mnu.AppendMenu(MF_ENABLED|MF_STRING|MF_BYPOSITION, 2, AGE_FIELD);
		mnu.AppendMenu(MF_ENABLED|MF_STRING|MF_BYPOSITION, 3, GENDER_UPPER_FIELD);
		mnu.AppendMenu(MF_ENABLED|MF_STRING|MF_BYPOSITION, 4, GENDER_LOWER_FIELD);
		mnu.AppendMenu(MF_ENABLED|MF_STRING|MF_BYPOSITION, 5, SUBJ_UPPER_FIELD);
		mnu.AppendMenu(MF_ENABLED|MF_STRING|MF_BYPOSITION, 6, SUBJ_LOWER_FIELD);
		mnu.AppendMenu(MF_ENABLED|MF_STRING|MF_BYPOSITION, 7, OBJ_UPPER_FIELD);
		mnu.AppendMenu(MF_ENABLED|MF_STRING|MF_BYPOSITION, 8, OBJ_LOWER_FIELD);
		mnu.AppendMenu(MF_ENABLED|MF_STRING|MF_BYPOSITION, 9, POSS_UPPER_FIELD);
		mnu.AppendMenu(MF_ENABLED|MF_STRING|MF_BYPOSITION, 10, POSS_LOWER_FIELD);
		mnu.AppendMenu(MF_ENABLED|MF_STRING|MF_BYPOSITION, 11, SPAWNING_FIELD);
		// (z.manning 2011-11-03 15:17) - PLID 42765 - Added field for spawned item
		mnu.AppendMenu(MF_ENABLED|MF_STRING|MF_BYPOSITION, 12, SPAWNED_ITEMS_FIELD);

		CRect rButton;
		GetDlgItem(IDC_INSERT_EMR_DATA_FIELD)->GetWindowRect(rButton);
		int nSelection = mnu.TrackPopupMenu(TPM_LEFTALIGN|TPM_RETURNCMD|TPM_TOPALIGN, rButton.right, rButton.top, this);

		switch(nSelection) {
		case 1:
			((CNxEdit*)GetDlgItem(IDC_DATA_LONGFORM))->ReplaceSel(DATA_FIELD);
			break;
		case 2:
			((CNxEdit*)GetDlgItem(IDC_DATA_LONGFORM))->ReplaceSel(AGE_FIELD);
			break;
		case 3:
			((CNxEdit*)GetDlgItem(IDC_DATA_LONGFORM))->ReplaceSel(GENDER_UPPER_FIELD);
			break;
		case 4:
			((CNxEdit*)GetDlgItem(IDC_DATA_LONGFORM))->ReplaceSel(GENDER_LOWER_FIELD);
			break;
		case 5:
			((CNxEdit*)GetDlgItem(IDC_DATA_LONGFORM))->ReplaceSel(SUBJ_UPPER_FIELD);
			break;
		case 6:
			((CNxEdit*)GetDlgItem(IDC_DATA_LONGFORM))->ReplaceSel(SUBJ_LOWER_FIELD);
			break;
		case 7:
			((CNxEdit*)GetDlgItem(IDC_DATA_LONGFORM))->ReplaceSel(OBJ_UPPER_FIELD);
			break;
		case 8:
			((CNxEdit*)GetDlgItem(IDC_DATA_LONGFORM))->ReplaceSel(OBJ_LOWER_FIELD);
			break;
		case 9:
			((CNxEdit*)GetDlgItem(IDC_DATA_LONGFORM))->ReplaceSel(POSS_UPPER_FIELD);
			break;
		case 10:
			((CNxEdit*)GetDlgItem(IDC_DATA_LONGFORM))->ReplaceSel(POSS_LOWER_FIELD);
			break;
		case 11:
			((CNxEdit*)GetDlgItem(IDC_DATA_LONGFORM))->ReplaceSel(SPAWNING_FIELD);
			break;
		case 12: // (z.manning 2011-11-03 15:18) - PLID 42765 - Spawned items
			((CNxEdit*)GetDlgItem(IDC_DATA_LONGFORM))->ReplaceSel(SPAWNED_ITEMS_FIELD);
			break;
		}
		if(nSelection != 0) {
			GetDlgItem(IDC_DATA_LONGFORM)->SetFocus();
		}
	}
	NxCatchAll(__FUNCTION__);
}

void CEmrItemEntryDlg::ReflectDataType()
{
	UINT nShowText = IsDlgButtonChecked(IDC_RADIO_TEXT_SELECT) ? SW_SHOW : SW_HIDE;
	UINT nShowDataElements  = IsDlgButtonChecked(IDC_RADIO_LIST_SELECT) || IsDlgButtonChecked(IDC_RADIO_LIST_MULTISELECT) || IsDlgButtonChecked(IDC_RADIO_TABLE) ? SW_SHOW : SW_HIDE;
	UINT nShowImage = IsDlgButtonChecked(IDC_RADIO_IMAGE) ? SW_SHOW : SW_HIDE;
	UINT nShowSlider = IsDlgButtonChecked(IDC_RADIO_SLIDER) ? SW_SHOW : SW_HIDE;
	UINT nShowTable = IsDlgButtonChecked(IDC_RADIO_TABLE) ? SW_SHOW : SW_HIDE;
	UINT nShowNarrative = IsDlgButtonChecked(IDC_RADIO_NARRATIVE) ? SW_SHOW : SW_HIDE;
	UINT nShowIfNotSmartStampTable = (!m_bIsSmartStampTable && IsDlgButtonChecked(IDC_RADIO_TABLE)) ? SW_SHOW : SW_HIDE;

	//TES 6/27/2012 - PLID 51241 - Remember the selected type
	m_nCurrentlySelectedDataType = CalcDataTypeByCurSelection();

	
	GetDlgItem(IDC_DATA_LABEL)->ShowWindow(nShowDataElements & !nShowTable);
	GetDlgItem(IDC_ADD_DATA_ITEM)->ShowWindow(nShowDataElements);
	GetDlgItem(IDC_ADD_MULTIPLE_DATA_ITEM)->ShowWindow(nShowDataElements);
	GetDlgItem(IDC_ADD_OTHER_DATA_ITEM)->ShowWindow(nShowDataElements);
	GetDlgItem(IDC_DELETE_DATA_ITEM)->ShowWindow(nShowDataElements);
	GetDlgItem(IDC_EMR_DATA_LIST)->ShowWindow(nShowDataElements);
	// (d.thompson 2012-10-16) - PLID 53184 - Hide/show the paste button appropriately.  Always hide it on allergies/medications tables
	GetDlgItem(IDC_PASTE_SETUP_DATA)->ShowWindow(nShowDataElements && !IsSystemCurrentMedicationsItem() && !IsSystemAllergiesItem());
	GetDlgItem(IDC_DATA_UP)->ShowWindow(nShowDataElements);
	GetDlgItem(IDC_DATA_DOWN)->ShowWindow(nShowDataElements);
	GetDlgItem(IDC_SHOW_INACTIVE_ELEMENTS)->ShowWindow(nShowDataElements);
	//TES 2/18/2010 - PLID 37234 - Hide all the sentence options if we're using the special Smart Stamps format.
	GetDlgItem(IDC_DATA_FORMAT_LABEL)->ShowWindow(nShowDataElements);
	GetDlgItem(IDC_DATA_FORMAT_TEXT)->ShowWindow(nShowDataElements);
	GetDlgItem(IDC_DATA_FORMAT_SEPARATOR_LABEL)->ShowWindow(nShowDataElements);
	GetDlgItem(IDC_DATA_FORMAT_SEPARATOR)->ShowWindow(nShowDataElements);
	GetDlgItem(IDC_DATA_FORMAT_SEPARATOR_FINAL_LABEL)->ShowWindow(nShowDataElements);
	GetDlgItem(IDC_DATA_FORMAT_SEPARATOR_FINAL)->ShowWindow(nShowDataElements);
	GetDlgItem(IDC_DATA_FORMAT_BULLET)->ShowWindow(nShowDataElements);
	GetDlgItem(IDC_DATA_FORMAT_NUMBER)->ShowWindow(nShowDataElements);
	GetDlgItem(IDC_DATA_FORMAT_LIST)->ShowWindow(nShowDataElements);
	GetDlgItem(IDC_DATA_LONGFORM)->ShowWindow(nShowDataElements && !nShowTable);
	GetDlgItem(IDC_DATA_LONGFORM_LABEL)->ShowWindow(nShowDataElements && !nShowTable);
	GetDlgItem(IDC_INSERT_EMR_DATA_FIELD)->ShowWindow(nShowDataElements && !nShowTable);
	GetDlgItem(IDC_AUTO_ALPHABETIZE_LIST_DATA)->ShowWindow(nShowDataElements);
	// (r.gonet 08/03/2012) - PLID 51735 - Show the Use With Wound Care checkbox only for tables.
	GetDlgItem(IDC_USE_WITH_WOUND_CARE_CALC)->ShowWindow(nShowTable);

	if(nShowTable) {
		GetDlgItem(IDC_DATA_FORMAT_NUMBER)->SetWindowText("Table");
		if(m_nDataType != 7) {
			//if we just selected the table type, then default the merge type to "Table"
			CheckDlgButton(IDC_DATA_FORMAT_TEXT,FALSE);
			CheckDlgButton(IDC_DATA_FORMAT_BULLET,FALSE);
			CheckDlgButton(IDC_DATA_FORMAT_NUMBER,TRUE);
			CheckDlgButton(IDC_DATA_FORMAT_LIST, FALSE);
			OnDataFormatSelected();
		}

		//TES 6/27/2012 - PLID 51241 - If we just changed to table, then we need to clear out any Glasses Order data we may have in 
		// memory.
		for(int i = 0; i < m_aryCurDataElements.GetSize(); i++) {
			m_aryCurDataElements[i]->m_GlassesOrderDataType = godtInvalid;
			m_aryCurDataElements[i]->m_nGlassesOrderDataID = -1;
		}
		for(i = 0; i < m_aryCurColumnDataElements.GetSize(); i++) {
			m_aryCurColumnDataElements[i]->m_GlassesOrderDataType = godtInvalid;
			m_aryCurColumnDataElements[i]->m_nGlassesOrderDataID = -1;
		}

		// (r.gonet 08/03/2012) - PLID 51735 - Clear out the Wound Care Column Type
		for(int i = 0; i < m_aryCurDataElements.GetSize(); i++) {
			// (r.gonet 08/03/2012) - PLID 51735 - This is row data, we shouldn't have anything here anyway.
			m_aryCurDataElements[i]->m_ewccWoundCareDataType = wcdtNone;
		}
		for(i = 0; i < m_aryCurColumnDataElements.GetSize(); i++) {
			m_aryCurColumnDataElements[i]->m_ewccWoundCareDataType = wcdtNone;
		}
	}
	else {
		GetDlgItem(IDC_DATA_FORMAT_NUMBER)->SetWindowText("Numbered List");
	}

	CRect rc;
	GetDlgItem(IDC_DATA_FORMAT_NUMBER)->GetWindowRect(&rc);
	ScreenToClient(rc);
	InvalidateRect(rc, FALSE);

	// (z.manning 2010-02-10 11:41) - PLID 37228 - No rows for smart stamp tables
	// (j.jones 2010-02-25 11:02) - PLID 37538 - we decided that rows are allowed
	GetDlgItem(IDC_ROW_LABEL)->ShowWindow(nShowTable);
	GetDlgItem(IDC_COLUMN_LABEL)->ShowWindow(nShowTable);
	GetDlgItem(IDC_EMR_COLUMN_LIST)->ShowWindow(nShowTable);
	// (d.thompson 2012-10-16) - PLID 53184 - Hide the paste button for columns appropriately.  Always hide it on allergies/medications items
	GetDlgItem(IDC_PASTE_SETUP_DATA_COLUMNS)->ShowWindow(nShowTable && !IsSystemCurrentMedicationsItem() && !IsSystemAllergiesItem());
	GetDlgItem(IDC_COLUMN_DATA_UP)->ShowWindow(nShowTable);
	GetDlgItem(IDC_COLUMN_DATA_DOWN)->ShowWindow(nShowTable);
	GetDlgItem(IDC_BTN_PREVIEW_TABLE)->ShowWindow(nShowIfNotSmartStampTable);
	// (j.gruber 2013-09-27 13:58) - PLID 58676
	GetDlgItem(IDC_BTN_EDIT_TABLE_CELL_CODES)->ShowWindow(nShowIfNotSmartStampTable);
	GetDlgItem(IDC_BTN_EDIT_TABLE_DROPDOWN_DATA)->ShowWindow(nShowTable);
	GetDlgItem(IDC_BTN_EDIT_TABLE_CALCULATED_FIELD)->ShowWindow(nShowTable);	
	GetDlgItem(IDC_TABLE_ROWS_AS_FIELDS)->ShowWindow(nShowTable); // (c.haag 2008-10-23 16:28) - PLID 31708
	GetDlgItem(IDC_BTN_EDIT_TABLE_AUTOFILL)->ShowWindow(nShowTable); // (z.manning 2011-03-18 14:48) - PLID 43662

	GetDlgItem(IDC_NARRATIVE_DEFAULT_TEXT)->ShowWindow(nShowNarrative);	

	//resize the data list accordingly
	// (z.manning 2010-02-10 14:13) - PLID 37228 - Don't show rows on smart stamp tables
	// (j.jones 2010-02-25 11:02) - PLID 37538 - we decided that rows are allowed
	if(nShowDataElements) {

		CRect rcRowList, rcColumnList;
		GetDlgItem(IDC_EMR_DATA_LIST)->GetWindowRect(&rcRowList);
		ScreenToClient(rcRowList);
		GetDlgItem(IDC_EMR_COLUMN_LIST)->GetWindowRect(&rcColumnList);
		ScreenToClient(rcColumnList);

		CRect rcDataUp, rcDataDown;
		GetDlgItem(IDC_DATA_UP)->GetWindowRect(&rcDataUp);
		ScreenToClient(rcDataUp);
		GetDlgItem(IDC_DATA_DOWN)->GetWindowRect(&rcDataDown);
		ScreenToClient(rcDataDown);

		long nBtnHeight = rcDataUp.Height();

		if(nShowTable) {
			//if not a tab, enlarge the size of the normal data list
			rcRowList.bottom = rcRowList.top + rcColumnList.Height();
			GetDlgItem(IDC_EMR_DATA_LIST)->MoveWindow(rcRowList.left, rcRowList.top, rcRowList.Width(), rcRowList.Height(), TRUE);

			//and center the buttons
			rcDataUp.top = rcRowList.top + (rcRowList.Height() / 2 - 3 - nBtnHeight);
			rcDataUp.bottom = rcDataUp.top + nBtnHeight;

			rcDataDown.top = rcDataUp.bottom + 6;
			rcDataDown.bottom = rcDataDown.top + nBtnHeight;

			GetDlgItem(IDC_DATA_UP)->MoveWindow(rcDataUp.left, rcDataUp.top, rcDataUp.Width(), rcDataUp.Height(), TRUE);
			GetDlgItem(IDC_DATA_DOWN)->MoveWindow(rcDataDown.left, rcDataDown.top, rcDataDown.Width(), rcDataDown.Height(), TRUE);
		}
		else {
			//if not a tab, enlarge the size of the normal data list
			CRect rcDataLongForm;
			GetDlgItem(IDC_DATA_LONGFORM_LABEL)->GetWindowRect(&rcDataLongForm);
			ScreenToClient(rcDataLongForm);
			rcRowList.bottom = rcDataLongForm.top-5;
			GetDlgItem(IDC_EMR_DATA_LIST)->MoveWindow(rcRowList.left, rcRowList.top, rcRowList.Width(), rcRowList.Height(), TRUE);

			//and center the buttons
			rcDataUp.top = rcRowList.top + ((rcDataLongForm.top-5 - rcRowList.top) / 2 - 3 - nBtnHeight);
			rcDataUp.bottom = rcDataUp.top + nBtnHeight;

			rcDataDown.top = rcDataUp.bottom + 6;
			rcDataDown.bottom = rcDataDown.top + nBtnHeight;

			GetDlgItem(IDC_DATA_UP)->MoveWindow(rcDataUp.left, rcDataUp.top, rcDataUp.Width(), rcDataUp.Height(), TRUE);
			GetDlgItem(IDC_DATA_DOWN)->MoveWindow(rcDataDown.left, rcDataDown.top, rcDataDown.Width(), rcDataDown.Height(), TRUE);

			//TES 6/27/2012 - PLID 51241 - If we just changed to a list from a non-list, clear out any Glasses Order data in memory
			for(int i = 0; i < m_aryCurDataElements.GetSize(); i++) {
				m_aryCurDataElements[i]->m_GlassesOrderDataType = godtInvalid;
				m_aryCurDataElements[i]->m_nGlassesOrderDataID = -1;
				// (r.gonet 08/03/2012) - PLID 51735 - Also the wound care type
				m_aryCurDataElements[i]->m_ewccWoundCareDataType = wcdtNone;
			}
		}

		InvalidateRect(rcRowList);
		InvalidateRect(rcDataUp);
		InvalidateRect(rcDataDown);
	}
	else if(nShowTable) {
		// (z.manning 2010-02-10 12:31) - PLID 37228 - This is
		GetDlgItem(IDC_EMR_DATA_LIST)->ShowWindow(SW_HIDE);
		// (d.thompson 2012-10-16) - PLID 53184 - Hide/show the paste button appropriately
		//	Note:  At present, this code is uncallable and I don't quite understand it, but my button
		//	always follows the up/down arrows, so I copied it here.
		GetDlgItem(IDC_PASTE_SETUP_DATA)->ShowWindow(SW_HIDE);
		GetDlgItem(IDC_DATA_UP)->ShowWindow(SW_HIDE);
		GetDlgItem(IDC_DATA_DOWN)->ShowWindow(SW_HIDE);
	}

	if(nShowTable) {
		//correct the regular datalist columns
		m_pdlDataElementList->GetColumn(delcDefault)->PutStoredWidth(0);
		m_pdlDataElementList->GetColumn(delcAction)->PutStoredWidth(0);
		// (z.manning 2010-04-13 10:03) - PLID 29301 - We now support labels on tables
		if(IsSystemAllergiesItem() || IsSystemCurrentMedicationsItem()) {
			m_pdlDataElementList->GetColumn(delcIsLabel)->PutStoredWidth(0);
		}
		else {
			m_pdlDataElementList->GetColumn(delcIsLabel)->PutStoredWidth(50);
		}
		// (j.gruber 2010-04-27 09:20) - PLID 38336 - hide the BOLD Code column on Tables
		m_pdlDataElementList->GetColumn(delcBOLDCode)->PutStoredWidth(0);
		// (j.jones 2012-09-18 16:33) - PLID 52316 - ParentLabelID is not available on tables
		m_pdlDataElementList->GetColumn(delcParentLabelID)->PutStoredWidth(0);
		m_pdlDataElementList->GetColumn(delcParentLabelID)->PutColumnStyle(csVisible|csFixedWidth);
		// (j.gruber 2013-10-02 12:14) - PLID 58674
		// (j.gruber 2013-10-21 09:11) - PLID 59101 - we have codes for rows now
		m_pdlDataElementList->GetColumn(delcCodes)->PutStoredWidth(100);
		// (j.gruber 2014-07-17 14:21) - PLID 62621 - Keyword columns
		m_pdlDataElementList->GetColumn(delcUseKeyWord)->PutStoredWidth(60);
	}
	else {
		m_pdlDataElementList->GetColumn(delcDefault)->PutStoredWidth(55);
		m_pdlDataElementList->GetColumn(delcAction)->PutStoredWidth(100);
		m_pdlDataElementList->GetColumn(delcIsLabel)->PutStoredWidth(50);
		// (j.gruber 2010-04-27 09:21) - PLID 38336 - show the BOLD code
		// (j.gruber 2010-06-04 14:54) - PLID 38935 - hide the BOLD column if they aren't licensed
		if(!g_pLicense || !g_pLicense->CheckForLicense(CLicense::lcBold, CLicense::cflrSilent)) {
			m_pdlDataElementList->GetColumn(delcBOLDCode)->PutStoredWidth(0);			
		}
		else {
			m_pdlDataElementList->GetColumn(delcBOLDCode)->PutStoredWidth(75);
			//TES 3/14/2011 - PLID 42784 - Converted to datalist2
			m_pdlDataElementList->GetColumn(delcBOLDCode)->PutColumnStyle(NXDATALIST2Lib::csVisible|NXDATALIST2Lib::csEditable);		
		}
		// (j.jones 2012-09-18 16:33) - PLID 52316 - show the ParentLabelID column
		m_pdlDataElementList->GetColumn(delcParentLabelID)->PutStoredWidth(75);
		m_pdlDataElementList->GetColumn(delcParentLabelID)->PutColumnStyle(csVisible|csEditable);
		// (j.gruber 2013-10-02 12:14) - PLID 58674
		m_pdlDataElementList->GetColumn(delcCodes)->PutStoredWidth(100);
		// (j.gruber 2014-07-17 14:21) - PLID 62621 - Keyword columns
		m_pdlDataElementList->GetColumn(delcUseKeyWord)->PutStoredWidth(60);
	}

	UINT nShow3D = (nShowImage == SW_SHOW && IsDlgButtonChecked(IDC_USE_SELECTED_3DIMAGE) ? SW_SHOW : SW_HIDE);
	GetDlgItem(IDC_USE_SELECTED_IMAGE)->ShowWindow(nShowImage);
	GetDlgItem(IDC_USE_SELECTED_3DIMAGE)->ShowWindow(nShowImage);
	GetDlgItem(IDC_PROMPT_FOR_IMAGE)->ShowWindow(nShowImage);
	GetDlgItem(IDC_EMR_IMAGE_FRAME)->ShowWindow(nShowImage == SW_SHOW && IsDlgButtonChecked(IDC_PROMPT_FOR_IMAGE) ? SW_SHOW : SW_HIDE);
	GetDlgItem(IDC_EMR_IMAGE)->ShowWindow(nShowImage == SW_SHOW && IsDlgButtonChecked(IDC_USE_SELECTED_IMAGE) ? SW_SHOW : SW_HIDE);
	GetDlgItem(IDC_EMR_ITEM_ENTRY_3DIMAGE)->ShowWindow(nShow3D);
	//DRT 1/17/2008 - PLID 28602 - Show the 'Modify HotSpots' button
	//DRT 3/18/2008 - PLID 28906 - Hiding for now.  You should be able to uncomment this 1 line when ready.
	//DRT 3/27/2008 - plid 29431 - And they're back.
	GetDlgItem(IDC_MODIFY_HOTSPOTS)->ShowWindow((nShowImage == SW_SHOW && IsDlgButtonChecked(IDC_USE_SELECTED_IMAGE)) ? SW_SHOW : SW_HIDE);
	// (z.manning 2010-02-09 12:53) - PLID 37228 - Smart stamp controls
	GetDlgItem(IDC_ENABLE_SMART_STAMPS)->ShowWindow(nShowImage);
	GetDlgItem(IDC_EDIT_SMART_STAMP_TABLE)->ShowWindow(nShowImage);
	GetDlgItem(IDC_NEW_SMART_STAMP_TABLE)->ShowWindow(nShowImage);
	GetDlgItem(IDC_SMART_STAMP_TABLE_COMBO)->ShowWindow(nShowImage);
	GetDlgItem(IDC_EMR_ITEM_SELECT_STAMPS)->ShowWindow(nShowImage); // (z.manning 2011-10-24 12:39) - PLID 46082
	OnEnableSmartStamps();


	GetDlgItem(IDC_DEFAULT_TEXT)->ShowWindow(nShowText);
	GetDlgItem(IDC_DEFAULT_TEXT_CAPTION)->ShowWindow(nShowText);

	GetDlgItem(IDC_EMR_SLIDER)->ShowWindow(nShowSlider);
	GetDlgItem(IDC_EMR_MINIMUM)->ShowWindow(nShowSlider);
	GetDlgItem(IDC_EMR_MIN_LABEL)->ShowWindow(nShowSlider);
	GetDlgItem(IDC_EMR_INCREMENT)->ShowWindow(nShowSlider);
	GetDlgItem(IDC_EMR_INC_LABEL)->ShowWindow(nShowSlider);
	GetDlgItem(IDC_EMR_MAXIMUM)->ShowWindow(nShowSlider);
	GetDlgItem(IDC_EMR_MAX_LABEL)->ShowWindow(nShowSlider);

	// Size the sentence field to take up the appropriate amount of space, depending on whether 
	// the dataelement-related stuff is there.
	{
		CRect rSeparator;
		GetDlgItem(IDC_DATA_FORMAT_SEPARATOR)->GetWindowRect(rSeparator);
		CRect rSentence;
		GetDlgItem(IDC_SENTENCE)->GetWindowRect(rSentence);
		rSentence.bottom = (nShowDataElements == SW_SHOW) ? (rSeparator.top-5) : rSeparator.bottom;
		ScreenToClient(rSentence);
		GetDlgItem(IDC_SENTENCE)->MoveWindow(rSentence);
	}

	//TES 12/23/2004 - If they selected "single-select list", then make sure there aren't multiple defaults.
	//DRT 6/30/2005 - PLID 16761 - Fixed both of the VarBool calls below to have a default value of false.  If one of your rows
	//	is a label, the "default" column is changed from a checkbox to just NULL.
	if(IsDlgButtonChecked(IDC_RADIO_LIST_SELECT)) {
		int nDefaultCount = 0;
		//TES 3/14/2011 - PLID 42784 - Converted to datalist2
		NXDATALIST2Lib::IRowSettingsPtr pRow = m_pdlDataElementList->GetFirstRow();
		while(pRow) {
			if(VarBool(pRow->GetValue(delcDefault), FALSE)) nDefaultCount++;
			pRow = pRow->GetNextRow();
		}
		if(nDefaultCount > 1) {
			//Leave the first one.
			bool bLeftOne = false;
			//TES 3/14/2011 - PLID 42784 - Converted to datalist2
			NXDATALIST2Lib::IRowSettingsPtr pRow = m_pdlDataElementList->GetFirstRow();
			while(pRow) {
				if(VarBool(pRow->GetValue(delcDefault), FALSE)) {
					if(!bLeftOne) {
						bLeftOne = true;
					}
					else {

						variant_t varTrue;
						varTrue.vt = VT_BOOL;
						varTrue.boolVal = TRUE;

						variant_t varFalse;
						varFalse.vt = VT_BOOL;
						varFalse.boolVal = FALSE;

						pRow->PutValue(delcDefault, varFalse);
						OnEditingFinishedEmrDataList(pRow, delcDefault, varTrue, varFalse, TRUE);
					}
				}
				// (j.jones 2012-10-16 09:25) - PLID 53195 - this previously didn't assign to pRow, causing an infinite loop!
				pRow = pRow->GetNextRow();
			}
		}
	}

	//DRT 7/13/2005 - PLID 16991 - Need to convert any list item types.  If you go from a checkbox list (single or multiple)
	//	to a table, all the rows need their ListType changed from 1 to 2, and vice versa.
	long nNewListType = -1;
	if(IsDlgButtonChecked(IDC_RADIO_TABLE)) {
		//We can't just check the previous type because they may have gone from list -> image -> table.
		nNewListType = 2;
	}
	else if(IsDlgButtonChecked(IDC_RADIO_LIST_SELECT) || IsDlgButtonChecked(IDC_RADIO_LIST_MULTISELECT)) {
		//We can't just check the previous type because they may have gone from table -> image -> list.
		nNewListType = 1;
	}

	if(nNewListType != -1) {
		for(int i = 0; i < m_aryCurDataElements.GetSize(); i++) {
			CEmrInfoDataElement *peide = m_aryCurDataElements.GetAt(i);
			peide->m_nListType = nNewListType;
		}
	}

	// (j.jones 2007-08-14 14:10) - PLID 27053 - will update the E/M Code Type combo appropriately
	ReflectEMCodeInterface();

	//TES 3/11/2011 - PLID 42757 - The Glasses Order checkbox is visible if we have a Glasses Order license, and are on a list or table.
	if(nShowDataElements && g_pLicense->CheckForLicense(CLicense::lcGlassesOrders, CLicense::cflrSilent)) {
		//TES 3/11/2011 - PLID 42757 - The lens dropdown is only an option for lists, not tables.
		if(nShowTable == SW_HIDE) {
			GetDlgItem(IDC_ASSOCIATE_WITH_GLASSES_ORDER)->ShowWindow(SW_SHOW);
			GetDlgItem(IDC_GLASSES_ORDER_LENS)->ShowWindow(SW_SHOW);
			//TES 4/6/2012 - PLID 49367 - Added controls for Contact Lens data
			GetDlgItem(IDC_ASSOCIATE_WITH_GLASSES_ORDER_OR_CL)->ShowWindow(SW_HIDE);
			GetDlgItem(IDC_GO_CL_TOGGLE)->ShowWindow(SW_HIDE);
		}
		else {
			GetDlgItem(IDC_ASSOCIATE_WITH_GLASSES_ORDER)->ShowWindow(SW_HIDE);
			GetDlgItem(IDC_GLASSES_ORDER_LENS)->ShowWindow(SW_HIDE);
			//TES 4/6/2012 - PLID 49367 - Added controls for Contact Lens data
			GetDlgItem(IDC_ASSOCIATE_WITH_GLASSES_ORDER_OR_CL)->ShowWindow(SW_SHOW);
			GetDlgItem(IDC_GO_CL_TOGGLE)->ShowWindow(SW_SHOW);
		}
	}
	else {
		GetDlgItem(IDC_ASSOCIATE_WITH_GLASSES_ORDER)->ShowWindow(SW_HIDE);
		GetDlgItem(IDC_GLASSES_ORDER_LENS)->ShowWindow(SW_HIDE);
		//TES 4/6/2012 - PLID 49367 - Added controls for Contact Lens data
		GetDlgItem(IDC_ASSOCIATE_WITH_GLASSES_ORDER_OR_CL)->ShowWindow(SW_HIDE);
		GetDlgItem(IDC_GO_CL_TOGGLE)->ShowWindow(SW_HIDE);
	}
	ReflectGlassesOrderCheck();

	// (c.haag 2011-03-14) - PLID 42814 - Show the "Configure Common Lists" button if this is a Current Medications or allergy item
	if(eistCurrentMedicationsTable != m_DataSubType && eistAllergiesTable != m_DataSubType) {
		m_btnEditCommonLists.ShowWindow(SW_HIDE);
	} else {
		m_btnEditCommonLists.ShowWindow(SW_SHOW);
	}

	// (z.manning 2011-11-15 16:29) - PLID 46485 - Show the don't spawn remembered values check on any item that can spawn.
	if(nShowImage == SW_SHOW || nShowTable == SW_SHOW || nShowDataElements == SW_SHOW) {
		GetDlgItem(IDC_DONT_SPAWN_WHEN_REMEMBERING)->ShowWindow(SW_SHOW);
	}
	else {
		GetDlgItem(IDC_DONT_SPAWN_WHEN_REMEMBERING)->ShowWindow(SW_HIDE);
	}

	//Show/hide the Current/Admin List.
	// (c.haag 2006-07-05 16:51) - PLID 19862 - This is obselete since we no longer have a current list
	//if((IsDlgButtonChecked(IDC_RADIO_LIST_SELECT) || IsDlgButtonChecked(IDC_RADIO_LIST_MULTISELECT))
	//	&& m_bMaintainCurrentList) 
	//{
	//	GetDlgItem(IDC_SELECT_LIST_TAB)->ShowWindow(SW_SHOW);
	//	GetDlgItem(IDC_CURRENT_ADMIN_LIST_HELP)->ShowWindow(SW_SHOW);
	//}
	//else {
	//	GetDlgItem(IDC_SELECT_LIST_TAB)->ShowWindow(SW_HIDE);
	//	GetDlgItem(IDC_CURRENT_ADMIN_LIST_HELP)->ShowWindow(SW_HIDE);
	//}

	//
	// (c.haag 2006-03-01 16:34) - PLID 19378 - Disable the Current List if we changed the data type.
	// If it's enable, it will misdirect users into thinking they can still change the current list,
	// when in reality, it will be overwritten because the item changed.
	//
	// (c.haag 2006-07-05 16:51) - PLID 19862 - This is obselete since we no longer have a current list
	//if (m_bMaintainCurrentList) {
	//	long nNewSelect = CalcDataTypeByCurSelection();
	//	if (nNewSelect != m_nDataType && (nNewSelect == 2 || nNewSelect == 3) && m_pSelectListTab->GetCurSel() != sltAdminList) {
	//		GetDlgItem(IDC_EMR_DATA_LIST)->EnableWindow(FALSE);
	//	} else {
	//		GetDlgItem(IDC_EMR_DATA_LIST)->EnableWindow(TRUE);
	//	}
	//}
}

BOOL CEmrItemEntryDlg::CanSetOnePerEmn()
{
	return TRUE;
}

void CEmrItemEntryDlg::OnSelectTabSelectList(short nNewTab, short nOldTab)
{
	ReflectDataType();
	ReflectDataElementList(sdeidClearSelection);
}

long CEmrItemEntryDlg::FindInCurrentList(CString strData)
{
	for(long i = 0; i < m_aryCurrentList.GetSize(); i++) {
		if(!strData.CompareNoCase(m_aryCurrentList.GetAt(i).strData)) {
			return i;
		}
	}
	return -1;
}

void CEmrItemEntryDlg::GetCurrentList(CArray<long,long>* naryIDs, CStringArray* straryData, CStringArray* straryLabels, CStringArray* straryLongForms, CArray<long,long>* naryActionsType, CArray<BOOL,BOOL>* baryInactive)
{
	// Get all ID & data of elements in admin list
	ASSERT(m_nID != -1);
	// (j.jones 2012-09-19 12:22) - PLID 52316 - added ParentLabelID, though it is currently unused
	_RecordsetPtr prs = CreateRecordset(
		"IF (SELECT AutoAlphabetizeListData FROM EmrInfoT WHERE ID = %li) = 1 "
		"SELECT ID, Data, IsLabel, ParentLabelID, LongForm, Inactive, "
		"(SELECT Min(CASE WHEN DestType = 3 OR DestType = 9 THEN 1 ELSE 2 END) AS MinActionType FROM EMRActionsT WHERE SourceType = 4 AND SourceID = EmrDataT.ID AND Deleted = 0) AS ActionsType "
		"FROM EMRDataT WHERE ListType = 1 AND EMRInfoID = %li ORDER BY EmrDataT.Data "
		"ELSE "
		"SELECT ID, Data, IsLabel, ParentLabelID, LongForm, Inactive, "
		"(SELECT Min(CASE WHEN DestType = 3 OR DestType = 9 THEN 1 ELSE 2 END) AS MinActionType FROM EMRActionsT WHERE SourceType = 4 AND SourceID = EmrDataT.ID AND Deleted = 0) AS ActionsType "
		"FROM EMRDataT WHERE ListType = 1 AND EMRInfoID = %li ORDER BY EmrDataT.SortOrder", m_nID, m_nID, m_nID);
	CStringArray straryAdminData;
	CStringArray straryAdminLabels;
	CStringArray straryAdminLongForms;
	CArray<long,long> naryAdminIDs;
	CArray<long,long> naryAdminActionsType;
	CArray<BOOL,BOOL> baryAdminInactive;
	FieldsPtr flds = prs->GetFields();
	while(!prs->eof) {
		naryAdminIDs.Add(AdoFldLong(flds, "ID"));
		straryAdminData.Add(AdoFldString(flds, "Data"));
		straryAdminLabels.Add(AdoFldBool(flds, "IsLabel", FALSE) ? "1" : "0");
		straryAdminLongForms.Add(AdoFldString(flds, "LongForm"));
		naryAdminActionsType.Add(AdoFldLong(flds, "ActionsType", -1));
		baryAdminInactive.Add(AdoFldBool(flds, "Inactive", 0));
		prs->MoveNext();
	}
	prs->Close();

	naryIDs->RemoveAll();
	straryData->RemoveAll();
	straryLabels->RemoveAll();
	straryLongForms->RemoveAll();
	naryActionsType->RemoveAll();
	baryInactive->RemoveAll();
	for(long i = 0; i < naryAdminIDs.GetSize(); i++) {
		if(FindInCurrentList(straryAdminData.GetAt(i)) != -1) {
			naryIDs->Add(naryAdminIDs.GetAt(i));
			straryData->Add(straryAdminData.GetAt(i));
			straryLabels->Add(straryAdminLabels.GetAt(i));
			straryLongForms->Add(straryAdminLongForms.GetAt(i));
			naryActionsType->Add(naryAdminActionsType.GetAt(i));
			baryInactive->Add(baryAdminInactive.GetAt(i));
		}
	}
}

CString CEmrItemEntryDlg::GetLabelText()
{
	return m_strName;
}

CString CEmrItemEntryDlg::GetLongForm()
{
	return m_strLongForm;
}

long CEmrItemEntryDlg::GetDataFormat()
{
	return m_nDataFormat;
}

CString CEmrItemEntryDlg::GetDataSeparator()
{
	return m_strDataSeparator;
}

CString CEmrItemEntryDlg::GetDataSeparatorFinal()
{
	return m_strDataSeparatorFinal;
}

int CEmrItemEntryDlg::CalcDataTypeByCurSelection() const
{
	long nSelect = -1;

	if(IsDlgButtonChecked(IDC_RADIO_TEXT_SELECT))
		nSelect = 1;
	else if(IsDlgButtonChecked(IDC_RADIO_LIST_SELECT))
		nSelect = 2;
	else if(IsDlgButtonChecked(IDC_RADIO_LIST_MULTISELECT))
		nSelect = 3;
	else if(IsDlgButtonChecked(IDC_RADIO_IMAGE))
		nSelect = 4;
	else if(IsDlgButtonChecked(IDC_RADIO_SLIDER))
		nSelect = 5;
	else if(IsDlgButtonChecked(IDC_RADIO_NARRATIVE))
		nSelect = 6;
	else if(IsDlgButtonChecked(IDC_RADIO_TABLE))
		nSelect = 7;

	return nSelect;
}

// (c.haag 2006-07-06 09:23) - PLID 19862 - We no longer have the ability to edit
// the "Current List"
//
/*void CEmrItemEntryDlg::OnCurrentAdminListHelp()
{
	CString strHelpText = "When you edit a single-select or multi-select list that exists on an EMN template or on a "
		"patient's EMN, you have the option of editing 2 lists, which are labeled the Admin List and Current List.\r\n\r\n"
		"When you make a change to the Current List, that change only affects this list on the EMN or EMN template "
		"that you are currently working on.\r\n\r\n"
		"When you make a change to the Admin List you are not only "
		"making changes to the list on the current EMN or EMN template, you're also making changes that affect "
		"future uses of this list.  For example, if you make a change to the Current List and then add this item ("
		+ m_strName + ") to another EMN or EMN template at a later time, the changes you make to the Admin List "
		"now will show up when you add this list to another EMN or EMN template.\r\n\r\n"
		"(Note: Actions, label, and sort order will always be the same for the Admin and Current Lists.)";

	m_dlgAdminCurrentListHelp.SetDlgItemText(IDC_HELP_TEXT, strHelpText);
	m_dlgAdminCurrentListHelp.ShowWindow(SW_RESTORE);
	m_dlgAdminCurrentListHelp.CenterWindow();
}*/

void CEmrItemEntryDlg::OnAutoAlphabetizeListData()
{
	// (c.haag 2007-02-06 12:00) - PLID 24423 - Do not auto-alphabetize columns
	// for Current medications items
	// (c.haag 2007-04-03 09:43) - PLID 25468 - Same with allergy items
	if (IsDlgButtonChecked(IDC_AUTO_ALPHABETIZE_LIST_DATA)) {
		// (j.jones 2009-09-21 08:54) - PLID 35605 - ensured we sort by the correct column enum
		m_pdlDataElementList->GetColumn(delcSortOrder)->SortPriority = -1;
		m_pdlDataElementList->GetColumn(delcData)->SortPriority = 0;
		m_pdlDataElementList->GetColumn(delcData)->SortAscending = TRUE;
		if (!IsSystemCurrentMedicationsItem() && !IsSystemAllergiesItem()) {
			m_pdlColumnDataElementList->GetColumn(cdelcSortOrder)->SortPriority = -1;
			m_pdlColumnDataElementList->GetColumn(cdelcData)->SortPriority = 0;
			m_pdlColumnDataElementList->GetColumn(cdelcData)->SortAscending = TRUE;
		}

	}
	else {
		// (j.jones 2009-09-21 08:54) - PLID 35605 - ensured we sort by the correct column enum
		m_pdlDataElementList->GetColumn(delcData)->SortPriority = -1;
		m_pdlDataElementList->GetColumn(delcSortOrder)->SortPriority = 0;
		m_pdlDataElementList->GetColumn(delcSortOrder)->SortAscending = TRUE;
		if (!IsSystemCurrentMedicationsItem() && !IsSystemAllergiesItem()) {
			m_pdlColumnDataElementList->GetColumn(cdelcData)->SortPriority = -1;
			m_pdlColumnDataElementList->GetColumn(cdelcSortOrder)->SortPriority = 0;
			m_pdlColumnDataElementList->GetColumn(cdelcSortOrder)->SortAscending = TRUE;	
		}
	}

	// (z.manning 2010-11-29 12:42) - PLID 39205 - The row and column orders likely changed so we
	// need to update any formulas though before we do so we need to make sure the lists are in
	// the correct order.
	m_pdlDataElementList->Sort();
	m_pdlColumnDataElementList->Sort();
	UpdateFormulaReferences();

	ReflectDataElementSelection();
	ReflectDataElementList(sdeidClearSelection); // refresh	
}

void CEmrItemEntryDlg::OnChangeColumnSortFinishedEmrCategories(short nOldSortCol, BOOL bOldSortAscending, short nNewSortCol, BOOL bNewSortAscending) 
{
	//ensure that the "No Categories" and "Multiple Categories" rows are always on top

	//multi-category row
	long nRowNumberMulti = m_pdlCategoryCombo->FindByColumn(0, (long)clsrvMultiCategory, -1, FALSE);	

	if(nRowNumberMulti != -1) {

		IRowSettingsPtr pRow;
		//get the row for later use
		pRow = m_pdlCategoryCombo->GetRow(nRowNumberMulti);	

		//remove the row
		m_pdlCategoryCombo->RemoveRow(nRowNumberMulti);

		//add the row again at the top of the list
		m_pdlCategoryCombo->InsertRow(pRow, 0);
	}
	else {
		// (j.jones 2006-01-18 14:51) - I can't think of a time when this row would not exist,
		// so ASSERT if it is missing, so we can figure out why
		ASSERT(FALSE);
	}

	//no category row
	long nRowNumberNoCat = m_pdlCategoryCombo->FindByColumn(0, (long)clsrvNoCategory, -1, FALSE);

	if(nRowNumberNoCat != -1) {

		IRowSettingsPtr pRow;
		//get the row for later use
		pRow = m_pdlCategoryCombo->GetRow(nRowNumberNoCat);	

		//remove the row
		m_pdlCategoryCombo->RemoveRow(nRowNumberNoCat);

		//add the row again at the top of the list
		m_pdlCategoryCombo->InsertRow(pRow, 0);
	}
	else {
		// (j.jones 2006-01-18 14:51) - I can't think of a time when this row would not exist,
		// so ASSERT if it is missing, so we can figure out why
		ASSERT(FALSE);
	}
}

void CEmrItemEntryDlg::SetCurrentEMN(CEMN* pEMN)
{
	m_pCurrentEMN = pEMN;
}

void CEmrItemEntryDlg::OnKillfocusEmrIncrement()
{
	CString strSliderInc;
	GetDlgItemText(IDC_EMR_INCREMENT, strSliderInc);
	if(atof(strSliderInc) <= 0.0) {
		SetDlgItemText(IDC_EMR_INCREMENT, "1");
	}
}

//used when we are saving the current item as a new item
BOOL CEmrItemEntryDlg::PrepareToReassignEmrInfoItem(long nOldInfoID, long &nNewInfoID)
{
	// (a.walling 2011-01-27 13:34) - PLID 34813 - Ensured Rollback tran and Return for RAISERROR
	// (c.haag 2013-11-18) - PLID 59551 - Added locking hints so that the process does not lose locks
	// in between queries and result in deadlocks.

	// (c.haag 2010-07-10 12:07) - PLID 39467 - Don't reassign if there are any table dropdowns with
	// duplicate SortOrder values. That is considered bad data and we don't to propogate that.
	if (EmrItemHasTableDropdownsWithDuplicateSortOrders(nOldInfoID)) 
	{
		ThrowNxException("This EMR item has one or more table dropdowns with duplicate Sort Order values. Please contact NexTech support for assistance.");
	}

	long nNewID;
	CString strNewName;
	GetDlgItemText(IDC_ITEM_NAME, strNewName);
	strNewName.TrimRight();
	strNewName.TrimLeft();
	//
	//Now do the deed of copying all this stuff
	BOOL bSaved = FALSE;

	//we will store our new IDs in member arrays, but not apply them to this dialog until the copy is committed
	//all of the info will be stored in m_pChangedIDMap
	ClearChangedIDMap();
	m_pChangedIDMap = new EMRInfoChangedIDMap;
	
	BEGIN_TRANS("PrepareToReassignEmrInfoItem")
		
		/* PHASE 1: EMRInfoT-level and hotspot information

		In the following block of code, we generate a new EMR Info ID, and copy records from the following tables:

		1. EmrInfoT
		2. EmrImageHotSpotsT
		3. EmrActionsT for hotspots
		4. EmrProblemActionsT for hotspots
		5. EmrActionChargeDataT for hotspots
		6. EmrActionsTodoDataT for hotspots
		7. EmrActionsTodoAssignToT for hotspots

		Returned records:

		1. New EMRImageHotSpotsT
		2. New EmrActionsT for hotspots

		*/

		//TES 12/5/2006 - PLID 23724 - Copy the EmrInfoMasterID instead of setting the CopiedFromInfoID
		// (c.haag 2007-01-30 09:15) - PLID 24423 - Include DataSubType
		//DRT 1/24/2008 - PLID 28602 - Additionally copied actions.  To properly handle the error states like the other queries, I 
		//	changed this to a parameterized recordset.
		// (a.walling 2008-06-30 14:52) - PLID 30570 - Included PreviewFlags
		// (j.jones 2008-09-22 13:08) - PLID 31476 - added RememberForEMR
		// (c.haag 2008-10-16 09:56) - PLID 31708 - Added TableRowsAsFields
		// (a.walling 2009-05-28 15:22) - PLID 34389 - Added DataCodeID, DataUnit
		// (z.manning 2010-02-09 15:12) - PLID 37228 - Added SmartStampsEnabled and ChildEmrInfoMasterID
		//TES 2/18/2010 - PLID 37234 - Added UseSmartStampsLongForm and SmartStampsLongForm
		// (z.manning 2010-07-26 14:44) - PLID 39848 - Removed UseSmartStampsLongForm and SmartStampsLongForm
		//TES 10/28/2010 - PLID 41174 - Special logging
		//TES 3/15/2011 - PLID 42757 - Added HasGlassesOrderData, GlassesOrderLens
		// (c.haag 2011-03-15) - PLID 42821 - Removed needless copying of the query so my modifications would not have
		// to be done twice if I make any.
		// (z.manning 2011-11-15 16:34) - PLID 46485 - Added InfoFlags
		//TES 4/6/2012 - PLID 49367 - Added HasContactLensData
		// (r.gonet 08/03/2012) - PLID 51735 - Added UseWithWoundCareCoding
		// (j.armen 2014-01-29 12:06) - PLID 60523 - Idenitate EMRInfoT
		CSqlFragment strprsMain = CSqlFragment(
			"SET NOCOUNT ON;\r\n"

			"INSERT INTO EMRInfoT "
			"(Name, DataType, DataSubType, LongForm, BackgroundImageFilePath, BackgroundImageType, DefaultPenColor, "
			"DataFormat, DataSeparator, DefaultText, RememberForPatient, RememberForEMR, SliderMin, SliderMax, SliderInc, "
			"DataSeparatorFinal, OnePerEmn, AutoAlphabetizeListData, DisableTableBorder, PreviewFlags, EmrInfoMasterID, TableRowsAsFields, "
			"DataCodeID, DataUnit, SmartStampsEnabled, ChildEmrInfoMasterID, HasGlassesOrderData, GlassesOrderLens, InfoFlags, HasContactLensData, "
			"UseWithWoundCareCoding) "

			"SELECT {STRING}, DataType, DataSubType, LongForm, BackgroundImageFilePath, BackgroundImageType, DefaultPenColor, "
			"DataFormat, DataSeparator, DefaultText, RememberForPatient, RememberForEMR, SliderMin, SliderMax, SliderInc, "
			"DataSeparatorFinal, OnePerEmn, AutoAlphabetizeListData, DisableTableBorder, PreviewFlags, EmrInfoMasterID, TableRowsAsFields, "
			"DataCodeID, DataUnit, SmartStampsEnabled, ChildEmrInfoMasterID, HasGlassesOrderData, GlassesOrderLens, InfoFlags, HasContactLensData, "
			"UseWithWoundCareCoding "
			"FROM EMRInfoT "
			"WHERE ID = {INT};\r\n"

			"DECLARE @EMRInfoID INT\r\n"
			"SET @EMRInfoID = SCOPE_IDENTITY()\r\n"

			"DECLARE @nError INT \r\n"
			//DRT 1/22/2008 - PLID 28602 - We need to also copy hotspots.  Since these are content (per info item), we can do it here along
			//	with other content, like the image background.
			//Maintain group IDs so we know where copies come from
			//TES 2/9/2010 - PLID 37223 - Added Anatomic Location information to hotspots
			// (z.manning 2011-07-22 16:21) - PLID 44676 - Added ImageHotSpotID
			"DECLARE @HotSpotTempT TABLE (RowNum int identity NOT NULL PRIMARY KEY, Data ntext, AnatomicLocationID INT, AnatomicQualifierID INT, AnatomySide INT NOT NULL, ImageHotSpotID int, EmrSpotGroupID int NOT NULL, NewID int NULL, OldID int NOT NULL); \r\n"
			"INSERT INTO @HotSpotTempT (Data, AnatomicLocationID, AnatomicQualifierID, AnatomySide, ImageHotSpotID, EmrSpotGroupID, OldID) SELECT Data, AnatomicLocationID, AnatomicQualifierID, AnatomySide, ImageHotSpotID, EmrSpotGroupID, ID FROM EMRImageHotSpotsT "
			"  WHERE EMRInfoID = {INT}; \r\n"
			"SET @nError = @@ERROR IF @nError <> 0 BEGIN RAISERROR('@@ERROR was %li!', 16, 1, @nError) ROLLBACK TRAN RETURN END\r\n"
			"DECLARE @HotSpotBase INT; \r\n"
			"SET @HotSpotBase = (SELECT COALESCE(MAX(ID), 0) FROM EMRImageHotSpotsT WITH(UPDLOCK, HOLDLOCK));\r\n"
			"UPDATE @HotSpotTempT SET NewID = RowNum + @HotSpotBase;\r\n"
			"SET @nError = @@ERROR IF @nError <> 0 BEGIN RAISERROR('@@ERROR was %li!', 16, 1, @nError) ROLLBACK TRAN RETURN END\r\n"
			"INSERT INTO EMRImageHotSpotsT (ID, EMRInfoID, Data, EmrSpotGroupID, AnatomicLocationID, AnatomicQualifierID, AnatomySide, ImageHotSpotID) SELECT NewID, @EMRInfoID, Data, EmrSpotGroupID, AnatomicLocationID, AnatomicQualifierID, AnatomySide, ImageHotSpotID "
			"  FROM @HotSpotTempT;\r\n "
			"SET @nError = @@ERROR IF @nError <> 0 BEGIN RAISERROR('@@ERROR was %li!', 16, 1, @nError) ROLLBACK TRAN RETURN END\r\n"


			//DRT 1/24/2008 - PLID 28602 - Also copy the actions for those hotspots.
			"DECLARE @tHotSpotActionsT TABLE (RowNum int identity NOT NULL PRIMARY KEY, OldID int NOT NULL, NewID int NULL, DestType int NOT NULL, NewSourceID int NOT NULL) \r\n"
			"INSERT INTO @tHotSpotActionsT (OldID, DestType, NewSourceID) \r\n"
			"  SELECT ID, DestType, NewSpotsT.NewID FROM EMRActionsT INNER JOIN @HotSpotTempT NewSpotsT ON EMRActionsT.SourceID = NewSpotsT.OldID AND SourceType = 10 AND Deleted = 0 \r\n"
			"SET @nError = @@ERROR IF @nError <> 0 BEGIN RAISERROR('@@ERROR was %li!', 16, 1, @nError) ROLLBACK TRAN RETURN END\r\n"
			"UPDATE @tHotSpotActionsT SET NewID = RowNum + COALESCE((SELECT MAX(ID) FROM EMRActionsT WITH(UPDLOCK, HOLDLOCK)), 0) \r\n"
			"SET @nError = @@ERROR IF @nError <> 0 BEGIN RAISERROR('@@ERROR was %li!', 16, 1, @nError) ROLLBACK TRAN RETURN END\r\n"

			"SET IDENTITY_INSERT EMRActionsT ON \r\n"
			"SET @nError = @@ERROR IF @nError <> 0 BEGIN RAISERROR('@@ERROR was %li!', 16, 1, @nError) ROLLBACK TRAN RETURN END\r\n"
			"INSERT INTO EMRActionsT (ID, SourceType, SourceID, DestType, DestID, SortOrder, Popup, SpawnAsChild) \r\n"
			" SELECT NewID, SourceType, NewSourceID, EMRActionsT.DestType, DestID, SortOrder, Popup, SpawnAsChild \r\n"
			" FROM EMRActionsT "
			" INNER JOIN @tHotSpotActionsT ON ID = OldID \r\n"
			"SET @nError = @@ERROR IF @nError <> 0 BEGIN RAISERROR('@@ERROR was %li!', 16, 1, @nError) ROLLBACK TRAN RETURN END\r\n"
			"SET IDENTITY_INSERT EMRActionsT OFF \r\n"
			"SET @nError = @@ERROR IF @nError <> 0 BEGIN RAISERROR('@@ERROR was %li!', 16, 1, @nError) ROLLBACK TRAN RETURN END\r\n"

			// (c.haag 2008-08-18 10:44) - PLID 30724 - Emr problem actions
			// (c.haag 2014-07-22) - PLID 62789 - Added SNOMEDCodeID
			// (s.tullis 2015-02-23 17:47) - PLID 64749 
			// (r.gonet 2015-03-10 14:48) - PLID 65013 - Added DoNotShowOnProblemPrompt.
			"DECLARE @tHotSpotProblemActionsT TABLE (RowNum int identity NOT NULL PRIMARY KEY, OldID INT NOT NULL, NewID INT NULL, NewActionID INT NOT NULL) \r\n"
			"INSERT INTO @tHotSpotProblemActionsT (OldID, NewActionID) "
			" SELECT EmrProblemActionsT.ID, NewActionsT.NewID FROM EmrProblemActionsT "
			" INNER JOIN @tHotSpotActionsT NewActionsT ON EmrProblemActionsT.EmrActionID = NewActionsT.OldID \r\n"
			"SET @nError = @@ERROR IF @nError <> 0 BEGIN RAISERROR('@@ERROR was %li!', 16, 1, @nError) ROLLBACK TRAN RETURN END\r\n"
			"UPDATE @tHotSpotProblemActionsT SET NewID = RowNum + COALESCE((SELECT MAX(ID) FROM EMRProblemActionsT WITH(UPDLOCK, HOLDLOCK)), 0) \r\n"
			"SET @nError = @@ERROR IF @nError <> 0 BEGIN RAISERROR('@@ERROR was %li!', 16, 1, @nError) ROLLBACK TRAN RETURN END\r\n"
			"SET IDENTITY_INSERT EMRProblemActionsT ON \r\n"
			"SET @nError = @@ERROR IF @nError <> 0 BEGIN RAISERROR('@@ERROR was %li!', 16, 1, @nError) ROLLBACK TRAN RETURN END\r\n"
			"INSERT INTO EmrProblemActionsT (ID, EmrActionID, DefaultDescription, DefaultStatus, SpawnToSourceItem, SNOMEDCodeID, DoNotShowOnCCDA, DoNotShowOnProblemPrompt) "
			" SELECT NewProblemActionsT.NewID, NewProblemActionsT.NewActionID, DefaultDescription, DefaultStatus, SpawnToSourceItem, SNOMEDCodeID, DoNotShowOnCCDA, DoNotShowOnProblemPrompt "
			" FROM EmrProblemActionsT "
			" INNER JOIN @tHotSpotProblemActionsT NewProblemActionsT ON EmrProblemActionsT.ID = NewProblemActionsT.OldID "
			" WHERE EmrProblemActionsT.Inactive = 0 \r\n"
			"SET IDENTITY_INSERT EMRProblemActionsT OFF \r\n"
			"SET @nError = @@ERROR IF @nError <> 0 BEGIN RAISERROR('@@ERROR was %li!', 16, 1, @nError) ROLLBACK TRAN RETURN END\r\n"

			//If the DestType is charge, then we need to copy the charge data
			"INSERT INTO EMRActionChargeDataT (ActionID, Prompt, DefaultQuantity, Modifier1Number, Modifier2Number, Modifier3Number, Modifier4Number) \r\n"
			" SELECT NewActionsT.NewID, Prompt, DefaultQuantity, Modifier1Number, Modifier2Number, Modifier3Number, Modifier4Number \r\n"
			" FROM EMRActionChargeDataT "
			" INNER JOIN @tHotSpotActionsT NewActionsT ON EMRActionChargeDataT.ActionID = OldID \r\n"
			" WHERE DestType = 1 \r\n"
			"SET @nError = @@ERROR IF @nError <> 0 BEGIN RAISERROR('@@ERROR was %li!', 16, 1, @nError) ROLLBACK TRAN RETURN END\r\n"

			// (c.haag 2008-06-20 10:58) - PLID 30221 - Copy todo data
			"INSERT INTO EmrActionsTodoDataT (ActionID, RemindType, RemindInterval, DeadlineType, DeadlineInterval, Notes, Priority, Task, CategoryID) \r\n"
			" SELECT NewActionsT.NewID, RemindType, RemindInterval, DeadlineType, DeadlineInterval, Notes, Priority, Task, CategoryID \r\n"
			" FROM EmrActionsTodoDataT "
			" INNER JOIN @tHotSpotActionsT NewActionsT ON EmrActionsTodoDataT.ActionID = OldID \r\n"
			"SET @nError = @@ERROR IF @nError <> 0 BEGIN RAISERROR('@@ERROR was %li!', 16, 1, @nError) ROLLBACK TRAN RETURN END\r\n"
			// Copy todo assignment data
			"INSERT INTO EmrActionsTodoAssignToT (ActionID, AssignTo) \r\n"
			" SELECT NewActionsT.NewID, AssignTo \r\n"
			" FROM EmrActionsTodoAssignToT "
			" INNER JOIN @tHotSpotActionsT NewActionsT ON EmrActionsTodoAssignToT.ActionID = OldID \r\n"
			"SET @nError = @@ERROR IF @nError <> 0 BEGIN RAISERROR('@@ERROR was %li!', 16, 1, @nError) ROLLBACK TRAN RETURN END\r\n"

			// (b.savon 2014-07-16 09:39) - PLID 62707 - Handle saving the new Diagnosis DestType action to EmrActionsT and EmrActionsDiagnosisDataT
			"INSERT INTO EmrActionDiagnosisDataT (EmrActionID, DiagCodeID_ICD9, DiagCodeID_ICD10 ) \r\n"
			" SELECT NewActionsT.NewID, DiagCodeID_ICD9, DiagCodeID_ICD10 \r\n "
			" FROM EmrActionDiagnosisDataT  \r\n"
			" INNER JOIN @tHotSpotActionsT NewActionsT ON EmrActionDiagnosisDataT.EmrActionID = OldID  \r\n"
			" WHERE DestType = {INT}  \r\n"

			"SET NOCOUNT OFF;\r\n\r\n"

			"SELECT @EMRInfoID AS EMRInfoID\r\n\r\n"

			//DRT 1/24/2008 - PLID 28602 - Also handle pulling out the old/new id sets so we can fix up our data
			// (c.haag 2008-08-18 10:24) - PLID 30724 - Also pull from problem actions
			//	0 = Hot spot record
			//	1 = Action record
			//	2 = Problem action record
			"SELECT RecType, OldHSID, NewID, OldID FROM ("
			"  SELECT 0 AS RecType, OldID AS OldHSID, NewID, OldID FROM @HotSpotTempT"
			"  UNION SELECT 1 AS RecType, HST.OldID AS OldHSID, NewActionsT.NewID, NewActionsT.OldID FROM @tHotSpotActionsT NewActionsT "
			"		 INNER JOIN @HotSpotTempT HST ON NewActionsT.NewSourceID = HST.NewID "
			"  UNION SELECT 2 AS RecType, HST.OldID AS OldHSID, NewProblemActionsT.NewID, NewProblemActionsT.OldID FROM @tHotSpotProblemActionsT NewProblemActionsT "
			"		 INNER JOIN @tHotSpotActionsT HSAT ON NewProblemActionsT.NewActionID = HSAT.NewID "
			"		 INNER JOIN @HotSpotTempT HST ON HSAT.NewSourceID = HST.NewID "
			") Q "
			"ORDER BY OldHSID, RecType;\r\n"
			, strNewName, nOldInfoID, nOldInfoID, eaoDiagnosis);

		if(IsSystemCurrentMedicationsItem()) 
		{
			Log_CurrentMedicationsEdit("Executing PrepareToReassign() Query: "
				+ strprsMain.Flatten());
		}
		_RecordsetPtr prsMain = CreateParamRecordset(strprsMain);

		// (j.armen 2014-01-29 12:06) - PLID 60523 - Idenitate EMRInfoT - Get the ID here
		nNewID = AdoFldLong(prsMain, "EMRInfoID");

		if(IsSystemCurrentMedicationsItem())
		{
			Log_CurrentMedicationsEdit(FormatString("nNewID = %li, strNewName = %s, nOldInfoID = %li", nNewID, strNewName, nOldInfoID));
		}

		prsMain = prsMain->NextRecordset(NULL);

		//Now work with the results of our query to update the changed ID maps
		//	See the code below after the data maps to see how I modeled this.
		while(!prsMain->eof) {
			long nRecType = AdoFldLong(prsMain, "RecType");

			//Must be on 0 to start
			if(nRecType != 0) {
				AfxThrowNxException("Invalid type when parsing hotspot change map results.");
			}

			long nOldID = AdoFldLong(prsMain, "OldID");
			long nNewID = AdoFldLong(prsMain, "NewID");

			EMRInfoChangedHotSpot *pChanged = new EMRInfoChangedHotSpot;
			pChanged->nOldHotSpotID = nOldID;
			pChanged->nNewHotSpotID = nNewID;

			//Now iterate through all the changed actions
			prsMain->MoveNext();

			while(!prsMain->eof) {
				long nRecType = AdoFldLong(prsMain, "RecType");
				long nOldHSID = AdoFldLong(prsMain, "OldHSID");
				long nOldSubID = AdoFldLong(prsMain, "OldID");
				long nNewSubID = AdoFldLong(prsMain, "NewID");

				bool bDone = false;
				switch(nRecType) {
				case 0:
					{
						//This is a new hotspot.  The previous one is done with its
						//	actions.
						bDone = true;

						//Do not move the loop, we want to read this next time around in the main loop
					}
					break;
				case 1:
					{
						//This is an action.  Add it to our array.
						EMRInfoChangedAction *pAction = new EMRInfoChangedAction;
						pAction->nOldActionID = nOldSubID;
						pAction->nNewActionID = nNewSubID;
						pChanged->aryChangedActionIDs.Add(pAction);

						//Move to the next iteration of the loop
						prsMain->MoveNext();
					}
					break;
				case 2:
					{
						// (c.haag 2008-08-18 10:41) - PLID 30724 - This is a problem action
						EMRInfoChangedProblemAction cpa;
						cpa.nOldID = nOldSubID;
						cpa.nNewID = nNewSubID;
						pChanged->aryChangedPAIDs.Add(cpa);

						//Move to the next iteration of the loop
						prsMain->MoveNext();
					}
					break;
				default:
					{
						AfxThrowNxException("Invalid type %li when parsing changed hotspot action data.", nRecType);
					}
					break;
				}

				if(bDone) {
					//Quit the loop
					break;
				}
			}

			//This particular element is done, add it to our member array.
			m_pChangedIDMap->aryChangedHotSpotIDs.Add(pChanged);
		}


		//audit that this is happening, use the new InfoID as the recordID
		//process this audit immediately
		{
			CString strOldName;
			_RecordsetPtr rs = CreateRecordset("SELECT Name FROM EMRInfoT WHERE ID = %li", nOldInfoID);
			if(!rs->eof) {
				strOldName = AdoFldString(rs, "Name","");
			}
			rs->Close();

			long nAuditID = BeginNewAuditEvent();
			AuditEvent(-1, "", nAuditID, aeiEMRItemAutoCopied, nNewID, strOldName, strNewName, aepHigh, aetCreated);
		}

		// (j.jones 2006-08-29 15:02) - PLID 22271 - we will use this data to reassign to the new info item in
		// ReassignEmrInfoItem()

		/* PHASE 2: EMRDataT information

		In the following block of code, we copy records from the following tables:

		1. EmrDataT
		2. EmrInfoDefaultsT
		3. EmrActionsT for data elements
		4. EmrProblemActionsT for data elements
		5. EmrActionChargeDataT for data elements
		6. EmrActionsTodoDataT for data elements
		7. EmrActionsTodoAssignToT for data elements
		8. EmrTableDropdownInfoT
		9. EmrActionsT for dropdown items
		10. EmrProblemActionsT for dropdown items
		11. EmrActionChargeDataT for dropdown items
		12. EmrActionsTodoDataT for dropdown items
		13. EmrActionsTodoAssignToT for dropdown items
		14. EmrItemLinkedDataT

		Returned records:

		1. New EmrDataT
		2. New EmrTableDropdownInfoT
		3. New EmrActionsT for data
		4. New EmrActionsT for dropdown items

		*/

		//2)  Copy all the records in EMRDataT		
		// (b.cardillo 2007-07-26 12:45) - PLID 26826 - Changed this crazy loop into a single statement.  This 
		// is phase 1 of this pl item.  I still need to pull the surrounding queries into this one just to make 
		// it that much faster.  Then after that I'll need to assess the ReassignEmrInfoItem() function because 
		// its slowness is now the bottleneck in saving EMR Items that are in use on patient EMNs.
		{
			// This query does everything at once for the data.  Notice it has to temporarily disable triggers 
			// which is guaranteed safe because since we know we're just adding data for a brand new emr item 
			// we know the trigger couldn't possibly do anything anyway.  The disabling and re-enabling is done 
			// within the transaction, and it involves an ALTER TABLE so as soon as it's disabled, the whole 
			// table is locked for the rest of the transaction; this way there's no chance that anybody will be 
			// able to secretly (or accidentally) take advantage of the absence of the trigger.
			//TES 10/28/2010 - PLID 41174 - Special logging
			// (c.haag 2011-03-15) - PLID 42821 - Removed needless copying of the query so my modifications would not have
			// to be done twice in case I need to make any
			// (j.armen 2014-02-04 16:56) - PLID 60641 - The method of altering the table was bad - especially when
			//	get into snapshot isolation, where tables are not locked, but the schema is.
			//	the triggers now listen to the enabled flag in EMRTriggerStateT
			//	SELECT operations in snapshot won't be calling the triggers, so they can now complete
			//	Multiple calls to this function will block at the beginning while trying to update the trigger flag.
			//	Anything that is legit trying to call triggers will be blocked until after this function completes.
			CSqlFragment strprsAll = CSqlFragment(
				//Make a new record of this data in EMRDataT
				"SET NOCOUNT ON \r\n"
				"UPDATE EMRTriggerStateT SET Enabled = 0\r\n"
				// (b.cardillo 2007-08-06 17:35) - Throughout this query we check the @@ERROR state, but all we 
				// ever did in response was rollback and return, we never threw an exception.  And since the 
				// transaction was started by ado the rollback itself made less sense.  So now we "raise" the 
				// error instead of rolling back; this causes an exception to be thrown, which causes the ado 
				// rollback to occur, so the transaction gets rolled back propely anyway, plus this way we get 
				// the reason for the error on screen.
				"DECLARE @nError INT \r\n"

				"DECLARE @tNewDataT TABLE (RowNum INT IDENTITY NOT NULL PRIMARY KEY, OldID INT NOT NULL, NewID INT) \r\n"
				"INSERT INTO @tNewDataT (OldID) \r\n"
				" SELECT ID FROM EMRDataT WHERE EMRInfoID = {INT} \r\n"
				"SET @nError = @@ERROR IF @nError <> 0 BEGIN RAISERROR('@@ERROR was %li!', 16, 1, @nError) ROLLBACK TRAN RETURN END\r\n"
				"UPDATE @tNewDataT SET NewID = RowNum + COALESCE((SELECT MAX(ID) FROM EMRDataT WITH(UPDLOCK, HOLDLOCK)), 0) \r\n"
				"SET @nError = @@ERROR IF @nError <> 0 BEGIN RAISERROR('@@ERROR was %li!', 16, 1, @nError) ROLLBACK TRAN RETURN END\r\n"

				//TES 12/7/2006 - PLID 23766 - Keep the same EmrDataGroupID, so we know these are copies of each other.
				// (z.manning, 06/02/2008) - PLID 16443 - Added Formula and DecimalPlaces
				// (z.manning 2009-01-15 17:07) - PLID 32724 - Added InputMask
				// (z.manning 2010-02-11 17:17) - PLID 37324 - ListSubType
				// (c.haag 2010-02-24 09:26) - PLID 37488 - AutoAlphabetizeDropDown
				// (j.gruber 2010-04-27 08:57) - PLID 38336 - BOLD Code
				//TES 3/15/2011 - PLID 42757 - Added GlassesOrderDataType, GlassesOrderDataID
				// (z.manning 2011-03-21 10:10) - PLID 23662 - Added autofill type
				// (z.manning 2011-05-26 15:11) - PLID 43865 - DataFlags
				// (z.manning 2011-09-19 13:50) - PLID 41954 - Dropdown separators
				// (z.manning 2011-11-07 10:58) - PLID 46309 - SpawnedItemsSeparator
				// (r.gonet 08/03/2012) - PLID 51735 - UseWithWoundCareCoding
				// (j.gruber 2014-07-18 14:19) - PLID 62624 - Keyword Saving
				// (j.gruber 2014-12-05 16:18) - PLID 64289 - search queue - UseNameForKeyword Saving
				"INSERT INTO EMRDataT (ID, EMRInfoID, Data, Inactive, LongForm, SortOrder, ListType, IsLabel, IsGrouped, CopiedFromDataID, EmrDataGroupID, Formula, DecimalPlaces, InputMask, ListSubType, AutoAlphabetizeDropDown, BOLDCode, AutoNumberType, AutoNumberPrefix, GlassesOrderDataType, GlassesOrderDataID, AutofillType, DataFlags, DropdownSeparator, DropdownSeparatorFinal, SpawnedItemsSeparator, WoundCareDataType, UseKeyword, KeywordOverride, UseNameForKeyword) \r\n"
				" SELECT NewID, {INT}, Data, Inactive, LongForm, SortOrder, ListType, IsLabel, IsGrouped, ID, EmrDataGroupID, Formula, DecimalPlaces, InputMask, ListSubType, AutoAlphabetizeDropDown, BOLDCode, AutoNumberType, AutoNumberPrefix, GlassesOrderDataType, GlassesOrderDataID, AutofillType, DataFlags, DropdownSeparator, DropdownSeparatorFinal, SpawnedItemsSeparator, WoundCareDataType, UseKeyword, KeywordOverride, UseNameForKeyword \r\n"
				" FROM EMRDataT INNER JOIN @tNewDataT ON ID = OldID \r\n"
				"SET @nError = @@ERROR IF @nError <> 0 BEGIN RAISERROR('@@ERROR was %li!', 16, 1, @nError) ROLLBACK TRAN RETURN END\r\n"

				//2a)  We also need to copy anything in EMRDefaultsT.  This record will only exist for some data
				//	elements, so we only copy some of the time.
				"INSERT INTO EMRInfoDefaultsT (EMRInfoID, EMRDataID) \r\n"
				" SELECT {INT}, NewID FROM @tNewDataT INNER JOIN EMRInfoDefaultsT ON EMRDataID = OldID \r\n"
				" WHERE EMRInfoID = {INT} \r\n"
				"SET @nError = @@ERROR IF @nError <> 0 BEGIN RAISERROR('@@ERROR was %li!', 16, 1, @nError) ROLLBACK TRAN RETURN END\r\n"
				
				//2b)  We also need to copy any EMR actions that are specific to this data.  SourceType = 4 means
				//	the actions are for this specific EMRData object.
				//  (z.manning, 3/16/2006, PLID 19747) - There's no reason to copy deleted action items.

				//DRT 1/18/2007 - PLID 24181 - EMRActionsT now links to EMRActionChargeDataT, so we cannot batch copy any longer.
				//	We need to get a list of all actions, insert them with their corresponding ChargeAction data.
				//Additionally for speed, we'll batch the whole process.
				"DECLARE @tActionsT TABLE (RowNum INT IDENTITY NOT NULL PRIMARY KEY, OldID INT NOT NULL, NewID INT, DestType INT NOT NULL, NewSourceID INT NOT NULL) \r\n"
				"INSERT INTO @tActionsT (OldID, DestType, NewSourceID) \r\n"
				" SELECT ID, DestType, ND.NewID FROM EMRActionsT "
				" INNER JOIN @tNewDataT ND ON SourceID = ND.OldID AND SourceType = 4 AND Deleted = 0 \r\n"
				"SET @nError = @@ERROR IF @nError <> 0 BEGIN RAISERROR('@@ERROR was %li!', 16, 1, @nError) ROLLBACK TRAN RETURN END\r\n"
				"UPDATE @tActionsT SET NewID = RowNum + COALESCE((SELECT MAX(ID) FROM EMRActionsT WITH(UPDLOCK, HOLDLOCK)), 0) \r\n"
				"SET @nError = @@ERROR IF @nError <> 0 BEGIN RAISERROR('@@ERROR was %li!', 16, 1, @nError) ROLLBACK TRAN RETURN END\r\n"

				//TES 1/30/2007 - PLID 24474 - Don't forget SpawnAsChild!
				"SET IDENTITY_INSERT EMRActionsT ON \r\n"
				"SET @nError = @@ERROR IF @nError <> 0 BEGIN RAISERROR('@@ERROR was %li!', 16, 1, @nError) ROLLBACK TRAN RETURN END\r\n"
				"INSERT INTO EMRActionsT (ID, SourceType, SourceID, DestType, DestID, SortOrder, Popup, SpawnAsChild) \r\n"
				" SELECT NewID, SourceType, NewSourceID, EMRActionsT.DestType, DestID, SortOrder, Popup, SpawnAsChild \r\n"
				" FROM EMRActionsT "
				" INNER JOIN @tActionsT ON ID = OldID \r\n"
				"SET @nError = @@ERROR IF @nError <> 0 BEGIN RAISERROR('@@ERROR was %li!', 16, 1, @nError) ROLLBACK TRAN RETURN END\r\n"
				"SET IDENTITY_INSERT EMRActionsT OFF \r\n"
				"SET @nError = @@ERROR IF @nError <> 0 BEGIN RAISERROR('@@ERROR was %li!', 16, 1, @nError) ROLLBACK TRAN RETURN END\r\n"

				// (c.haag 2008-08-18 10:44) - PLID 30724 - Emr problem actions
				// (c.haag 2014-07-22) - PLID 62789 - Added SNOMEDCodeID
				// (s.tullis 2015-02-23 17:47) - PLID 64749 
				// (r.gonet 2015-03-10 14:48) - PLID 65013 - Added DoNotShowOnProblemPrompt.
				"DECLARE @tProblemActionsT TABLE (RowNum int identity NOT NULL PRIMARY KEY, OldID INT NOT NULL, NewID INT NULL, NewActionID INT NOT NULL) \r\n"
				"INSERT INTO @tProblemActionsT (OldID, NewActionID) "
				" SELECT EmrProblemActionsT.ID, NewActionsT.NewID FROM EmrProblemActionsT "
				" INNER JOIN @tActionsT NewActionsT ON EmrProblemActionsT.EmrActionID = NewActionsT.OldID \r\n"
				"SET @nError = @@ERROR IF @nError <> 0 BEGIN RAISERROR('@@ERROR was %li!', 16, 1, @nError) ROLLBACK TRAN RETURN END\r\n"
				"UPDATE @tProblemActionsT SET NewID = RowNum + COALESCE((SELECT MAX(ID) FROM EMRProblemActionsT WITH(UPDLOCK, HOLDLOCK)), 0) \r\n"
				"SET @nError = @@ERROR IF @nError <> 0 BEGIN RAISERROR('@@ERROR was %li!', 16, 1, @nError) ROLLBACK TRAN RETURN END\r\n"
				"SET IDENTITY_INSERT EMRProblemActionsT ON \r\n"
				"SET @nError = @@ERROR IF @nError <> 0 BEGIN RAISERROR('@@ERROR was %li!', 16, 1, @nError) ROLLBACK TRAN RETURN END\r\n"
				"INSERT INTO EmrProblemActionsT (ID, EmrActionID, DefaultDescription, DefaultStatus, SpawnToSourceItem, SNOMEDCodeID, DoNotShowOnCCDA, DoNotShowOnProblemPrompt) "
				" SELECT NewProblemActionsT.NewID, NewProblemActionsT.NewActionID, DefaultDescription, DefaultStatus, SpawnToSourceItem, SNOMEDCodeID, DoNotShowOnCCDA, DoNotShowOnProblemPrompt "
				" FROM EmrProblemActionsT "
				" INNER JOIN @tProblemActionsT NewProblemActionsT ON EmrProblemActionsT.ID = NewProblemActionsT.OldID "
				" WHERE EmrProblemActionsT.Inactive = 0 \r\n"
				"SET IDENTITY_INSERT EMRProblemActionsT OFF \r\n"
				"SET @nError = @@ERROR IF @nError <> 0 BEGIN RAISERROR('@@ERROR was %li!', 16, 1, @nError) ROLLBACK TRAN RETURN END\r\n"

				//If the DestType is charge, then we need to copy the charge data
				"INSERT INTO EMRActionChargeDataT (ActionID, Prompt, DefaultQuantity, Modifier1Number, Modifier2Number, Modifier3Number, Modifier4Number) \r\n"
				" SELECT NewID, Prompt, DefaultQuantity, Modifier1Number, Modifier2Number, Modifier3Number, Modifier4Number \r\n"
				" FROM EMRActionChargeDataT "
				" INNER JOIN @tActionsT ON EMRActionChargeDataT.ActionID = OldID \r\n"
				" WHERE DestType = 1 \r\n"
				"SET @nError = @@ERROR IF @nError <> 0 BEGIN RAISERROR('@@ERROR was %li!', 16, 1, @nError) ROLLBACK TRAN RETURN END\r\n"

				// (c.haag 2008-06-20 10:58) - PLID 30221 - Copy todo data
				"INSERT INTO EmrActionsTodoDataT (ActionID, RemindType, RemindInterval, DeadlineType, DeadlineInterval, Notes, Priority, Task, CategoryID) \r\n"
				" SELECT NewID, RemindType, RemindInterval, DeadlineType, DeadlineInterval, Notes, Priority, Task, CategoryID \r\n"
				" FROM EmrActionsTodoDataT "
				" INNER JOIN @tActionsT NewActionsT ON EmrActionsTodoDataT.ActionID = OldID \r\n"
				"SET @nError = @@ERROR IF @nError <> 0 BEGIN RAISERROR('@@ERROR was %li!', 16, 1, @nError) ROLLBACK TRAN RETURN END\r\n"
				// Copy todo assignment data
				"INSERT INTO EmrActionsTodoAssignToT (ActionID, AssignTo) \r\n"
				" SELECT NewID, AssignTo \r\n"
				" FROM EmrActionsTodoAssignToT "
				" INNER JOIN @tActionsT NewActionsT ON EmrActionsTodoAssignToT.ActionID = OldID \r\n"
				"SET @nError = @@ERROR IF @nError <> 0 BEGIN RAISERROR('@@ERROR was %li!', 16, 1, @nError) ROLLBACK TRAN RETURN END\r\n"

				// (b.savon 2014-07-16 09:39) - PLID 62707 - Handle saving the new Diagnosis DestType action to EmrActionsT and EmrActionsDiagnosisDataT
				"INSERT INTO EmrActionDiagnosisDataT (EmrActionID, DiagCodeID_ICD9, DiagCodeID_ICD10 ) \r\n"
				" SELECT NewActionsT.NewID, DiagCodeID_ICD9, DiagCodeID_ICD10 \r\n "
				" FROM EmrActionDiagnosisDataT  \r\n"
				" INNER JOIN @tActionsT NewActionsT ON EmrActionDiagnosisDataT.EmrActionID = OldID  \r\n"
				" WHERE DestType = {INT}  \r\n"

				//2c)  If this is a table, we need to copy data from EMRTableDropdownInfoT			
				// Get the set of IDs of all the records we're going to copy				
				"DECLARE @tDDInfoT TABLE (RowNum INT IDENTITY NOT NULL PRIMARY KEY, OldID INT NOT NULL, NewID INT, NewEMRDataID INT NOT NULL) \r\n"
				"INSERT INTO @tDDInfoT (OldID, NewEMRDataID) \r\n"
				" SELECT ID, ND.NewID FROM EMRTableDropdownInfoT INNER JOIN @tNewDataT ND ON EMRDataID = ND.OldID \r\n"
				"SET @nError = @@ERROR IF @nError <> 0 BEGIN RAISERROR('@@ERROR was %li!', 16, 1, @nError) ROLLBACK TRAN RETURN END\r\n"
				// Give them a guaranteed unique new id in the temp table
				"UPDATE @tDDInfoT SET NewID = RowNum + COALESCE((SELECT MAX(ID) FROM EMRTableDropdownInfoT WITH(UPDLOCK, HOLDLOCK)), 0) \r\n"
				"SET @nError = @@ERROR IF @nError <> 0 BEGIN RAISERROR('@@ERROR was %li!', 16, 1, @nError) ROLLBACK TRAN RETURN END\r\n"
				// Finally make copies of just those records, using the new id for each new record's id
				//TES 12/7/2006 - PLID 23766 - Keep the same DropdownGroupID, so we know these are copies of each other.
				//TES 3/15/2011 - PLID 42757 - Added GlassesOrderDataID
				// (j.gruber 2014-07-22 13:11) - PLID 62627 - Keyword				
				"INSERT INTO EMRTableDropdownInfoT (ID, EMRDataID, Data, SortOrder, Inactive, GlassesOrderDataID, CopiedFromDropdownID, DropdownGroupID, UseKeyword, KeywordOverride) \r\n"
				" SELECT NewID, NewEMRDataID, Data, SortOrder, Inactive, GlassesOrderDataID, ID, DropdownGroupID, UseKeyword, KeywordOverride \r\n"
				" FROM EMRTableDropdownInfoT "
				" INNER JOIN @tDDInfoT ON ID = OldID \r\n"
				"SET @nError = @@ERROR IF @nError <> 0 BEGIN RAISERROR('@@ERROR was %li!', 16, 1, @nError) ROLLBACK TRAN RETURN END\r\n"

				"INSERT INTO EmrTableDropdownStampFilterT (EmrTableDropdownInfoID, StampID) \r\n"
				" SELECT NewID, StampID \r\n"
				" FROM EmrTableDropdownStampFilterT "
				" INNER JOIN @tDDInfoT ON EmrTableDropdownInfoID = OldID \r\n"
				"SET @nError = @@ERROR IF @nError <> 0 BEGIN RAISERROR('@@ERROR was %li!', 16, 1, @nError) ROLLBACK TRAN RETURN END\r\n"

				"INSERT INTO EMRTableDropdownStampDefaultsT (EmrTableDropdownInfoID, StampID) \r\n"
				" SELECT NewID, StampID \r\n"
				" FROM EMRTableDropdownStampDefaultsT "
				" INNER JOIN @tDDInfoT ON EmrTableDropdownInfoID = OldID \r\n"
				"SET @nError = @@ERROR IF @nError <> 0 BEGIN RAISERROR('@@ERROR was %li!', 16, 1, @nError) ROLLBACK TRAN RETURN END\r\n"

				// (c.haag 2010-07-10 11:19) - PLID 39467 - Ensure we did not create multiple values for a dropdown with the same sort order
				"IF EXISTS(SELECT EMRDataID, SortOrder FROM EMRTableDropdownInfoT WHERE EMRDataID IN (SELECT NewEMRDataID FROM @tDDInfoT) GROUP BY EMRDataID, SortOrder HAVING Count(SortOrder) > 1) \r\n"
				"BEGIN RAISERROR('Duplicate SortOrder values detected in EMRTableDropdownInfoT!', 16, 1) ROLLBACK TRAN RETURN END \r\n"

				// (z.manning 2009-02-12 11:02) - PLID 33058 - Table dropdown item actions
				"DECLARE @tDropdownActionsT TABLE (RowNum INT IDENTITY NOT NULL PRIMARY KEY, OldID INT NOT NULL, NewID INT, DestType INT NOT NULL, NewSourceID INT NOT NULL) \r\n"
				"INSERT INTO @tDropdownActionsT (OldID, DestType, NewSourceID) \r\n"
				" SELECT ID, DestType, NewInfo.NewID FROM EMRActionsT INNER JOIN @tDDInfoT NewInfo ON SourceID = NewInfo.OldID AND SourceType = 13 AND Deleted = 0 \r\n"
				"SET @nError = @@ERROR IF @nError <> 0 BEGIN RAISERROR('@@ERROR was %li!', 16, 1, @nError) ROLLBACK TRAN RETURN END\r\n"
				"UPDATE @tDropdownActionsT SET NewID = RowNum + COALESCE((SELECT MAX(ID) FROM EMRActionsT), 0) \r\n"
				"SET @nError = @@ERROR IF @nError <> 0 BEGIN RAISERROR('@@ERROR was %li!', 16, 1, @nError) ROLLBACK TRAN RETURN END\r\n"

				// (z.manning 2009-02-12 11:02) - PLID 33058 - Table dropdown item actions
				"SET IDENTITY_INSERT EMRActionsT ON \r\n"
				"SET @nError = @@ERROR IF @nError <> 0 BEGIN RAISERROR('@@ERROR was %li!', 16, 1, @nError) ROLLBACK TRAN RETURN END\r\n"
				"INSERT INTO EMRActionsT (ID, SourceType, SourceID, DestType, DestID, SortOrder, Popup, SpawnAsChild) \r\n"
				" SELECT NewID, SourceType, NewSourceID, EMRActionsT.DestType, DestID, SortOrder, Popup, SpawnAsChild \r\n"
				" FROM EMRActionsT "
				" INNER JOIN @tDropdownActionsT ON ID = OldID \r\n"
				"SET @nError = @@ERROR IF @nError <> 0 BEGIN RAISERROR('@@ERROR was %li!', 16, 1, @nError) ROLLBACK TRAN RETURN END\r\n"
				"SET IDENTITY_INSERT EMRActionsT OFF \r\n"
				"SET @nError = @@ERROR IF @nError <> 0 BEGIN RAISERROR('@@ERROR was %li!', 16, 1, @nError) ROLLBACK TRAN RETURN END\r\n"

				// (z.manning 2009-02-12 11:02) - PLID 33058 - Table dropdown item actions
				// (c.haag 2014-07-22) - PLID 62789 - Added SNOMEDCodeID
				// (s.tullis 2015-02-23 17:47) - PLID 64749 
				// (r.gonet 2015-03-10 14:48) - PLID 65013 - Added DoNotShowOnProblemPrompt.
				"DECLARE @tDropdownProblemActionsT TABLE (RowNum int identity NOT NULL PRIMARY KEY, OldID INT NOT NULL, NewID INT NULL, NewActionID INT NOT NULL) \r\n"
				"INSERT INTO @tDropdownProblemActionsT (OldID, NewActionID) "
				" SELECT EmrProblemActionsT.ID, NewActionsT.NewID FROM EmrProblemActionsT "
				" INNER JOIN @tDropdownActionsT NewActionsT ON EmrProblemActionsT.EmrActionID = NewActionsT.OldID \r\n"
				"SET @nError = @@ERROR IF @nError <> 0 BEGIN RAISERROR('@@ERROR was %li!', 16, 1, @nError) ROLLBACK TRAN RETURN END\r\n"
				"UPDATE @tDropdownProblemActionsT SET NewID = RowNum + COALESCE((SELECT MAX(ID) FROM EMRProblemActionsT), 0) \r\n"
				"SET @nError = @@ERROR IF @nError <> 0 BEGIN RAISERROR('@@ERROR was %li!', 16, 1, @nError) ROLLBACK TRAN RETURN END\r\n"
				"SET IDENTITY_INSERT EMRProblemActionsT ON \r\n"
				"SET @nError = @@ERROR IF @nError <> 0 BEGIN RAISERROR('@@ERROR was %li!', 16, 1, @nError) ROLLBACK TRAN RETURN END\r\n"
				"INSERT INTO EmrProblemActionsT (ID, EmrActionID, DefaultDescription, DefaultStatus, SpawnToSourceItem, SNOMEDCodeID, DoNotShowOnCCDA, DoNotShowOnProblemPrompt) "
				" SELECT NewProblemActionsT.NewID, NewProblemActionsT.NewActionID, DefaultDescription, DefaultStatus, SpawnToSourceItem, SNOMEDCodeID, DoNotShowOnCCDA, DoNotShowOnProblemPrompt "
				" FROM EmrProblemActionsT "
				" INNER JOIN @tDropdownProblemActionsT NewProblemActionsT ON EmrProblemActionsT.ID = NewProblemActionsT.OldID "
				" WHERE EmrProblemActionsT.Inactive = 0 \r\n"
				"SET IDENTITY_INSERT EMRProblemActionsT OFF \r\n"
				"SET @nError = @@ERROR IF @nError <> 0 BEGIN RAISERROR('@@ERROR was %li!', 16, 1, @nError) ROLLBACK TRAN RETURN END\r\n"

				// (z.manning 2009-02-12 11:02) - PLID 33058 - Table dropdown item actions
				"INSERT INTO EMRActionChargeDataT (ActionID, Prompt, DefaultQuantity, Modifier1Number, Modifier2Number, Modifier3Number, Modifier4Number) \r\n"
				" SELECT NewID, Prompt, DefaultQuantity, Modifier1Number, Modifier2Number, Modifier3Number, Modifier4Number \r\n"
				" FROM EMRActionChargeDataT "
				" INNER JOIN @tDropdownActionsT ON EMRActionChargeDataT.ActionID = OldID \r\n"
				" WHERE DestType = 1 \r\n"
				"SET @nError = @@ERROR IF @nError <> 0 BEGIN RAISERROR('@@ERROR was %li!', 16, 1, @nError) ROLLBACK TRAN RETURN END\r\n"

				// (z.manning 2009-02-12 11:02) - PLID 33058 - Table dropdown item actions
				"INSERT INTO EmrActionsTodoDataT (ActionID, RemindType, RemindInterval, DeadlineType, DeadlineInterval, Notes, Priority, Task, CategoryID) \r\n"
				" SELECT NewID, RemindType, RemindInterval, DeadlineType, DeadlineInterval, Notes, Priority, Task, CategoryID \r\n"
				" FROM EmrActionsTodoDataT "
				" INNER JOIN @tDropdownActionsT NewActionsT ON EmrActionsTodoDataT.ActionID = OldID \r\n"
				"SET @nError = @@ERROR IF @nError <> 0 BEGIN RAISERROR('@@ERROR was %li!', 16, 1, @nError) ROLLBACK TRAN RETURN END\r\n"
				"INSERT INTO EmrActionsTodoAssignToT (ActionID, AssignTo) \r\n"
				" SELECT NewID, AssignTo \r\n"
				" FROM EmrActionsTodoAssignToT "
				" INNER JOIN @tDropdownActionsT NewActionsT ON EmrActionsTodoAssignToT.ActionID = OldID \r\n"
				"SET @nError = @@ERROR IF @nError <> 0 BEGIN RAISERROR('@@ERROR was %li!', 16, 1, @nError) ROLLBACK TRAN RETURN END\r\n"

				// (b.savon 2014-07-16 09:39) - PLID 62707 - Handle saving the new Diagnosis DestType action to EmrActionsT and EmrActionsDiagnosisDataT
				"INSERT INTO EmrActionDiagnosisDataT (EmrActionID, DiagCodeID_ICD9, DiagCodeID_ICD10 ) \r\n"
				" SELECT NewActionsT.NewID, DiagCodeID_ICD9, DiagCodeID_ICD10 \r\n "
				" FROM EmrActionDiagnosisDataT  \r\n"
				" INNER JOIN @tDropdownActionsT NewActionsT ON EmrActionDiagnosisDataT.EmrActionID = OldID  \r\n"
				" WHERE DestType = {INT}  \r\n"
				"SET @nError = @@ERROR IF @nError <> 0 BEGIN RAISERROR('@@ERROR was %li!', 16, 1, @nError) ROLLBACK TRAN RETURN END\r\n"

				//2d) TES 1/23/2007 - PLID 24377 - We also need to copy any links that this data item was a part of.
				"INSERT INTO EmrItemLinkedDataT (EmrLinkID, EmrDataID) \r\n"
				" SELECT EmrLinkID, NewID FROM EmrItemLinkedDataT "
				" INNER JOIN @tNewDataT ON EmrDataID = OldID \r\n"
				"SET @nError = @@ERROR IF @nError <> 0 BEGIN RAISERROR('@@ERROR was %li!', 16, 1, @nError) ROLLBACK TRAN RETURN END\r\n"

				// (j.armen 2014-02-04 17:09) - PLID 60641 - We want to enable our triggers again.
				//	We need not worry about deadlocks, we already have a lock here because we disabled above.
				//	The below update to EMRDataT previously had triggers enabled on it, so that it shall remain.
				"UPDATE EMRTriggerStateT SET Enabled = 1\r\n"
				"SET @nError = @@ERROR IF @nError <> 0 BEGIN RAISERROR('@@ERROR was %li!', 16, 1, @nError) ROLLBACK TRAN RETURN END\r\n"

				// (j.jones 2012-09-21 14:12) - PLID 52316 - update the ParentLabelID for any rows that had it before
				"UPDATE EMRDataT SET EMRDataT.ParentLabelID = NewParentLabelDataMapT.NewID \r\n"
				"FROM EMRDataT \r\n"
				"INNER JOIN @tNewDataT NewDataMapT ON EMRDataT.ID = NewDataMapT.NewID \r\n"
				"INNER JOIN EMRDataT OldEMRDataT ON NewDataMapT.OldID = OldEMRDataT.ID \r\n"
				"INNER JOIN EMRDataT OldParentLabelDataT ON OldEMRDataT.ParentLabelID = OldParentLabelDataT.ID \r\n"
				"INNER JOIN @tNewDataT NewParentLabelDataMapT ON OldParentLabelDataT.ID = NewParentLabelDataMapT.OldID \r\n"

				"SET NOCOUNT OFF \r\n"

				// (b.cardillo 2007-07-26 12:35) - Select the results to include all the new data ids, plus for each 
				// data id all of its new dropdowninfo ids.  This is the only resultset returned by this query, and 
				// it's sifted through later in order to generate the proper mappings for updating the entry screen.
				// (b.cardillo 2007-08-01 10:09) - PLID 26826 - Added the @tActionsT results here as well so that I 
				// could take out the complex query that was being run followed by a sub-loop on each iteration of 
				// the map loop down below (see associated comment where that code was removed).  The map loop now 
				// is pure c++ code, no calls to sql, so it's an almost 100% reduction in the time.  NOTE: In order 
				// to add the fields, I had to change how the query was formed as well as how it is then interpreted 
				// by the loop below; it's now a union of queries, one for each set of ids, sorted by data id.  Thus 
				// the loop below needs to expect the first record 
				// (c.haag 2008-08-18 10:49) - PLID 30724 - Added support for EmrProblemActionsT
				// (z.manning 2009-02-12 14:10) - PLID 33058 - Added support for table dropdown item actions
				// (z.manning 2011-04-29 10:33) - PLID 37604 - Added old list type and old dropdown data
				"SELECT Q.RecType, Q.OldID, Q.NewID, Q.SubItemNewID, Q.OldListType, Q.OldDropdownData FROM (\r\n"
				" SELECT CONVERT(INT, 0) AS RecType, NDT.OldID AS OldDataID, NDT.OldID, NDT.NewID, -1 AS SubItemNewID, EmrDataT.ListType AS OldListType, NULL AS OldDropdownData \r\n"
				" FROM @tNewDataT NDT \r\n"
				" LEFT JOIN EmrDataT ON NDT.OldID = EmrDataT.ID \r\n"
				" UNION ALL \r\n"
				" SELECT CONVERT(INT, 1) AS RecType, NDT.OldID AS OldDataID, DDIT.OldID, DDIT.NewID, -1 AS SubItemNewID, NULL AS OldListType, EmrTableDropdownInfoT.Data AS OldDropdownData \r\n"
				" FROM @tNewDataT NDT \r\n"
				" INNER JOIN @tDDInfoT DDIT ON NDT.NewID = DDIT.NewEMRDataID \r\n"
				" LEFT JOIN EmrTableDropdownInfoT ON DDIT.OldID = EmrTableDropdownInfoT.ID \r\n"
				" UNION ALL \r\n"
				" SELECT CONVERT(INT, 2) AS RecType, NDT.OldID AS OldDataID, DAT.OldID, DAT.NewID, -1 AS SubItemNewID, NULL AS OldListType, NULL AS OldDropdownData FROM @tNewDataT NDT INNER JOIN @tActionsT DAT ON NDT.NewID = DAT.NewSourceID \r\n"
				" UNION ALL \r\n"
				" SELECT CONVERT(INT, 3) AS RecType, NDT.OldID AS OldDataID, DPAT.OldID, DPAT.NewID, -1 AS SubItemNewID, NULL AS OldListType, NULL AS OldDropdownData FROM @tProblemActionsT DPAT "
				"		 INNER JOIN @tActionsT DAT ON DPAT.NewActionID = DAT.NewID "
				"		 INNER JOIN @tNewDataT NDT ON DAT.NewSourceID = NDT.NewID "
				" UNION ALL \r\n"
				" SELECT CONVERT(INT, 4) AS RecType, NDT.OldID AS OldDataID, DDAT.OldID, DDAT.NewID, DDIT.NewID AS SubItemNewID, NULL AS OldListType, NULL AS OldDropdownData \r\n"
				"	FROM @tDDInfoT DDIT \r\n"
				"	INNER JOIN @tNewDataT NDT ON DDIT.NewEmrDataID = NDT.NewID \r\n"
				"	INNER JOIN @tDropdownActionsT DDAT ON DDIT.NewID = DDAT.NewSourceID \r\n"
				" UNION ALL \r\n"
				" SELECT CONVERT(INT, 5) AS RecType, NDT.OldID AS OldDataID, DDPAT.OldID, DDPAT.NewID, DDIT.NewID AS SubItemNewID, NULL AS OldListType, NULL AS OldDropdownData \r\n"
				"	FROM @tDropdownProblemActionsT DDPAT "
				"	INNER JOIN @tDropdownActionsT DDAT ON DDPAT.NewActionID = DDAT.NewID "
				"	INNER JOIN @tDDInfoT DDIT ON DDAT.NewSourceID = DDIT.NewID "
				"	INNER JOIN @tNewDataT NDT ON DDIT.NewEmrDataID = NDT.NewID \r\n"

				") Q \r\n"
				"ORDER BY Q.OldDataID, Q.RecType \r\n",
				nOldInfoID, 
				nNewID,
				nNewID,
				nOldInfoID,
				eaoDiagnosis, 
				eaoDiagnosis);

			if(IsSystemCurrentMedicationsItem()) 
			{
				Log_CurrentMedicationsEdit("Executing PrepareToReassign() query 2 \r\n"
					+ strprsAll.Flatten());
				Log_CurrentMedicationsEdit(FormatString("nOldInfoID = %li, nNewID = %li", nOldInfoID, nNewID));
			}

			_RecordsetPtr prsAll = CreateParamRecordset(strprsAll);

			// (b.cardillo 2007-08-03 17:42) - For some crazy reason on some databases, and I'm waiting to get my hands 
			// on an example of such a database so I can try to figure out WHY, the ALTER TABLE statements in the above 
			// query each return a closed recordset as if NOCOUNT hadn't been set to ON!  So for now I've placed this 
			// workaround so that we just jump to the last recordset, i.e. the one in which we have SELECTed the records 
			// we need.
			while (true) {
				_RecordsetPtr prsNext = prsAll->NextRecordset(NULL);
				if (prsNext != NULL) {
					prsAll = prsNext;
				} else {
					break;
				}
			}

			// Now sift through the resultset to store all the correct mappings
			FieldsPtr pflds = prsAll->GetFields();
			FieldPtr fldRecType = pflds->GetItem("RecType");
			FieldPtr fldOldID = pflds->GetItem("OldID");
			FieldPtr fldNewID = pflds->GetItem("NewID");
			// (b.cardillo 2007-08-01 13:55) - The layout of the recordset is different now.  We now get exactly one 
			while (!prsAll->eof) {
				// Determine which kind of record this is
				long nRecType = AdoFldLong(fldRecType);
				// At the beginning of this loop the record type is ALWAYS 0 because we 100% expect that we're on a 
				// new data id.
				ASSERT(nRecType == 0);
				if (nRecType != 0) {
					ThrowNxException("Unexpected record type of %li when expected 0!", nRecType);
				}

				// Get the old and new data ids 
				long nOldDataID = AdoFldLong(fldOldID);
				long nNewDataID = AdoFldLong(fldNewID);

				// Store the new data id
				EMRInfoChangedData *pNewChangedData = new EMRInfoChangedData;
				pNewChangedData->nOldDataID = nOldDataID;
				pNewChangedData->nNewDataID = nNewDataID;
				// (z.manning 2011-04-29 10:27) - PLID 37604 - Added old and new list types
				pNewChangedData->nOldListType = AdoFldLong(prsAll, "OldListType", -1);
				// (z.manning 2011-04-29 17:32) - PLID 37604 - Since the new item isn't saved yet let's look up the new list type in memory.
				long nColIndex = m_aryCurColumnDataElements.FindDataElement(nOldDataID, 0);
				if(nColIndex == -1) {
					pNewChangedData->nNewListType = pNewChangedData->nOldListType;
				}
				else {
					CEmrInfoDataElement *peide = m_aryCurColumnDataElements.GetAt(nColIndex);
					pNewChangedData->nNewListType = peide->m_nListType;
				}

				// Move to the next record to see if there are any sub-records for this data id record
				prsAll->MoveNext();

				// Now get all the ddinfo sub-records corresponding to this overall emrdata record (we do this 
				// by looping until we get a different "old data id", which would mean we're on to the next one 
				// which means there are no more ddinfo ids for our current one.  This logic relies on the fact 
				// that the resultset is sorted by "old data id", because that means the ddinfo ids are GROUPED 
				// by same.
				while (!prsAll->eof) {
					// Get the record type again now that we're on a new record
					nRecType = AdoFldLong(fldRecType);

					// If we're back at a 0-type record, that means our inner loop is done so break out
					if (nRecType == 0) {
						break;
					}

					// Add the appropriate sub-records to the main data object based on the record type
					switch (nRecType) {
					case 1:
						// 
						{
							// Store the new ddinfo id
							EMRInfoChangedDropdown *pNewChangedDropdown = new EMRInfoChangedDropdown;
							pNewChangedDropdown->nOldDropdownID = AdoFldLong(fldOldID);
							pNewChangedDropdown->nNewDropdownID = AdoFldLong(fldNewID);
							// (z.manning 2011-04-29 10:39) - PLID 37604 - Added old data value
							pNewChangedDropdown->strOldData = AdoFldString(prsAll, "OldDropdownData", "");
							// Add it to the set for this emrdata element
							pNewChangedData->aryChangedDropdownIDs.Add(pNewChangedDropdown);
						}
						break;
					case 2:
						{
							// Store the new action id
							EMRInfoChangedAction *pNewChangedAction = new EMRInfoChangedAction;
							pNewChangedAction->nOldActionID = AdoFldLong(fldOldID);
							pNewChangedAction->nNewActionID = AdoFldLong(fldNewID);
							// Add it to the set for this emrdata element
							pNewChangedData->aryChangedActionIDs.Add(pNewChangedAction);
						}
						break;
					case 3:
						{
							// (c.haag 2008-08-18 10:52) - PLID 30724 - Problem actions
							EMRInfoChangedProblemAction cpa;
							cpa.nOldID = AdoFldLong(fldOldID);
							cpa.nNewID = AdoFldLong(fldNewID);
							pNewChangedData->aryChangedPAIDs.Add(cpa);
						}
						break;
					case 4:
						{
							// (z.manning 2009-02-12 14:24) - PLID 33058 - Table dropdown item actions
							EMRInfoChangedAction *pNewChangedAction = new EMRInfoChangedAction;
							pNewChangedAction->nOldActionID = AdoFldLong(fldOldID);
							pNewChangedAction->nNewActionID = AdoFldLong(fldNewID);
							EMRInfoChangedDropdown *pcdd = pNewChangedData->GetChangedDropdownByNewID(AdoFldLong(pflds, "SubItemNewID"));
							if(pcdd == NULL) {
								ThrowNxException("CEmrItemEntryDlg::PrepareToReassignEmrInfoItem - Could not find dropdown item when reassigning old action with ID %li", AdoFldLong(fldOldID));
							}
							pcdd->aryChangedActions.Add(pNewChangedAction);
						}
						break;
					case 5:
						{
							// (z.manning 2009-02-12 14:24) - PLID 33058 - Table dropdown item problem actions
							EMRInfoChangedProblemAction cpa;
							cpa.nOldID = AdoFldLong(fldOldID);
							cpa.nNewID = AdoFldLong(fldNewID);
							EMRInfoChangedDropdown *pcdd = pNewChangedData->GetChangedDropdownByNewID(AdoFldLong(pflds, "SubItemNewID"));
							if(pcdd == NULL) {
								ThrowNxException("CEmrItemEntryDlg::PrepareToReassignEmrInfoItem - Could not find dropdown item when reassigning old action with ID %li", AdoFldLong(fldOldID));
							}
							pcdd->aryChangedProblemActions.Add(cpa);
						}
						break;
					default:
						// We don't support any other record types (except 0 which we accounted for prior to 
						// this switch-statement
						ASSERT(FALSE);
						ThrowNxException("Unexpected record type of %li encountered!", nRecType);
						break;
					}

					// We're done with this record (regardless of what type it was) so move to the next
					prsAll->MoveNext();
				}

				// (b.cardillo 2007-07-25 15:56) - TODO: Should we really be adding these to the member variable 
				// right now?  This is what the code did before, so I'm leaving it this way for now, but if there's 
				// an exception here, doesn't that mean the member variable could end up with completely arbitrary 
				// IDs in it, so the caller could get all screwed up.  I haven't investigated this fully right now, 
				// which is why I'm not prepared to make a change to the logic, so I've created plid 26820 to look 
				// into it in the future.  The likelihood of an exception being thrown AFTER the query has returned 
				// successfully is low, so I'm not putting a pragma TODO here or even necessarily putting the pl 
				// item in scope.
				m_pChangedIDMap->aryChangedDataIDs.Add(pNewChangedData);
			}
		}

		/* PHASE 3: EMRInfoT actions

		In the following block of code, we copy records from the following tables:

		1. EmrActionsT for the info item
		2. EmrProblemActionsT for the info item
		3. EmrActionChargeDataT for the info item
		4. EmrActionsTodoDataT for the info item
		5. EmrActionsTodoAssignToT for the info item

		Returned records:

		<none>

		*** You may be wondering "Why are we not updating the change map here?" The answer is that
		we do it farther down. Look for the comment "//continue to populate" and you'll see.

		*/

		//3)  Copy any EMR actions for this whole detail, we can batch copy these.  SourceType = 3 means
		//	the actions are for the entire EMRInfo object.
		{
			//DRT 1/18/2007 - PLID 24181 - EMRActionsT now links to EMRActionChargeDataT, so we cannot batch copy any longer.
			//	We need to get a list of all actions, insert them with their corresponding ChargeAction data.
			//Additionally for speed, we'll batch the whole process.
			CString strActionSql;

			// (c.haag 2008-06-20 11:04) - PLID 30221 - We need a variable to track the new action ID
			strActionSql += "DECLARE @ActionID INT; ";

			// (z.manning 2011-01-26 15:23) - PLID 42244 - Don't copy deleted actions!
			_RecordsetPtr prsActions = CreateParamRecordset(
				"SELECT ID, DestType FROM EMRActionsT \r\n"
				"WHERE SourceID = {INT} AND SourceType = {INT} AND EmrActionsT.Deleted = 0 \r\n"
				, nOldInfoID, eaoEmrItem);
			while(!prsActions->eof) {
				long nActionID = AdoFldLong(prsActions, "ID");
				EmrActionObject eaoType = (EmrActionObject)AdoFldLong(prsActions, "DestType");

				//TES 1/30/2007 - PLID 24474 - Don't forget SpawnAsChild!
				strActionSql += FormatString("INSERT INTO EMRActionsT (SourceType, SourceID, DestType, DestID, SortOrder, Popup, SpawnAsChild) "
					"SELECT SourceType, %li, DestType, DestID, SortOrder, Popup, SpawnAsChild "
					"FROM EMRActionsT WHERE ID = %li;\r\nSET @ActionID = SCOPE_IDENTITY();\r\n", nNewID, nActionID);

				// (c.haag 2008-07-17 16:56) - PLID 30724 - Emr problem actions
				// (c.haag 2014-07-22) - PLID 62789 - Added SNOMEDCodeID
				// (s.tullis 2015-02-23 17:47) - PLID 64749 
				// (r.gonet 2015-03-10 14:48) - PLID 65013 - Added DoNotShowOnProblemPrompt.
				strActionSql += FormatString("INSERT INTO EmrProblemActionsT (EmrActionID, DefaultDescription, DefaultStatus, SpawnToSourceItem, SNOMEDCodeID, DoNotShowOnCCDA, DoNotShowOnProblemPrompt) "
					" SELECT @ActionID, DefaultDescription, DefaultStatus, SpawnToSourceItem, SNOMEDCodeID,DoNotShowOnCCDA, DoNotShowOnProblemPrompt "
					" FROM EmrProblemActionsT WHERE EmrActionID = %d AND Inactive = 0 \r\n", nActionID);

				//If the DestType is charge, then we need to copy the charge data
				if(eaoType == eaoCpt) {
					strActionSql += FormatString("INSERT INTO EMRActionChargeDataT (ActionID, Prompt, DefaultQuantity, Modifier1Number, "
						"Modifier2Number, Modifier3Number, Modifier4Number) SELECT @ActionID, Prompt, DefaultQuantity, Modifier1Number, "
						"Modifier2Number, Modifier3Number, Modifier4Number FROM EMRActionChargeDataT WHERE ActionID = %li", nActionID);
				}
				// (c.haag 2008-06-20 11:01) - PLID 30221 - Todo actions
				if(eaoType == eaoTodo) {
					strActionSql += FormatString("INSERT INTO EmrActionsTodoDataT (ActionID, RemindType, RemindInterval, DeadlineType, "
						"DeadlineInterval, Notes, Priority, Task, CategoryID) SELECT @ActionID, RemindType, RemindInterval, DeadlineType, "
						"DeadlineInterval, Notes, Priority, Task, CategoryID FROM EmrActionsTodoDataT WHERE ActionID = %li", nActionID);

					strActionSql += FormatString("INSERT INTO EmrActionsTodoAssignToT (ActionID, AssignTo) SELECT @ActionID, AssignTo "
						"FROM EmrActionsTodoAssignToT WHERE ActionID = %li", nActionID);
				}
				// (b.savon 2014-07-16 10:00) - PLID 62707 - Handle saving the new Diagnosis DestType action to EmrActionsT and EmrActionsDiagnosisDataT
				if (eaoType == eaoDiagnosis){
					strActionSql +=
						FormatString(
							R"(
							INSERT INTO EMRActionDiagnosisDataT (EmrActionID, DiagCodeID_ICD9, DiagCodeID_ICD10)
							SELECT	@ActionID, DiagCodeID_ICD9, DiagCodeID_ICD10
							FROM	EmrActionDiagnosisDataT
							WHERE	EmrActionID = %li
							)"
							,
							nActionID
						);
				}
				prsActions->MoveNext();
			}

			//Execute 'em all
			if(!strActionSql.IsEmpty()) {
				//TES 10/28/2010 - PLID 41174 - Special logging
				if(IsSystemCurrentMedicationsItem()) {
					Log_CurrentMedicationsEdit("PrepareToReassign() query 3 \r\n" + strActionSql);
				}
				ExecuteSqlStd(strActionSql);
			}
		}

		//4)  Copy EMRInfoCategoryT
		//TES 10/28/2010 - PLID 41174 - Special logging
		if(IsSystemCurrentMedicationsItem()) {
			Log_CurrentMedicationsEdit("PrepareToReassign() query 4 \r\n" + 
				FormatString("INSERT INTO EMRInfoCategoryT (EMRInfoID, EMRCategoryID) "
				"SELECT %li, EMRCategoryID FROM EMRInfoCategoryT WHERE EMRInfoID = %li", 
				nNewID, nOldInfoID));
		}
		ExecuteSql("INSERT INTO EMRInfoCategoryT (EMRInfoID, EMRCategoryID) SELECT %li, EMRCategoryID FROM EMRInfoCategoryT "
			"WHERE EMRInfoID = %li", 
			nNewID, nOldInfoID);
	

		// (c.haag 2011-03-15) - PLID 42821 - Copy common lists. I would have preferred to do all this back when the Emr Data ID's
		// are mapped but that query wasn't really meant to populate tables that are entirely unrelated to EmrDataT. Furthermore, because
		// we need the new Emr Data ID's to populate the EmrInfoCommonListItemsT, and the EmrDataT ID map is only available in memory,
		// we have to do those individually.
		//5) - EmrInfoCommonListT
		{
			CString strprsCommonLists =
				"SET NOCOUNT ON \r\n"
				"DECLARE @nError INT \r\n"
				// (c.haag 2011-03-15) - PLID 42821 - A) - Create a table variable that maps old EmrInfoCommonListT.ID's to new EmrInfoCommonListT.ID's.
				"DECLARE @tNewCommonListT TABLE (RowNum INT IDENTITY NOT NULL PRIMARY KEY, OldID INT NOT NULL, NewID INT) \r\n"
				"INSERT INTO @tNewCommonListT (OldID) \r\n"
				" SELECT ID FROM EmrInfoCommonListT WHERE EMRInfoID = {INT} \r\n"
				"SET @nError = @@ERROR IF @nError <> 0 BEGIN RAISERROR('@@ERROR was %li!', 16, 1, @nError) ROLLBACK TRAN RETURN END\r\n"
				"UPDATE @tNewCommonListT SET NewID = RowNum + COALESCE((SELECT MAX(ID) FROM EmrInfoCommonListT WITH(UPDLOCK, HOLDLOCK)), 0) \r\n"
				"SET @nError = @@ERROR IF @nError <> 0 BEGIN RAISERROR('@@ERROR was %li!', 16, 1, @nError) ROLLBACK TRAN RETURN END\r\n"

				// (c.haag 2011-03-15) - PLID 42821 - B) - Copy the contents of EmrInfoCommonListT for the old EmrInfoID to the new EmrInfoID
				// (c.haag 2011-04-11) - PLID 43234 - Also copy GroupOnPreviewPane
				"SET IDENTITY_INSERT EmrInfoCommonListT ON \r\n"
				"SET @nError = @@ERROR IF @nError <> 0 BEGIN RAISERROR('@@ERROR was %li!', 16, 1, @nError) ROLLBACK TRAN RETURN END\r\n"
				"INSERT INTO EmrInfoCommonListT (ID, EmrInfoID, Name, Color, Inactive, OrderID, GroupOnPreviewPane) \r\n"
				" SELECT NewID, {INT}, Name, Color, Inactive, OrderID, GroupOnPreviewPane \r\n"
				" FROM EmrInfoCommonListT INNER JOIN @tNewCommonListT ON ID = OldID \r\n"
				"SET @nError = @@ERROR IF @nError <> 0 BEGIN RAISERROR('@@ERROR was %li!', 16, 1, @nError) ROLLBACK TRAN RETURN END\r\n"
				"SET IDENTITY_INSERT EmrInfoCommonListT OFF \r\n"
				"SET @nError = @@ERROR IF @nError <> 0 BEGIN RAISERROR('@@ERROR was %li!', 16, 1, @nError) ROLLBACK TRAN RETURN END\r\n"

				// (c.haag 2011-03-15) - PLID 42821 - C) - Return the mapped common list ID's
				"SET NOCOUNT OFF \r\n"
				"SELECT OldID, NewID FROM @tNewCommonListT \r\n"
				;

			// This recordset returns the table variable that maps the old list ID's to the new list ID's
			_RecordsetPtr prsCommonListMap = CreateParamRecordset(strprsCommonLists,
				nOldInfoID, nNewID);
			while (!prsCommonListMap->eof)
			{
				long nOldListID = AdoFldLong(prsCommonListMap->Fields, "OldID");
				long nNewListID = AdoFldLong(prsCommonListMap->Fields, "NewID");

				// Update our changed map
				EMRInfoChangedCommonList eiccb;
				eiccb.nOldID = nOldListID;
				eiccb.nNewID = nNewListID;
				m_pChangedIDMap->aryChangedCommonListIDs.Add(eiccb);

				// Now copy the list details. First we query all of the individual items for this list, then one by
				// one we add a new item with the proper corresponding values.
				_RecordsetPtr prsCommonListDetails = CreateParamRecordset(
					"SELECT ID, EmrDataID FROM EmrInfoCommonListItemsT WHERE ListID = {INT}"
					,nOldListID);
				while (!prsCommonListDetails->eof)
				{
					// Figure out the ID's we're working with
					long nOldListItemID = AdoFldLong(prsCommonListDetails->Fields, "ID");
					long nOldEmrDataID = AdoFldLong(prsCommonListDetails->Fields, "EmrDataID");
					long nNewEmrDataID = -1;

					for (int i=0; i < m_pChangedIDMap->aryChangedDataIDs.GetSize() && -1 == nNewEmrDataID; i++) 
					{
						if (nOldEmrDataID == m_pChangedIDMap->aryChangedDataIDs[i]->nOldDataID)
						{
							nNewEmrDataID = m_pChangedIDMap->aryChangedDataIDs[i]->nNewDataID;
						}
					}
					if (-1 == nNewEmrDataID)
					{
						ThrowNxException("Could not properly map old common list item ID %d!", nOldListItemID);
					}

					// Now add the new item to data
					_RecordsetPtr prsNewListItem = CreateParamRecordset(
						"SET NOCOUNT ON \r\n"
						"DECLARE @nError INT \r\n"
						"INSERT INTO EmrInfoCommonListItemsT (ListID, EmrDataID) "
						"VALUES ({INT}, {INT}) \r\n "
						"SET @nError = @@ERROR IF @nError <> 0 BEGIN RAISERROR('@@ERROR was %li!', 16, 1, @nError) ROLLBACK TRAN RETURN END\r\n"
						"SET NOCOUNT OFF \r\n"
						"SELECT CONVERT(INT, SCOPE_IDENTITY()) AS NewID \r\n"
						,nNewListID, nNewEmrDataID
						);
					if (prsNewListItem->eof) {
						ThrowNxException("Could not fetch new common list detail id!");
					} else {
						EMRInfoChangedCommonListItem eiccbd;
						eiccbd.nOldListID = nOldListID;
						eiccbd.nNewListID = nNewListID;
						eiccbd.nOldID = nOldListItemID;
						eiccbd.nNewID = AdoFldLong(prsNewListItem->Fields, "NewID");
						eiccbd.nOldDataID = nOldEmrDataID;
						eiccbd.nNewDataID = nNewEmrDataID;
						m_pChangedIDMap->aryChangedCommonListDetailIDs.Add(eiccbd);
					}
					prsCommonListDetails->MoveNext();
				} // while (!prsCommonListDetails->eof)
				
				prsCommonListMap->MoveNext();
			} // while (!prsCommonListMap->eof)
		}

		bSaved = TRUE;

	END_TRANS_CATCH_ALL("PrepareToReassignEmrInfoItem")

	if(bSaved) {

		nNewInfoID = nNewID;

		// (j.jones 2007-07-23 18:02) - PLID 26742 - if changing medications or allergies,
		// send the new InfoID in a tablechecker
		switch ((EmrInfoSubType)m_DataSubType) {
		case eistCurrentMedicationsTable:
			CClient::RefreshTable(NetUtils::CurrentMedicationsEMRInfoID, nNewInfoID);
			break;
		case eistAllergiesTable:
			CClient::RefreshTable(NetUtils::CurrentAllergiesEMRInfoID, nNewInfoID);
			break;
		}

		//now we can update the dialog with the new IDs

		//EMRInfoID
		m_nID = nNewID;

		//EMRDataIDs
		// (a.walling 2007-11-05 16:08) - PLID 27980 - VS2008 - for() loops
		int i = 0;

		{
			// (c.haag 2011-10-28) - PLID 46172 - To avoid some O(n^2) traversals in the changed ID map
			// loop, we will create map versions of m_aryDataElements and m_aryCurDataElements.
			CMap<long,long,CEmrInfoDataElement*,CEmrInfoDataElement*> mapDataElements;
			CMap<long,long,CEmrInfoDataElement*,CEmrInfoDataElement*> mapCurDataElements;

			// (d.thompson 2011-11-10) - PLID 46386 - By pre-allocating the map size (we know exactly how many elements will be
			//	in it), we can shave a lot of time off the internal memory growth routines, speeding up the loops below.
			if(m_aryDataElements.GetSize() > 0) {
				mapDataElements.InitHashTable(m_aryDataElements.GetSize());
			}
			if(m_aryCurDataElements.GetSize() > 0) {
				mapCurDataElements.InitHashTable(m_aryCurDataElements.GetSize());
			}

			for (i=0; i < m_aryDataElements.GetSize(); i++) {
				CEmrInfoDataElement *peide = m_aryDataElements.GetAt(i);
				mapDataElements[ peide->m_nID ] = peide;
			}
			for (i=0; i < m_aryCurDataElements.GetSize(); i++) {
				CEmrInfoDataElement *peide = m_aryCurDataElements.GetAt(i);
				mapCurDataElements[ peide->m_nID ] = peide;
			}

			// (d.thompson 2011-11-10) - PLID 46386 - This loop was doing 2 datalist FindByColumn searches.  While a fairly fast function, 
			//	we should not be calling it thousands of times in a loop (like in a large medication item), as we're doing entire 
			//	iterations of the datalist each time.  Instead, let's pull out a map of IDs to row pointers.
			CMap<long, long&, NXDATALIST2Lib::IRowSettingsPtr, NXDATALIST2Lib::IRowSettingsPtr> mapIDToDataElementRow;
			{
				NXDATALIST2Lib::IRowSettingsPtr pRow = m_pdlDataElementList->GetFirstRow();
				while(pRow != NULL)
				{
					long nDataID = VarLong(pRow->GetValue(delcID));
					//Map DataID -> Row pointer
					mapIDToDataElementRow.SetAt(nDataID, pRow);

					pRow = pRow->GetNextRow();
				}
			}

			CMap<long, long&, NXDATALIST2Lib::IRowSettingsPtr, NXDATALIST2Lib::IRowSettingsPtr> mapIDToColumnDataElementRow;
			{
				NXDATALIST2Lib::IRowSettingsPtr pRow = m_pdlColumnDataElementList->GetFirstRow();
				while(pRow != NULL)
				{
					long nDataID = VarLong(pRow->GetValue(cdelcID));
					//Map DataID -> Row pointer
					mapIDToColumnDataElementRow.SetAt(nDataID, pRow);

					pRow = pRow->GetNextRow();
				}
			}

			CEmrInfoDataElement *peide = NULL;

			for(i=0; i<m_pChangedIDMap->aryChangedDataIDs.GetSize(); i++) {

				EMRInfoChangedData *pChangedData = m_pChangedIDMap->aryChangedDataIDs.GetAt(i);

				long nOldDataID = pChangedData->nOldDataID;
				long nNewDataID = pChangedData->nNewDataID;

				//update the arrays
				// (a.walling 2007-11-05 16:08) - PLID 27980 - VS2008 - for() loops
				long j = 0;

				BOOL bFound;

				if (mapDataElements.Lookup(nOldDataID, peide)) {
					peide->m_nID = nNewDataID;

					// (j.jones 2012-09-21 14:37) - PLID 52316 - find the ParentLabelID too
					if(peide->m_nParentLabelID != -1) {
						CEmrInfoDataElement *peideParentLabelID = NULL;
						if (mapDataElements.Lookup(peide->m_nParentLabelID, peideParentLabelID)) {
							peide->m_nParentLabelID = peideParentLabelID->m_nID;
						}
					}
				}

				// (j.jones 2012-10-02 17:29) - PLID 52316 - re-map ParentLabelIDs
				for (j=0; j<m_aryDataElements.GetSize(); j++) {
					CEmrInfoDataElement *peideRow = m_aryDataElements.GetAt(j);
					if (peideRow->m_nParentLabelID == nOldDataID) {
						peideRow->m_nParentLabelID = nNewDataID;
					}
				}

				bFound = FALSE;
				for (j=0; j<m_aryColumnDataElements.GetSize() && !bFound; j++) {
					peide = m_aryColumnDataElements.GetAt(j);
					if (peide->m_nID == nOldDataID) {
						peide->m_nID = nNewDataID;
						bFound = TRUE;
					}
				}
				if (mapCurDataElements.Lookup(nOldDataID, peide)) {
					peide->m_nID = nNewDataID;

					// (j.jones 2012-09-21 14:37) - PLID 52316 - find the ParentLabelID too
					if(peide->m_nParentLabelID != -1) {
						CEmrInfoDataElement *peideParentLabelID = NULL;
						if (mapCurDataElements.Lookup(peide->m_nParentLabelID, peideParentLabelID)) {
							peide->m_nParentLabelID = peideParentLabelID->m_nID;
						}
					}
				}

				// (j.jones 2012-10-02 17:29) - PLID 52316 - re-map ParentLabelIDs
				for (j=0; j<m_aryCurDataElements.GetSize(); j++) {
					CEmrInfoDataElement *peideRow = m_aryCurDataElements.GetAt(j);
					if (peideRow->m_nParentLabelID == nOldDataID) {
						peideRow->m_nParentLabelID = nNewDataID;
					}
				}

				bFound = FALSE;
				for (j=0; j<m_aryCurColumnDataElements.GetSize() && !bFound; j++) {
					peide = m_aryCurColumnDataElements.GetAt(j);
					if (peide->m_nID == nOldDataID) {
						peide->m_nID = nNewDataID;
						bFound = TRUE;
					}
				}
				//check for deleted items
				bFound = FALSE;
				for (j=0; j<m_aryCurDeletedDataElements.GetSize() && !bFound; j++) {
					peide = m_aryCurDeletedDataElements.GetAt(j);
					if (peide->m_nID == nOldDataID) {
						peide->m_nID = nNewDataID;
						bFound = TRUE;
					}
				}


				// (d.thompson 2011-11-10) - PLID 46386 - Instead of doing datalist FindByColumn here, we mapped
				//	all the IDs to their rows above, and will just lookup from that map.
				//a)  Try to find the old data ID in the data element list
				NXDATALIST2Lib::IRowSettingsPtr pRow = NULL;
				if(mapIDToDataElementRow.Lookup(nOldDataID, pRow)) {
					//found it, so update the row to have the new ID
					pRow->PutValue(delcID, (long)nNewDataID);
				}
				//b)  Now try the same in the column list
				if(mapIDToColumnDataElementRow.Lookup(nOldDataID, pRow)) {
					//found it, so update the row to have the new ID
					pRow->PutValue(cdelcID, (long)nNewDataID);
				}

				// (b.cardillo 2007-08-01 12:17) - PLID 26826 - Removed a query that was being called here and whose 
				// results were themselves being looped through.  It was causing a significant performance hit so I 
				// moved the logic up to the big parameterized query above.  The output is now combined in the one 
				// returned recordset, and pulled out by the same technique the other data was being extracted in a 
				// quick c++ loop.
			}
		}

		//Action IDs

		// (d.thompson 2011-11-10) - PLID 46386 - These queries should be batched together and parameterized, not separate trips
		//	to the database.
		//continue to populate our action ID arrays for the info item itself, since we had non-committed Identities before
		_RecordsetPtr rsActions = CreateParamRecordset(
			"SELECT EMRActionsT.ID AS NewID, OldActionsT.ID AS OldID "
			"FROM EMRActionsT "
			"INNER JOIN (SELECT * FROM EMRActionsT WHERE SourceType = 3 AND SourceID = {INT}) AS OldActionsT "
			"ON EMRActionsT.DestType = OldActionsT.DestType "
			"AND EMRActionsT.DestID = OldActionsT.DestID "
			"AND EMRActionsT.SourceType = OldActionsT.SourceType "
			"AND EMRActionsT.Popup = OldActionsT.Popup "
			"WHERE EMRActionsT.SourceType = 3 AND EMRActionsT.SourceID = {INT};\r\n"

			//rsProblems
			"SELECT EMRProblemActionsT.ID AS NewID, OldProblemActionsT.ID AS OldID "
			"FROM EmrProblemActionsT "
			"INNER JOIN (SELECT * FROM EMRProblemActionsT WHERE EmrActionID IN (SELECT ID FROM EMRActionsT WHERE SourceType = 3 AND SourceID = {INT})) AS OldProblemActionsT "
			"ON EmrProblemActionsT.DefaultDescription = OldProblemActionsT.DefaultDescription "
			"AND EmrProblemActionsT.DefaultStatus = OldProblemActionsT.DefaultStatus "
			"AND EmrProblemActionsT.SpawnToSourceItem = OldProblemActionsT.SpawnToSourceItem "
			"AND EmrProblemActionsT.Inactive = 0 "
			"WHERE EmrProblemActionsT.EmrActionID IN (SELECT ID FROM EMRActionsT WHERE EMRActionsT.SourceType = 3 AND EMRActionsT.SourceID = {INT})\r\n"

			, nOldInfoID, nNewInfoID
			, nOldInfoID, nNewInfoID);
		while(!rsActions->eof) {

			EMRInfoChangedAction *pNewChangedAction = new EMRInfoChangedAction;

			pNewChangedAction->nOldActionID = AdoFldLong(rsActions, "OldID",-1);
			pNewChangedAction->nNewActionID = AdoFldLong(rsActions, "NewID",-1);

			//store the new number
			m_pChangedIDMap->aryChangedActionIDs.Add(pNewChangedAction);

			rsActions->MoveNext();
		}

		// (c.haag 2008-08-18 10:57) - PLID 30724 - Also problem actions
		_RecordsetPtr rsProblemActions = rsActions->NextRecordset(NULL);
		while(!rsProblemActions->eof) {

			EMRInfoChangedProblemAction cpa;
			cpa.nOldID = AdoFldLong(rsProblemActions, "OldID",-1);
			cpa.nNewID = AdoFldLong(rsProblemActions, "NewID",-1);

			//store the new number
			m_pChangedIDMap->aryChangedInfoPAIDs.Add(cpa);

			rsProblemActions->MoveNext();
		}
		rsProblemActions->Close();

		// (c.haag 2008-08-18 11:23) - PLID 30724 - This legacy block of code goes through all
		// action objects in memory, and updates their ID's. I've broken the code up into three
		// functions, and added support for problem action renumbering as well.
		UpdateChangedInfoActionIDs();
		UpdateChangedDataActionIDs();
		UpdateChangedHotspotActionIDs();
		// (c.haag 2011-03-15) - PLID 42821
		UpdateChangedCommonListIDs();
	}

	//TES 10/28/2010 - PLID 41174 - Special logging
	if(IsSystemCurrentMedicationsItem()) {
		Log_CurrentMedicationsEdit("PrepareToReassign() returning " + CString(bSaved?"TRUE":"FALSE"));
	}
	return bSaved;
}

// (c.haag 2008-08-18 11:26) - PLID 30724 - Percolates ID changes from PrepareToReassignEmrInfoItem (legacy code)
void CEmrItemEntryDlg::UpdateChangedInfoActionIDs()
{
	int i;
	for(i=0; i<m_pChangedIDMap->aryChangedActionIDs.GetSize(); i++) {

		EMRInfoChangedAction *pChangedAction = m_pChangedIDMap->aryChangedActionIDs.GetAt(i);

		long nOldActionID = pChangedAction->nOldActionID;
		long nNewActionID = pChangedAction->nNewActionID;

		// (a.walling 2007-11-05 16:08) - PLID 27980 - VS2008 - for() loops
		long j = 0;

		BOOL bFound = FALSE;
		for (j=0; j<m_arCurActions.GetSize() && !bFound; j++) {
			EmrAction ea = m_arCurActions.GetAt(j);
			if (ea.nID == nOldActionID) {
				ea.nID = nNewActionID;
				UpdateChangedProblemActionIDs(ea, m_pChangedIDMap->aryChangedInfoPAIDs);
				m_arCurActions.SetAt(j, ea);
				bFound = TRUE;
			}
		}
		bFound = FALSE;
		for (j=0; j<m_arActions.GetSize() && !bFound; j++) {
			EmrAction ea = m_arActions.GetAt(j);
			if (ea.nID == nOldActionID) {
				ea.nID = nNewActionID;
				UpdateChangedProblemActionIDs(ea, m_pChangedIDMap->aryChangedInfoPAIDs);
				m_arActions.SetAt(j, ea);
				bFound = TRUE;
			}
		}
	}
}

// (c.haag 2008-08-18 11:26) - PLID 30724 - Percolates ID changes from PrepareToReassignEmrInfoItem (legacy code)
void CEmrItemEntryDlg::UpdateChangedDataActionIDs()
{
	for(int i=0; i<m_pChangedIDMap->aryChangedDataIDs.GetSize(); i++) {

		EMRInfoChangedData *pChangedData = m_pChangedIDMap->aryChangedDataIDs.GetAt(i);

		// (a.walling 2007-11-05 16:08) - PLID 27980 - VS2008 - for() loops
		long j = 0;

		//data Action IDs			
		for(int a=0; a<pChangedData->aryChangedActionIDs.GetSize(); a++) {

			EMRInfoChangedAction *pChangedAction = pChangedData->aryChangedActionIDs.GetAt(a);

			long nOldActionID = pChangedAction->nOldActionID;
			long nNewActionID = pChangedAction->nNewActionID;

			// (a.walling 2007-11-05 16:08) - PLID 27980 - VS2008 - for() loops
			int j = 0;

			BOOL bFound = FALSE;
			for (j=0; j<m_aryCurDataElements.GetSize() && !bFound; j++) {
				CEmrInfoDataElement *peide = m_aryCurDataElements.GetAt(j);
				for (long k=0; k<peide->m_arActions.GetSize() && !bFound; k++) {
					EmrAction ea = peide->m_arActions.GetAt(k);
					if (ea.nID == nOldActionID) {
						ea.nID = nNewActionID;
						UpdateChangedProblemActionIDs(ea, pChangedData->aryChangedPAIDs);
						peide->m_arActions.SetAt(k, ea);
						bFound = TRUE;
					}
				}
			}
			bFound = FALSE;
			for (j=0; j<m_aryDataElements.GetSize() && !bFound; j++) {
				CEmrInfoDataElement *peide = m_aryDataElements.GetAt(j);
				for (long k=0; k<peide->m_arActions.GetSize() && !bFound; k++) {
					EmrAction ea = peide->m_arActions.GetAt(k);
					if (ea.nID == nOldActionID) {
						ea.nID = nNewActionID;
						UpdateChangedProblemActionIDs(ea, pChangedData->aryChangedPAIDs);
						peide->m_arActions.SetAt(k, ea);
						bFound = TRUE;
					}
				}				
			}
		}

		//Table Dropdown IDs

		for(int d=0; d<pChangedData->aryChangedDropdownIDs.GetSize(); d++) {

			EMRInfoChangedDropdown *pChangedDropdown = pChangedData->aryChangedDropdownIDs.GetAt(d);

			long nOldDropdownID = pChangedDropdown->nOldDropdownID;
			long nNewDropdownID = pChangedDropdown->nNewDropdownID;

			for (j=0; j<m_aryCurColumnDataElements.GetSize(); j++) {
				CEmrInfoDataElement *peide = m_aryCurColumnDataElements.GetAt(j);
				// (a.walling 2014-06-30 10:21) - PLID 62497
				if (auto * pddi = peide->m_arypEMRDropDownList.FindDropdownElement(nOldDropdownID)) {
					peide->m_arypEMRDropDownList.UpdateElementID(pddi, nNewDropdownID);
					// (z.manning 2009-02-12 15:13) - PLID 33058 - Need to update dropdown item actions.
					UpdateChangedDropdownActionIDs(pChangedDropdown, pddi);
					break;
				}
			}
			for (j=0; j<m_aryColumnDataElements.GetSize(); j++) {
				CEmrInfoDataElement *peide = m_aryColumnDataElements.GetAt(j);
				// (a.walling 2014-06-30 10:21) - PLID 62497
				if (auto * pddi = peide->m_arypEMRDropDownList.FindDropdownElement(nOldDropdownID)) {
					peide->m_arypEMRDropDownList.UpdateElementID(pddi, nNewDropdownID);						
					// (z.manning 2009-02-12 15:13) - PLID 33058 - Need to update dropdown item actions.
					UpdateChangedDropdownActionIDs(pChangedDropdown, pddi);
					break;
				}				
			}
			//and the deleted items
			for (j=0; j<m_aryCurColumnDataElements.GetSize(); j++) {
				CEmrInfoDataElement *peide = m_aryCurColumnDataElements.GetAt(j);
				// (a.walling 2014-06-30 10:21) - PLID 62497
				if (auto * pddi = peide->m_arypEMRDropDownDeleted.FindDropdownElement(nOldDropdownID)) {
					peide->m_arypEMRDropDownDeleted.UpdateElementID(pddi, nNewDropdownID);
					// (z.manning 2009-02-12 15:13) - PLID 33058 - Need to update dropdown item actions.
					UpdateChangedDropdownActionIDs(pChangedDropdown, pddi);
					break;
				}
			}
			for (j=0; j<m_aryColumnDataElements.GetSize(); j++) {
				CEmrInfoDataElement *peide = m_aryColumnDataElements.GetAt(j);
				// (a.walling 2014-06-30 10:21) - PLID 62497
				if (auto * pddi = peide->m_arypEMRDropDownDeleted.FindDropdownElement(nOldDropdownID)) {
					peide->m_arypEMRDropDownDeleted.UpdateElementID(pddi, nNewDropdownID);
					// (z.manning 2009-02-12 15:13) - PLID 33058 - Need to update dropdown item actions.
					UpdateChangedDropdownActionIDs(pChangedDropdown, pddi);
					break;
				}
			}
		}
	}
}

// (z.manning 2009-02-12 14:51) - PLID 33058
void CEmrItemEntryDlg::UpdateChangedDropdownActionIDs(EMRInfoChangedDropdown *pChangedDropdown, CEmrTableDropDownItem *pddi)
{
	for(int nChangedActionIndex = 0; nChangedActionIndex < pChangedDropdown->aryChangedActions.GetSize(); nChangedActionIndex++) {
		EMRInfoChangedAction *pChangedAction = pChangedDropdown->aryChangedActions.GetAt(nChangedActionIndex);
		for(int nActionIndex = 0; nActionIndex < pddi->aryActions.GetSize(); nActionIndex++) {
			EmrAction ea = pddi->aryActions.GetAt(nActionIndex);
			if(ea.nID == pChangedAction->nOldActionID) {
				ea.nID = pChangedAction->nNewActionID;
				UpdateChangedProblemActionIDs(ea, pChangedDropdown->aryChangedProblemActions);
				pddi->aryActions.SetAt(nActionIndex, ea);
			}
		}
	}
}

// (c.haag 2008-08-18 11:26) - PLID 30724 - Percolates ID changes from PrepareToReassignEmrInfoItem (legacy code)
void CEmrItemEntryDlg::UpdateChangedHotspotActionIDs()
{
	//DRT 1/24/2008 - PLID 28602 - Now take the hotspots that changed and fix them
	for(int i = 0; i < m_pChangedIDMap->aryChangedHotSpotIDs.GetSize(); i++) {
		EMRInfoChangedHotSpot *pChanged = m_pChangedIDMap->aryChangedHotSpotIDs.GetAt(i);

		long nOldID = pChanged->nOldHotSpotID;
		long nNewID = pChanged->nNewHotSpotID;

		//Find the hotspot for this old ID and change it.  We need only search in 'last saved', because
		//	it contains both 'removed' and 'changed', and 'new' won't have IDs to change anyways.
		int j = 0;
		CEMRHotSpot *pSpot = NULL;
		for(j = 0; j < m_aryLastSavedHotSpots.GetSize() && pSpot == NULL; j++) {
			CEMRHotSpot *pSpotTmp = m_aryLastSavedHotSpots.GetAt(j);
			if(pSpotTmp->GetID() == nOldID) {
				//Found it!  Now change it
				pSpotTmp->SetID(nNewID);
				pSpot = pSpotTmp;
			}
		}

		//Now fix any actions if we found the spot
		if(pSpot) {
			for(j = 0; j < pChanged->aryChangedActionIDs.GetSize(); j++) {
				EMRInfoChangedAction *pAction = pChanged->aryChangedActionIDs.GetAt(j);

				//Search existing hotspot for this action
				bool bDone = false;
				int k = 0;
				for(k = 0; k < pSpot->GetCurrentActionArray()->GetSize() && !bDone; k++) {
					if(pSpot->GetCurrentActionArray()->GetAt(k).nID == pAction->nOldActionID) {
						//Found it
						EmrAction ea = pSpot->GetCurrentActionArray()->GetAt(k);
						ea.nID = pAction->nNewActionID;
						UpdateChangedProblemActionIDs(ea, pChanged->aryChangedPAIDs);

						pSpot->GetCurrentActionArray()->SetAt(k, ea);
						bDone = true;
					}
				}
				//Fix the "original" action array too
				bDone = false;
				for(k = 0; k < pSpot->GetOriginalActionArray()->GetSize() && !bDone; k++) {
					if(pSpot->GetOriginalActionArray()->GetAt(k).nID == pAction->nOldActionID) {
						//Found it
						EmrAction ea = pSpot->GetOriginalActionArray()->GetAt(k);
						ea.nID = pAction->nNewActionID;
						UpdateChangedProblemActionIDs(ea, pChanged->aryChangedPAIDs);

						pSpot->GetOriginalActionArray()->SetAt(k, ea);
						bDone = true;
					}
				}
			}


		} // if(pSpot)
	}
}

// (c.haag 2008-08-18 11:50) - PLID 30724 - When PrepareToReassignEmrInfoItem is called, this function will percolate
// the newly generated problem action ID's to the given action 
void CEmrItemEntryDlg::UpdateChangedProblemActionIDs(EmrAction& ea, const CArray<EMRInfoChangedProblemAction,EMRInfoChangedProblemAction&>& aChangedIDs)
{
	for (int i=0; i < aChangedIDs.GetSize(); i++) {
		EMRInfoChangedProblemAction cpa = aChangedIDs[i];
		// (a.walling 2014-07-01 15:28) - PLID 62697
		for (EmrProblemAction& epa : ea.aProblemActions) {
			if (epa.nID == cpa.nOldID) {
				epa.nID = cpa.nNewID;
				break;
			}
		}
	}
}

// (c.haag 2011-03-15) - PLID 42821 - Update the internal ID's of the custom buttons and their data
void CEmrItemEntryDlg::UpdateChangedCommonListIDs()
{
	// Update the ID's in our unsaved changes
	m_CommonListCollection.UpdateIDs(m_pChangedIDMap);
	// Update the ID's in our saved changes too; they also used to be the same item
	m_SavedCommonListCollection.UpdateIDs(m_pChangedIDMap);
}

BOOL CEmrItemEntryDlg::ReassignEmrInfoItem(long nOldInfoID, long nNewInfoID)
{
	// (a.walling 2011-01-27 13:34) - PLID 34813 - Ensured Rollback tran and Return for RAISERROR

	//Now do the deed of reassigning all this stuff
	BOOL bSaved = FALSE;

	//PrepareToReassignEmrInfoItem() stored all the new IDs in m_pChangedIDMap,
	//so now we must use that data to assign the new item
	if(!m_pChangedIDMap) {
		ASSERT(FALSE);
		AfxThrowNxException("CEmrItemEntryDlg::ReassignEmrInfoItem - m_pChangedIDMap is NULL!");
	}
	
	BEGIN_TRANS("ReassignEmrInfoItem")

		// (b.cardillo 2007-08-10 15:40) - PLID 26826 - For vastly improved speed, we now run the whole thing in one 
		// set-based ad-hoc proc.  Before we did it in a single batch, but the sql statement was massive because it 
		// was a concatenation of a loop of loops of individual statements, sometimes numbering in the thousands, 
		// resulting in a unique sql string that could be on the order of megabytes in size.  Besides taking a long 
		// time to run such an inefficient statement on the server, we were actually taking a hit just generating the 
		// string!  So now we very quickly generate two xml tables and pass them in as parameters to the static sql 
		// statement.  The first time the statement is run it takes about 2 seconds for sql to process it and come up 
		// with the execution plan, but then on subsequent executions it takes less than 100 ms for most situations.

		//1) Update all uses of EMRDataT

		long nMapSize = m_pChangedIDMap->aryChangedDataIDs.GetSize();
		long nDropdownCount;
		CString strChangedDataIDXML;
		{
			// Calculate the maximum size of the xml string containing two IDs per node, plus the root tag and its closing:
			//  <ROOT><P O="2147483648" N="2147483648" />...</ROOT>
			//  6 + 35*count + 7
			// So if there are, say, 1000 data elements, then the maximum string size would be 35,013.  So the maximum number 
			// of data elements we can support would be 61,356,675, because that would put us over 2 GB for the string.  Way 
			// before we would hit that limit, we would get a memory allocation exception, so all we need to do is make sure 
			// our calculation doesn't go larger than long max.
			if (nMapSize >= 61356675) {
				// Our calculation won't work
				ThrowNxException("This EMR Item has too many data elements, %li, to be placed safely in an XML string!", nMapSize);
			}
			long nMaxStringLen = 6 + 35 * nMapSize + 7;
			LPTSTR pstr = strChangedDataIDXML.GetBuffer(nMaxStringLen);
			LPCTSTR pstrOrig = pstr;
			pstr += sprintf(pstr, "<ROOT>");
			nDropdownCount = 0;
			for(int i=0; i<nMapSize; i++) {
				EMRInfoChangedData *pChangedData = m_pChangedIDMap->aryChangedDataIDs.GetAt(i);
				pstr += sprintf(pstr, "<P O=\"%li\" N=\"%li\" />", pChangedData->nOldDataID, pChangedData->nNewDataID);
				nDropdownCount += pChangedData->aryChangedDropdownIDs.GetSize();
			}
			pstr += sprintf(pstr, "</ROOT>");
			strChangedDataIDXML.ReleaseBuffer(pstr - pstrOrig);
		}

		CString strChangeDropdownIDXML;
		{
			// Calculate the maximum size of the xml string containing two IDs per node, plus the root tag and its closing:
			//  <ROOT><P D="2147483648" O="2147483648" N="2147483648" />...</ROOT>
			//  6 + 35*count + 7
			// So if there are, say, 1000 data elements, then the maximum string size would be 35,013.  So the maximum number 
			// of data elements we can support would be 42,949,672, because that would put us over 2 GB for the string.  Way 
			// before we would hit that limit, we would get a memory allocation exception, so all we need to do is make sure 
			// our calculation doesn't go larger than long max.
			if (nMapSize >= 42949672) {
				// Our calculation won't work
				ThrowNxException("This EMR Item has too many data elements, %li, to be placed safely in an XML string!", nMapSize);
			}
			long nMaxStringLen = 6 + 50 * nDropdownCount + 7;
			LPTSTR pstr = strChangeDropdownIDXML.GetBuffer(nMaxStringLen);
			LPCTSTR pstrOrig = pstr;
			pstr += sprintf(pstr, "<ROOT>");
			for(int i=0; i<nMapSize; i++) {
				EMRInfoChangedData *pChangedData = m_pChangedIDMap->aryChangedDataIDs.GetAt(i);
				for(int j=0, nDDSize=pChangedData->aryChangedDropdownIDs.GetSize(); j<nDDSize; j++) {
					EMRInfoChangedDropdown *pChangedDropdown = pChangedData->aryChangedDropdownIDs.GetAt(j);
					pstr += sprintf(pstr, "<P D=\"%li\" O=\"%li\" N=\"%li\" />", pChangedData->nOldDataID, pChangedDropdown->nOldDropdownID, pChangedDropdown->nNewDropdownID);
				}
			}
			pstr += sprintf(pstr, "</ROOT>");
			strChangeDropdownIDXML.ReleaseBuffer(pstr - pstrOrig);
		}

		//DRT 1/30/2008 - PLID 28602 - We need to handle image hotspots too
		long nHotSpotMapSize = m_pChangedIDMap->aryChangedHotSpotIDs.GetSize();
		CString strChangedHotSpotIDXML;
		{
			//Calculate the max size of the xml string.  There are 2 IDs per node.
			//	<ROOT><P O="2147483648" N="2147483648" />...</ROOT>
			if(nHotSpotMapSize >= 61356675) {	//text is the same as for data IDs
				ThrowNxException("This EMR Item has too many hot spots, %li, to be placed safely in an XML string!", nHotSpotMapSize);
			}

			long nMaxStringLen = 6 + 35 * nHotSpotMapSize + 7;
			LPTSTR pstr = strChangedHotSpotIDXML.GetBuffer(nMaxStringLen);
			LPCTSTR pstrOrig = pstr;
			pstr += sprintf(pstr, "<ROOT>");
			for(int i = 0; i < nHotSpotMapSize; i++) {
				EMRInfoChangedHotSpot *pChangedSpot = m_pChangedIDMap->aryChangedHotSpotIDs.GetAt(i);
				pstr += sprintf(pstr, "<P O=\"%li\" N=\"%li\" />", pChangedSpot->nOldHotSpotID, pChangedSpot->nNewHotSpotID);
			}
			pstr += sprintf(pstr, "</ROOT>");
			strChangedHotSpotIDXML.ReleaseBuffer(pstr - pstrOrig);
		}


		// Add the rows from the XML into our temp table
		//TES 10/28/2010 - PLID 41174 - Special logging
		if(IsSystemCurrentMedicationsItem()) {
			Log_CurrentMedicationsEdit("ReassignEmrInfoItem() query 1 \r\n"
				"SET NOCOUNT ON \r\n"

				"DECLARE @nError INT \r\n"
				
				// Create the table of all the changed data ids
				"DECLARE @tDataIDs TABLE (RowNum INT IDENTITY NOT NULL PRIMARY KEY, OldDataID INT NOT NULL, NewDataID INT NOT NULL) \r\n"
				"DECLARE @hDoc AS INT \r\n"
				"EXEC sp_xml_preparedocument @hDoc OUTPUT, {STRING} \r\n"
				"SET @nError = @@ERROR IF @nError <> 0 BEGIN RAISERROR('@@ERROR was %li!', 16, 1, @nError) ROLLBACK TRAN RETURN END\r\n"
				"INSERT INTO @tDataIDs (OldDataID, NewDataID) \r\n"
				" SELECT OldDataID, NewDataID FROM OPENXML(@hDoc, '/ROOT/P') WITH (OldDataID INT '@O', NewDataID INT '@N') \r\n"
				"SET @nError = @@ERROR IF @nError <> 0 BEGIN RAISERROR('@@ERROR was %li!', 16, 1, @nError) ROLLBACK TRAN RETURN END\r\n"
				"EXEC sp_xml_removedocument @hDoc \r\n"
				"SET @nError = @@ERROR IF @nError <> 0 BEGIN RAISERROR('@@ERROR was %li!', 16, 1, @nError) ROLLBACK TRAN RETURN END\r\n"

				// Create the table of all the changed dropdown ids
				"DECLARE @tDropdownT TABLE (RowNum INT IDENTITY NOT NULL PRIMARY KEY, OldDataID INT NOT NULL, OldDropdownID INT NOT NULL, NewDropdownID INT NOT NULL) \r\n"
				"EXEC sp_xml_preparedocument @hDoc OUTPUT, {STRING} \r\n"
				"SET @nError = @@ERROR IF @nError <> 0 BEGIN RAISERROR('@@ERROR was %li!', 16, 1, @nError) ROLLBACK TRAN RETURN END\r\n"
				"INSERT INTO @tDropdownT (OldDataID, OldDropdownID, NewDropdownID) \r\n"
				" SELECT OldDataID, OldDropdownID, NewDropdownID FROM OPENXML(@hDoc, '/ROOT/P') WITH (OldDataID INT '@D', OldDropdownID INT '@O', NewDropdownID INT '@N') \r\n"
				"SET @nError = @@ERROR IF @nError <> 0 BEGIN RAISERROR('@@ERROR was %li!', 16, 1, @nError) ROLLBACK TRAN RETURN END\r\n"
				"EXEC sp_xml_removedocument @hDoc \r\n"
				"SET @nError = @@ERROR IF @nError <> 0 BEGIN RAISERROR('@@ERROR was %li!', 16, 1, @nError) ROLLBACK TRAN RETURN END\r\n"

				//DRT 1/30/2008 - PLID 28602 - Create the table of all changed hotspot ids
				"DECLARE @tHotSpotIDs TABLE (RowNum INT IDENTITY NOT NULL PRIMARY KEY, OldHotSpotID INT NOT NULL, NewHotSpotID INT NOT NULL) \r\n"
				"EXEC sp_xml_preparedocument @hDoc OUTPUT, {STRING} \r\n"
				"SET @nError = @@ERROR IF @nError <> 0 BEGIN RAISERROR('@@ERROR was %li!', 16, 1, @nError) ROLLBACK TRAN RETURN END\r\n"
				"INSERT INTO @tHotSpotIDs (OldHotSpotID, NewHotSpotID) \r\n"
				"  SELECT OldHotSpotID, NewHotSpotID FROM OPENXML(@hDoc, '/ROOT/P') WITH (OldHotSpotID INT '@O', NewHotSpotID INT '@N') \r\n"
				"SET @nError = @@ERROR IF @nError <> 0 BEGIN RAISERROR('@@ERROR was %li!', 16, 1, @nError) ROLLBACK TRAN RETURN END\r\n"
				"EXEC sp_xml_removedocument @hDoc \r\n"
				"SET @nError = @@ERROR IF @nError <> 0 BEGIN RAISERROR('@@ERROR was %li!', 16, 1, @nError) ROLLBACK TRAN RETURN END\r\n"


				"DECLARE @nCalledFromDetailID INT \r\n"
				"SET @nCalledFromDetailID = {INT} \r\n"
				"SET @nError = @@ERROR IF @nError <> 0 BEGIN RAISERROR('@@ERROR was %li!', 16, 1, @nError) ROLLBACK TRAN RETURN END\r\n"

				"DECLARE @tDeleted TABLE (OldDataID INT NOT NULL) \r\n"
				"INSERT INTO @tDeleted (OldDataID) SELECT OldDataID FROM @tDataIDs WHERE NewDataID NOT IN (SELECT A.ID FROM EMRDataT A) \r\n"
				"SET @nError = @@ERROR IF @nError <> 0 BEGIN RAISERROR('@@ERROR was %li!', 16, 1, @nError) ROLLBACK TRAN RETURN END\r\n"

				//DRT 1/30/2008 - PLID 28602 - Create the table of all deleted hotspot ids
				"DECLARE @tDeletedSpots TABLE (OldHotSpotID INT NOT NULL) \r\n"
				"INSERT INTO @tDeletedSpots (OldHotSpotID) SELECT OldHotSpotID FROM @tHotSpotIDs WHERE NewHotSpotID NOT IN (SELECT A.ID FROM EMRImageHotSpotsT A) \r\n"
				"SET @nError = @@ERROR IF @nError <> 0 BEGIN RAISERROR('@@ERROR was %li!', 16, 1, @nError) ROLLBACK TRAN RETURN END\r\n"
				
				// Save time by only running the deletion queries if there is anything in the @tDeleted table
				"IF (EXISTS (SELECT * FROM @tDeleted)) BEGIN \r\n"

				//*
				// Delete from all appropriate tables where the new data id doesn't exist because the user deleted it
				// (j.jones 2006-09-06 17:43) - PLID 22427 - required when deletions occurred
				"DELETE FROM EmrTemplateSelectT WHERE EmrDataID IN (SELECT OldDataID FROM @tDeleted) \r\n"
				"SET @nError = @@ERROR IF @nError <> 0 BEGIN RAISERROR('@@ERROR was %li!', 16, 1, @nError) ROLLBACK TRAN RETURN END\r\n"
				"DELETE FROM EMRTemplateTableColumnWidthsT WHERE EMRDataID_Y IN (SELECT OldDataID FROM @tDeleted) \r\n"
				"SET @nError = @@ERROR IF @nError <> 0 BEGIN RAISERROR('@@ERROR was %li!', 16, 1, @nError) ROLLBACK TRAN RETURN END\r\n"
				// (c.haag 2008-10-22 15:08) - PLID 31708 - EMRDataID_X
				"DELETE FROM EMRTemplateTableColumnWidthsT WHERE EMRDataID_X IN (SELECT OldDataID FROM @tDeleted) \r\n"
				"SET @nError = @@ERROR IF @nError <> 0 BEGIN RAISERROR('@@ERROR was %li!', 16, 1, @nError) ROLLBACK TRAN RETURN END\r\n"
				//
				"DELETE FROM EmrTemplateTableDefaultsT WHERE EMRDataID_X IN (SELECT OldDataID FROM @tDeleted) \r\n"
				"                                         OR EMRDataID_Y IN (SELECT OldDataID FROM @tDeleted) \r\n"
				"SET @nError = @@ERROR IF @nError <> 0 BEGIN RAISERROR('@@ERROR was %li!', 16, 1, @nError) ROLLBACK TRAN RETURN END\r\n"
					
				// Include only those data elements from the one EMN detail that we're editing now (if we're editing one)
				// (c.haag 2008-10-22 15:33) - PLID 31708 - Added EMRDataID_X
				"IF (@nCalledFromDetailID != -1) BEGIN \r\n"
				"   DELETE FROM EMRTableColumnWidthsT \r\n"
				"   WHERE (EMRDataID_X IN (SELECT OldDataID FROM @tDeleted) OR \r\n"
				"          EMRDataID_Y IN (SELECT OldDataID FROM @tDeleted)) AND \r\n"
				"         EmrDetailID IN (\r\n"
				"          SELECT ID FROM EmrDetailsT WHERE Deleted = 0 AND \r\n"
				"              EMRID IN (SELECT ID FROM EMRMasterT WHERE Deleted = 0 AND Status <> 2) AND \r\n"
				"              EMRDetailsT.ID = @nCalledFromDetailID \r\n"
				"         ) \r\n"
				"   SET @nError = @@ERROR IF @nError <> 0 BEGIN RAISERROR('@@ERROR was %li!', 16, 1, @nError) ROLLBACK TRAN RETURN END\r\n"
					// (j.jones 2007-07-05 17:36) - PLID 26557 - added key parentheses in the where clause
				"   DELETE FROM EMRDetailTableDataT \r\n"
				"   WHERE (EMRDataID_X IN (SELECT OldDataID FROM @tDeleted) OR \r\n"
				"          EMRDataID_Y IN (SELECT OldDataID FROM @tDeleted)) AND \r\n"
				"         EmrDetailID IN (\r\n"
				"          SELECT ID FROM EmrDetailsT WHERE Deleted = 0 AND EMRID IN (SELECT ID FROM EMRMasterT WHERE Deleted = 0 AND Status <> 2) AND \r\n"
				"          EMRDetailsT.ID = @nCalledFromDetailID\r\n"
				"         )\r\n"
				"   SET @nError = @@ERROR IF @nError <> 0 BEGIN RAISERROR('@@ERROR was %li!', 16, 1, @nError) ROLLBACK TRAN RETURN END\r\n"
				"   DELETE FROM EmrSelectT \r\n"
				"   WHERE EMRDataID IN (SELECT OldDataID FROM @tDeleted) AND \r\n"
				"         EmrDetailID IN (\r\n"
				"          SELECT ID FROM EmrDetailsT WHERE Deleted = 0 AND EMRID IN (SELECT ID FROM EMRMasterT WHERE Deleted = 0 AND Status <> 2) AND \r\n"
				"          EMRDetailsT.ID = @nCalledFromDetailID\r\n"
				"         )\r\n"
				"   SET @nError = @@ERROR IF @nError <> 0 BEGIN RAISERROR('@@ERROR was %li!', 16, 1, @nError) ROLLBACK TRAN RETURN END\r\n"
				"END \r\n"

				//(e.lally 2009-05-11) PLID 28553 - If we are removing DrugList records, Delete from Order Set Templates first
				//	I can't actually find a scenario in which the drug list has records removed, but it could be for some
				//	legacy reason.
				"DELETE FROM OrderSetTemplateMedicationsT WHERE MedicationID IN(SELECT ID FROM DrugList WHERE EMRDataID IN (SELECT OldDataID FROM @tDeleted));\r\n"
				"SET @nError = @@ERROR IF @nError <> 0 BEGIN RAISERROR('@@ERROR was %li!', 16, 1, @nError) ROLLBACK TRAN RETURN END\r\n"
				
				// (c.haag 2007-04-11 12:09) - PLID 25575 - We need to check other tables which link with EmrDataT
				// and delete those corresponding records too. Notice that we don't delete from PatientAllergyT or
				// PatientMedications; we want this to fail if records exist because we should not delete historic
				// patient data
				// (c.haag 2009-03-12 09:49) - PLID 32589 - Delete all actions that spawn this drug
				"DELETE FROM DrugAllergyT WHERE DrugID IN (SELECT ID FROM DrugList WHERE EMRDataID IN (SELECT OldDataID FROM @tDeleted)) \r\n"
				"SET @nError = @@ERROR IF @nError <> 0 BEGIN RAISERROR('@@ERROR was %li!', 16, 1, @nError) ROLLBACK TRAN RETURN END\r\n"
				"DELETE FROM DrugAllergyT WHERE AllergyID IN (SELECT ID FROM AllergyT WHERE EmrDataID IN (SELECT OldDataID FROM @tDeleted)) \r\n"
				"SET @nError = @@ERROR IF @nError <> 0 BEGIN RAISERROR('@@ERROR was %li!', 16, 1, @nError) ROLLBACK TRAN RETURN END\r\n"
				"UPDATE EMRActionsT SET Deleted = 1 WHERE DestType = 7 AND DestID IN (SELECT ID FROM DrugList WHERE EMRDataID IN (SELECT OldDataID FROM @tDeleted))\r\n"
				"SET @nError = @@ERROR IF @nError <> 0 BEGIN RAISERROR('@@ERROR was %li!', 16, 1, @nError) ROLLBACK TRAN RETURN END\r\n"
				"DELETE FROM DrugList WHERE EMRDataID IN (SELECT OldDataID FROM @tDeleted) \r\n"
				"SET @nError = @@ERROR IF @nError <> 0 BEGIN RAISERROR('@@ERROR was %li!', 16, 1, @nError) ROLLBACK TRAN RETURN END\r\n"
				"DELETE FROM AllergyT WHERE EMRDataID IN (SELECT OldDataID FROM @tDeleted) \r\n"
				"SET @nError = @@ERROR IF @nError <> 0 BEGIN RAISERROR('@@ERROR was %li!', 16, 1, @nError) ROLLBACK TRAN RETURN END\r\n"

				//* /
				"END \r\n"

				//
				//0b)  DRT 1/30/2008 - PLID 28602 - We also need to fix up any deleted hotspots
				// Save time by only running the deletion queries if there is anything in the @tDeleted table
				"IF (EXISTS (SELECT * FROM @tDeletedSpots)) BEGIN \r\n"
					// Delete from all appropriate tables where the new hotspot id doesn't exist because the user deleted it
					"DELETE FROM EMRHotSpotTemplateSelectT WHERE EmrImageHotSpotID IN (SELECT OldHotSpotID FROM @tDeletedSpots) \r\n"
					"SET @nError = @@ERROR IF @nError <> 0 BEGIN RAISERROR('@@ERROR was %li!', 16, 1, @nError) ROLLBACK TRAN RETURN END\r\n"

					// Include only those hot spots from the one EMN detail that we're editing now (if we're editing one)
					"IF (@nCalledFromDetailID != -1) BEGIN \r\n"
					"   DELETE FROM EMRHotSpotSelectT \r\n"
					"   WHERE EmrImageHotSpotID IN (SELECT OldHotSpotID FROM @tDeletedSpots) AND \r\n"
					"         EmrDetailID IN (\r\n"
					"          SELECT ID FROM EmrDetailsT WHERE Deleted = 0 AND EMRID IN (SELECT ID FROM EMRMasterT WHERE Deleted = 0 AND Status <> 2) AND \r\n"
					"          EMRDetailsT.ID = @nCalledFromDetailID\r\n"
					"         )\r\n"
					"   SET @nError = @@ERROR IF @nError <> 0 BEGIN RAISERROR('@@ERROR was %li!', 16, 1, @nError) ROLLBACK TRAN RETURN END\r\n"
					"END \r\n"
				"END \r\n"


				//1a)  Reassign any data elements selected on templates
				"UPDATE EMRTemplateSelectT SET EmrDataID = NewDataID \r\n"
				"FROM EMRTemplateSelectT INNER JOIN @tDataIDs T ON EMRTemplateSelectT.EmrDataID = T.OldDataID \r\n"
				"WHERE EmrTemplateDetailID IN (SELECT ID FROM EmrTemplateDetailsT WHERE TemplateID IN (SELECT ID FROM EMRTemplateT WHERE Deleted = 0)) \r\n"
				"SET @nError = @@ERROR IF @nError <> 0 BEGIN RAISERROR('@@ERROR was %li!', 16, 1, @nError) ROLLBACK TRAN RETURN END\r\n"

				//1a-i)  DRT 1/30/2008 - PLID 28602 - Reassign hotspots on templates
				"UPDATE EMRHotSpotTemplateSelectT SET EmrImageHotSpotID = NewHotSpotID \r\n"
				"FROM EMRHotSpotTemplateSelectT INNER JOIN @tHotSpotIDs T ON EMRHotSpotTemplateSelectT.EmrImageHotSpotID = T.OldHotSpotID \r\n"
				"WHERE EmrDetailID IN (SELECT ID FROM EmrTemplateDetailsT WHERE TemplateID IN (SELECT ID FROM EMRTemplateT WHERE Deleted = 0)) \r\n"
				"SET @nError = @@ERROR IF @nError <> 0 BEGIN RAISERROR('@@ERROR was %li!', 16, 1, @nError) ROLLBACK TRAN RETURN END\r\n"

				//1b)  Reassign any data elements selected on the current detail
				"IF (@nCalledFromDetailID != -1) BEGIN \r\n"
					//if we are editing a detail directly, then we will update just that item
				"   UPDATE EmrSelectT SET EmrDataID = NewDataID \r\n"
				"   FROM EmrSelectT INNER JOIN @tDataIDs T ON EmrSelectT.EmrDataID = T.OldDataID \r\n"
				"   WHERE EmrDetailID IN (\r\n"
				"     SELECT ID FROM EmrDetailsT \r\n"
				"     WHERE Deleted = 0 AND \r\n"
				"      EMRID IN (SELECT ID FROM EMRMasterT WHERE Deleted = 0 AND Status <> 2) AND \r\n"
				"      EMRDetailsT.ID = @nCalledFromDetailID\r\n"
				"     ) \r\n"
				"   SET @nError = @@ERROR IF @nError <> 0 BEGIN RAISERROR('@@ERROR was %li!', 16, 1, @nError) ROLLBACK TRAN RETURN END\r\n"
				"END \r\n"

				//1b-i)  DRT 1/30/2008 - PLID 28602 - Reassign hotspots on current detail
				"IF (@nCalledFromDetailID != -1) BEGIN \r\n"
					//if we are editing a detail directly, then we will update just that item
				"   UPDATE EMRHotSpotSelectT SET EmrImageHotSpotID = NewHotSpotID \r\n"
				"   FROM EMRHotSpotSelectT INNER JOIN @tHotSpotIDs T ON EMRHotSpotSelectT.EmrImageHotSpotID = T.OldHotSpotID \r\n"
				"   WHERE EmrDetailID IN (\r\n"
				"     SELECT ID FROM EmrDetailsT \r\n"
				"     WHERE Deleted = 0 AND \r\n"
				"      EMRID IN (SELECT ID FROM EMRMasterT WHERE Deleted = 0 AND Status <> 2) AND \r\n"
				"      EMRDetailsT.ID = @nCalledFromDetailID\r\n"
				"     ) \r\n"
				"   SET @nError = @@ERROR IF @nError <> 0 BEGIN RAISERROR('@@ERROR was %li!', 16, 1, @nError) ROLLBACK TRAN RETURN END\r\n"
				"END \r\n"


				//1c)  Reassign any table dropdown elements selected on templates
				// (b.cardillo 2007-08-23 11:42) - PLID 27081 - Sometimes sql attempts the (Data = OldDropdownID) part of the join before 
				// the (EMRDataID_Y = T.OldDataID) part which can result in an error because many Data values for other types of records 
				// are non-numeric and it tries to convert them to an INT for the comparison.  This isn't a problem on every database, but 
				// it definitely can happen.  So I've changed the string-to-integer comparison to a safer string-to-string comparison by 
				// converting the OldDropdownID value to NVARCHAR.
				// (c.haag 2008-01-16 13:04) - PLID 17936 - The Data field is now in CSV format. We will need to use a more advanced filter
				// to find the records we need, and also used a stored procedure to build the new CSV values
				// (c.haag 2008-02-21 16:01) - PLID 17936 - The former clause did not work. We need to update CSV values in a loop rather than a single
				// update statement. This code will use variables with the prefix @cv.
				"DECLARE @cvData nvarchar(4000) \r\n"
				"DECLARE @cvID INT \r\n"
				"DECLARE @cvOldDropdownID INT \r\n"
				"DECLARE @cvNewDropdownID INT \r\n"
				"DECLARE csrEmrTemplateTableData CURSOR FOR \r\n"
				"   SELECT EMRTemplateTableDefaultsT.ID, T.OldDropdownID, T.NewDropdownID FROM EMRTemplateTableDefaultsT INNER JOIN @tDropdownT T ON " + TABLEDROPDOWN_JOIN_ON_ELEMENT("EMRTemplateTableDefaultsT.Data", "CONVERT(NVARCHAR, T.OldDropdownID)") + " AND EMRTemplateTableDefaultsT.EMRDataID_Y = T.OldDataID \r\n"
				"	WHERE EmrTemplateDetailID IN (SELECT ID FROM EmrTemplateDetailsT WHERE TemplateID IN (SELECT ID FROM EMRTemplateT WHERE Deleted = 0)) \r\n"
				"FOR READ ONLY \r\n"
				"OPEN csrEmrTemplateTableData \r\n"
				"FETCH NEXT FROM csrEmrTemplateTableData INTO @cvID, @cvOldDropdownID, @cvNewDropdownID \r\n"
				"WHILE @@FETCH_STATUS = 0 BEGIN \r\n"
				"   UPDATE EMRTemplateTableDefaultsT SET Data = dbo.CSVReplaceInt(Data, @cvOldDropdownID, @cvNewDropdownID) WHERE EMRTemplateTableDefaultsT.ID = @cvID \r\n"
				"FETCH NEXT FROM csrEmrTemplateTableData INTO @cvID, @cvOldDropdownID, @cvNewDropdownID \r\n"
				"END \r\n"
				"CLOSE csrEmrTemplateTableData \r\n"
				"DEALLOCATE csrEmrTemplateTableData \r\n"
				// Old, bad code here
				//"UPDATE EMRTemplateTableDefaultsT SET Data = dbo.CSVReplaceInt(Data, T.OldDropdownID, NewDropdownID) FROM EMRTemplateTableDefaultsT INNER JOIN @tDropdownT T ON " + TABLEDROPDOWN_JOIN_ON_ELEMENT("EMRTemplateTableDefaultsT.Data", "CONVERT(NVARCHAR, T.OldDropdownID)") + " AND EMRTemplateTableDefaultsT.EMRDataID_Y = T.OldDataID \r\n"
				//"WHERE EmrTemplateDetailID IN (SELECT ID FROM EmrTemplateDetailsT WHERE TemplateID IN (SELECT ID FROM EMRTemplateT WHERE Deleted = 0)) \r\n"
				"SET @nError = @@ERROR IF @nError <> 0 BEGIN RAISERROR('@@ERROR was %li!', 16, 1, @nError) ROLLBACK TRAN RETURN END\r\n"

				//1d)  Reassign any table dropdown elements selected on the current detail
				//if we are editing a detail directly, then we will update just that item
				// (b.cardillo 2007-08-23 11:42) - PLID 27081 - Sometimes sql attempts the (Data = OldDropdownID) part of the join before 
				// the (EMRDataID_Y = T.OldDataID) part which can result in an error because many Data values for other types of records 
				// are non-numeric and it tries to convert them to an INT for the comparison.  This isn't a problem on every database, but 
				// it definitely can happen.  So I've changed the string-to-integer comparison to a safer string-to-string comparison by 
				// converting the OldDropdownID value to NVARCHAR.
				// (c.haag 2008-01-16 13:04) - PLID 17936 - The Data field is now in CSV format. We will need to use a more advanced filter
				// to find the records we need, and also used a stored procedure to build the new CSV values
				"IF (@nCalledFromDetailID != -1) BEGIN \r\n"
				// (c.haag 2008-02-21 16:15) - PLID 17936 - The former clause did not work. We need to update CSV values in a loop rather than a single
				// update statement. This code will use variables with the prefix @cv.
				"DECLARE csrEmrDetailTableData CURSOR FOR\r\n"
				"   SELECT EMRDetailTableDataT.ID, T.OldDropdownID, T.NewDropdownID FROM EMRDetailTableDataT INNER JOIN @tDropdownT T ON " + TABLEDROPDOWN_JOIN_ON_ELEMENT("EMRDetailTableDataT.Data", "CONVERT(NVARCHAR, T.OldDropdownID)") + " AND EMRDataID_Y = T.OldDataID \r\n"
				"   WHERE EmrDetailID IN (SELECT ID FROM EmrDetailsT WHERE Deleted = 0 AND EMRID IN (SELECT ID FROM EMRMasterT WHERE Deleted = 0 AND Status <> 2) AND EMRDetailsT.ID = @nCalledFromDetailID) \r\n"
				"FOR READ ONLY \r\n"
				"OPEN csrEmrDetailTableData \r\n"
				"FETCH NEXT FROM csrEmrDetailTableData INTO @cvID, @cvOldDropdownID, @cvNewDropdownID \r\n"
				"WHILE @@FETCH_STATUS = 0 BEGIN \r\n"
				"	UPDATE EMRDetailTableDataT SET Data = dbo.CSVReplaceInt(Data, @cvOldDropdownID, @cvNewDropdownID) WHERE EMRDetailTableDataT.ID = @cvID \r\n"
				"FETCH NEXT FROM csrEmrDetailTableData INTO @cvID, @cvOldDropdownID, @cvNewDropdownID \r\n"
				"END \r\n"
				"CLOSE csrEmrDetailTableData \r\n"
				"DEALLOCATE csrEmrDetailTableData \r\n"
				
				"   SET @nError = @@ERROR IF @nError <> 0 BEGIN RAISERROR('@@ERROR was %li!', 16, 1, @nError) ROLLBACK TRAN RETURN END\r\n"
				"END \r\n"

				//1f)  Continue reassignment of table information on templates
				"UPDATE EMRTemplateTableDefaultsT SET EmrDataID_X = NewDataID FROM EMRTemplateTableDefaultsT INNER JOIN @tDataIDs T ON EMRTemplateTableDefaultsT.EmrDataID_X = T.OldDataID \r\n"
				"WHERE EmrTemplateDetailID IN (SELECT ID FROM EmrTemplateDetailsT WHERE TemplateID IN (SELECT ID FROM EMRTemplateT WHERE Deleted = 0)) \r\n"
				"SET @nError = @@ERROR IF @nError <> 0 BEGIN RAISERROR('@@ERROR was %li!', 16, 1, @nError) ROLLBACK TRAN RETURN END\r\n"

				"UPDATE EMRTemplateTableDefaultsT SET EmrDataID_Y = NewDataID FROM EMRTemplateTableDefaultsT INNER JOIN @tDataIDs T ON EMRTemplateTableDefaultsT.EmrDataID_Y = T.OldDataID \r\n"
				"WHERE EmrTemplateDetailID IN (SELECT ID FROM EmrTemplateDetailsT WHERE TemplateID IN (SELECT ID FROM EMRTemplateT WHERE Deleted = 0)) \r\n"
				"SET @nError = @@ERROR IF @nError <> 0 BEGIN RAISERROR('@@ERROR was %li!', 16, 1, @nError) ROLLBACK TRAN RETURN END\r\n"

				//1g)  Reassign any table column widths
				"UPDATE EMRTemplateTableColumnWidthsT SET EMRDataID_Y = NewDataID FROM EMRTemplateTableColumnWidthsT INNER JOIN @tDataIDs T ON EMRTemplateTableColumnWidthsT.EMRDataID_Y = T.OldDataID \r\n"
				"WHERE EmrDetailID IN (SELECT ID FROM EmrTemplateDetailsT WHERE TemplateID IN (SELECT ID FROM EMRTemplateT WHERE Deleted = 0)) \r\n"
				"SET @nError = @@ERROR IF @nError <> 0 BEGIN RAISERROR('@@ERROR was %li!', 16, 1, @nError) ROLLBACK TRAN RETURN END\r\n"
				// (c.haag 2008-10-22 15:08) - PLID 31708 - EMRDataID_X
				"UPDATE EMRTemplateTableColumnWidthsT SET EMRDataID_X = NewDataID FROM EMRTemplateTableColumnWidthsT INNER JOIN @tDataIDs T ON EMRTemplateTableColumnWidthsT.EMRDataID_X = T.OldDataID \r\n"
				"WHERE EmrDetailID IN (SELECT ID FROM EmrTemplateDetailsT WHERE TemplateID IN (SELECT ID FROM EMRTemplateT WHERE Deleted = 0)) \r\n"
				"SET @nError = @@ERROR IF @nError <> 0 BEGIN RAISERROR('@@ERROR was %li!', 16, 1, @nError) ROLLBACK TRAN RETURN END\r\n"

				// (z.manning 2012-07-12 14:24) - PLID 50404 - I moved 3 (updating details' info IDs) before 1h (updating detail
				// table data) becaus there is now a trigger on EmrDetailTableDataT to ensure the info IDs of the row/column and
				// the detail are in sync. By updating EmrDetailsT first, we prevent this trigger from firing.
				//3) now reassign details' references to EMRInfoID
				
				//TES 12/5/2006 - PLID 23724 - Template details now just reference the EmrInfoMasterID, which hasn't changed.
				//3a) Reassign the EMRInfoT-referencing records in EMRTemplateDetailsT
				/*ExecuteSql("UPDATE EmrTemplateDetailsT SET EMRInfoID = %d WHERE EMRInfoID = %d AND TemplateID IN "
					"(SELECT ID FROM EMRTemplateT WHERE Deleted = 0)",
					nNewInfoID, nOldInfoID);*/

				//3b) Reassign the EMRInfoT-referencing in EMRDetailsT for the current detail
				//if we are editing a detail directly, then we will update just that item
				"IF (@nCalledFromDetailID != -1) BEGIN \r\n"
				"   UPDATE EMRDetailsT SET EMRInfoID = {INT} WHERE Deleted = 0 AND EMRInfoID = {INT} AND \r\n"
				"      EMRID IN (SELECT ID FROM EMRMasterT WHERE Deleted = 0 AND Status <> 2) AND \r\n"
				"      EMRDetailsT.ID = @nCalledFromDetailID \r\n"
				"   SET @nError = @@ERROR IF @nError <> 0 BEGIN RAISERROR('@@ERROR was %li!', 16, 1, @nError) ROLLBACK TRAN RETURN END\r\n"
				"END \r\n"

				//1h)  Continue reassignment of table information on the current detail
				//if we are editing a detail directly, then we will update just that item
				// Reassign any table column widths
				"IF (@nCalledFromDetailID != -1) BEGIN \r\n"
				"   UPDATE EMRDetailTableDataT SET EmrDataID_Y = NewDataID FROM EMRDetailTableDataT INNER JOIN @tDataIDs T ON EMRDetailTableDataT.EmrDataID_Y = T.OldDataID \r\n"
				"   WHERE EmrDetailID IN (\r\n"
				"          SELECT ID FROM EmrDetailsT WHERE Deleted = 0 AND \r\n"
				"           EMRID IN (SELECT ID FROM EMRMasterT WHERE Deleted = 0 AND Status <> 2) AND \r\n"
				"           EMRDetailsT.ID = @nCalledFromDetailID) \r\n"
				"   SET @nError = @@ERROR IF @nError <> 0 BEGIN RAISERROR('@@ERROR was %li!', 16, 1, @nError) ROLLBACK TRAN RETURN END\r\n"
				"   UPDATE EMRDetailTableDataT SET EmrDataID_X = NewDataID FROM EMRDetailTableDataT INNER JOIN @tDataIDs T ON EMRDetailTableDataT.EmrDataID_X = T.OldDataID \r\n"
				"   WHERE EmrDetailID IN (\r\n"
				"          SELECT ID FROM EmrDetailsT WHERE Deleted = 0 AND \r\n"
				"           EMRID IN (SELECT ID FROM EMRMasterT WHERE Deleted = 0 AND Status <> 2) AND \r\n"
				"           EMRDetailsT.ID = @nCalledFromDetailID\r\n"
				"          ) \r\n"
				"   SET @nError = @@ERROR IF @nError <> 0 BEGIN RAISERROR('@@ERROR was %li!', 16, 1, @nError) ROLLBACK TRAN RETURN END\r\n"
				"   UPDATE EMRTableColumnWidthsT SET EMRDataID_Y = NewDataID FROM EMRTableColumnWidthsT INNER JOIN @tDataIDs T ON EMRTableColumnWidthsT.EMRDataID_Y = T.OldDataID \r\n"
				"   WHERE EmrDetailID IN (\r\n"
				"          SELECT ID FROM EmrDetailsT WHERE Deleted = 0 AND EMRID IN (SELECT ID FROM EMRMasterT WHERE Deleted = 0 AND Status <> 2) AND \r\n"
				"           EMRDetailsT.ID = @nCalledFromDetailID) \r\n"
				"   SET @nError = @@ERROR IF @nError <> 0 BEGIN RAISERROR('@@ERROR was %li!', 16, 1, @nError) ROLLBACK TRAN RETURN END\r\n"
				// (c.haag 2008-10-22 13:55) - PLID 31708 - EmrDataID_X
				"	UPDATE EMRTableColumnWidthsT SET EmrDataID_X = NewDataID FROM EMRTableColumnWidthsT INNER JOIN @tDataIDs T ON EMRTableColumnWidthsT.EMRDataID_X = T.OldDataID \r\n"
				"   WHERE EmrDetailID IN (\r\n"
				"          SELECT ID FROM EmrDetailsT WHERE Deleted = 0 AND EMRID IN (SELECT ID FROM EMRMasterT WHERE Deleted = 0 AND Status <> 2) AND \r\n"
				"           EMRDetailsT.ID = @nCalledFromDetailID) \r\n"
				"   SET @nError = @@ERROR IF @nError <> 0 BEGIN RAISERROR('@@ERROR was %li!', 16, 1, @nError) ROLLBACK TRAN RETURN END\r\n"
				"END \r\n"

				//1i) (c.haag 2007-01-30 17:15) - PLID 24423 - Update the DrugList table
				"UPDATE DrugList SET EMRDataID = NewDataID FROM DrugList INNER JOIN @tDataIDs T ON DrugList.EMRDataID = T.OldDataID \r\n"
				"SET @nError = @@ERROR IF @nError <> 0 BEGIN RAISERROR('@@ERROR was %li!', 16, 1, @nError) ROLLBACK TRAN RETURN END\r\n"

				// (c.haag 2007-04-03 09:36) - PLID 25468 - Update the AllergyT table
				"UPDATE AllergyT SET EMRDataID = NewDataID FROM AllergyT INNER JOIN @tDataIDs T ON AllergyT.EMRDataID = T.OldDataID \r\n"
				"SET @nError = @@ERROR IF @nError <> 0 BEGIN RAISERROR('@@ERROR was %li!', 16, 1, @nError) ROLLBACK TRAN RETURN END\r\n"

				//TES 12/5/2006 - PLID 23724 - Action destinations now just reference the EmrInfoMasterID, which hasn't changed.
				/*// (j.jones 2006-09-21 14:11) - PLID 22640
				//4) reassign actions' references to EMRInfoID as a destination type
				ExecuteSql("UPDATE EMRActionsT SET DestID = %li WHERE DestType = %li AND DestID = %li", nNewInfoID, eaoEmrItem, nOldInfoID);*/

				// (a.walling 2009-07-01 16:50) - PLID 34759
				"IF {INT} <> (SELECT ActiveEmrInfoID FROM EmrInfoMasterT WHERE ID = {INT}) BEGIN RAISERROR('Item is out of date', 16, 41) ROLLBACK TRAN RETURN END; "

				//TES 12/6/2006 - PLID 23724 - Also, this is now the active version of this item.
				"UPDATE EmrInfoMasterT SET ActiveEmrInfoID = {INT} WHERE ID = {INT} \r\n"
				"SET @nError = @@ERROR IF @nError <> 0 BEGIN RAISERROR('@@ERROR was %li!', 16, 1, @nError) ROLLBACK TRAN RETURN END\r\n"

				"SET NOCOUNT OFF \r\n");
			Log_CurrentMedicationsEdit("strChangedDataIDXML = " + strChangedDataIDXML);
			Log_CurrentMedicationsEdit("strChangeDropdownIDXML = " + strChangeDropdownIDXML);
			Log_CurrentMedicationsEdit("strChangedHotSpotIDXML = " + strChangedHotSpotIDXML);
			Log_CurrentMedicationsEdit(FormatString("m_nCalledFromDetailID = %li, nNewInfoID = %li, nOldInfoID = %li, m_nEmrInfoMasterID = %li, "
				"nNewInfoID = %li", GetCalledFromDetailID(), nNewInfoID, nOldInfoID, m_nEmrInfoMasterID, nNewInfoID));
		}
		ExecuteParamSql(
			"SET NOCOUNT ON \r\n"

			"DECLARE @nError INT \r\n"
			
			// Create the table of all the changed data ids
			"DECLARE @tDataIDs TABLE (RowNum INT IDENTITY NOT NULL PRIMARY KEY, OldDataID INT NOT NULL, NewDataID INT NOT NULL) \r\n"
			"DECLARE @hDoc AS INT \r\n"
			"EXEC sp_xml_preparedocument @hDoc OUTPUT, {STRING} \r\n"
			"SET @nError = @@ERROR IF @nError <> 0 BEGIN RAISERROR('@@ERROR was %li!', 16, 1, @nError) ROLLBACK TRAN RETURN END\r\n"
			"INSERT INTO @tDataIDs (OldDataID, NewDataID) \r\n"
			" SELECT OldDataID, NewDataID FROM OPENXML(@hDoc, '/ROOT/P') WITH (OldDataID INT '@O', NewDataID INT '@N') \r\n"
			"SET @nError = @@ERROR IF @nError <> 0 BEGIN RAISERROR('@@ERROR was %li!', 16, 1, @nError) ROLLBACK TRAN RETURN END\r\n"
			"EXEC sp_xml_removedocument @hDoc \r\n"
			"SET @nError = @@ERROR IF @nError <> 0 BEGIN RAISERROR('@@ERROR was %li!', 16, 1, @nError) ROLLBACK TRAN RETURN END\r\n"

			// Create the table of all the changed dropdown ids
			"DECLARE @tDropdownT TABLE (RowNum INT IDENTITY NOT NULL PRIMARY KEY, OldDataID INT NOT NULL, OldDropdownID INT NOT NULL, NewDropdownID INT NOT NULL) \r\n"
			"EXEC sp_xml_preparedocument @hDoc OUTPUT, {STRING} \r\n"
			"SET @nError = @@ERROR IF @nError <> 0 BEGIN RAISERROR('@@ERROR was %li!', 16, 1, @nError) ROLLBACK TRAN RETURN END\r\n"
			"INSERT INTO @tDropdownT (OldDataID, OldDropdownID, NewDropdownID) \r\n"
			" SELECT OldDataID, OldDropdownID, NewDropdownID FROM OPENXML(@hDoc, '/ROOT/P') WITH (OldDataID INT '@D', OldDropdownID INT '@O', NewDropdownID INT '@N') \r\n"
			"SET @nError = @@ERROR IF @nError <> 0 BEGIN RAISERROR('@@ERROR was %li!', 16, 1, @nError) ROLLBACK TRAN RETURN END\r\n"
			"EXEC sp_xml_removedocument @hDoc \r\n"
			"SET @nError = @@ERROR IF @nError <> 0 BEGIN RAISERROR('@@ERROR was %li!', 16, 1, @nError) ROLLBACK TRAN RETURN END\r\n"

			//DRT 1/30/2008 - PLID 28602 - Create the table of all changed hotspot ids
			"DECLARE @tHotSpotIDs TABLE (RowNum INT IDENTITY NOT NULL PRIMARY KEY, OldHotSpotID INT NOT NULL, NewHotSpotID INT NOT NULL) \r\n"
			"EXEC sp_xml_preparedocument @hDoc OUTPUT, {STRING} \r\n"
			"SET @nError = @@ERROR IF @nError <> 0 BEGIN RAISERROR('@@ERROR was %li!', 16, 1, @nError) ROLLBACK TRAN RETURN END\r\n"
			"INSERT INTO @tHotSpotIDs (OldHotSpotID, NewHotSpotID) \r\n"
			"  SELECT OldHotSpotID, NewHotSpotID FROM OPENXML(@hDoc, '/ROOT/P') WITH (OldHotSpotID INT '@O', NewHotSpotID INT '@N') \r\n"
			"SET @nError = @@ERROR IF @nError <> 0 BEGIN RAISERROR('@@ERROR was %li!', 16, 1, @nError) ROLLBACK TRAN RETURN END\r\n"
			"EXEC sp_xml_removedocument @hDoc \r\n"
			"SET @nError = @@ERROR IF @nError <> 0 BEGIN RAISERROR('@@ERROR was %li!', 16, 1, @nError) ROLLBACK TRAN RETURN END\r\n"


			"DECLARE @nCalledFromDetailID INT \r\n"
			"SET @nCalledFromDetailID = {INT} \r\n"
			"SET @nError = @@ERROR IF @nError <> 0 BEGIN RAISERROR('@@ERROR was %li!', 16, 1, @nError) ROLLBACK TRAN RETURN END\r\n"

			"DECLARE @tDeleted TABLE (OldDataID INT NOT NULL) \r\n"
			"INSERT INTO @tDeleted (OldDataID) SELECT OldDataID FROM @tDataIDs WHERE NewDataID NOT IN (SELECT A.ID FROM EMRDataT A) \r\n"
			"SET @nError = @@ERROR IF @nError <> 0 BEGIN RAISERROR('@@ERROR was %li!', 16, 1, @nError) ROLLBACK TRAN RETURN END\r\n"

			//DRT 1/30/2008 - PLID 28602 - Create the table of all deleted hotspot ids
			"DECLARE @tDeletedSpots TABLE (OldHotSpotID INT NOT NULL) \r\n"
			"INSERT INTO @tDeletedSpots (OldHotSpotID) SELECT OldHotSpotID FROM @tHotSpotIDs WHERE NewHotSpotID NOT IN (SELECT A.ID FROM EMRImageHotSpotsT A) \r\n"
			"SET @nError = @@ERROR IF @nError <> 0 BEGIN RAISERROR('@@ERROR was %li!', 16, 1, @nError) ROLLBACK TRAN RETURN END\r\n"
			
			// Save time by only running the deletion queries if there is anything in the @tDeleted table
			"IF (EXISTS (SELECT * FROM @tDeleted)) BEGIN \r\n"

			//*
			// Delete from all appropriate tables where the new data id doesn't exist because the user deleted it
			// (j.jones 2006-09-06 17:43) - PLID 22427 - required when deletions occurred
			"DELETE FROM EmrTemplateSelectT WHERE EmrDataID IN (SELECT OldDataID FROM @tDeleted) \r\n"
			"SET @nError = @@ERROR IF @nError <> 0 BEGIN RAISERROR('@@ERROR was %li!', 16, 1, @nError) ROLLBACK TRAN RETURN END\r\n"
			"DELETE FROM EMRTemplateTableColumnWidthsT WHERE EMRDataID_Y IN (SELECT OldDataID FROM @tDeleted) \r\n"
			"SET @nError = @@ERROR IF @nError <> 0 BEGIN RAISERROR('@@ERROR was %li!', 16, 1, @nError) ROLLBACK TRAN RETURN END\r\n"
			// (c.haag 2008-10-22 15:08) - PLID 31708 - EMRDataID_X
			"DELETE FROM EMRTemplateTableColumnWidthsT WHERE EMRDataID_X IN (SELECT OldDataID FROM @tDeleted) \r\n"
			"SET @nError = @@ERROR IF @nError <> 0 BEGIN RAISERROR('@@ERROR was %li!', 16, 1, @nError) ROLLBACK TRAN RETURN END\r\n"
			//
			"DELETE FROM EmrTemplateTableDefaultsT WHERE EMRDataID_X IN (SELECT OldDataID FROM @tDeleted) \r\n"
			"                                         OR EMRDataID_Y IN (SELECT OldDataID FROM @tDeleted) \r\n"
			"SET @nError = @@ERROR IF @nError <> 0 BEGIN RAISERROR('@@ERROR was %li!', 16, 1, @nError) ROLLBACK TRAN RETURN END\r\n"
				
			// Include only those data elements from the one EMN detail that we're editing now (if we're editing one)
			// (c.haag 2008-10-22 15:33) - PLID 31708 - Added EMRDataID_X
			"IF (@nCalledFromDetailID != -1) BEGIN \r\n"
			"   DELETE FROM EMRTableColumnWidthsT \r\n"
			"   WHERE (EMRDataID_X IN (SELECT OldDataID FROM @tDeleted) OR \r\n"
			"          EMRDataID_Y IN (SELECT OldDataID FROM @tDeleted)) AND \r\n"
			"         EmrDetailID IN (\r\n"
			"          SELECT ID FROM EmrDetailsT WHERE Deleted = 0 AND \r\n"
			"              EMRID IN (SELECT ID FROM EMRMasterT WHERE Deleted = 0 AND Status <> 2) AND \r\n"
			"              EMRDetailsT.ID = @nCalledFromDetailID \r\n"
			"         ) \r\n"
			"   SET @nError = @@ERROR IF @nError <> 0 BEGIN RAISERROR('@@ERROR was %li!', 16, 1, @nError) ROLLBACK TRAN RETURN END\r\n"
				// (j.jones 2007-07-05 17:36) - PLID 26557 - added key parentheses in the where clause
			"   DELETE FROM EMRDetailTableDataT \r\n"
			"   WHERE (EMRDataID_X IN (SELECT OldDataID FROM @tDeleted) OR \r\n"
			"          EMRDataID_Y IN (SELECT OldDataID FROM @tDeleted)) AND \r\n"
			"         EmrDetailID IN (\r\n"
			"          SELECT ID FROM EmrDetailsT WHERE Deleted = 0 AND EMRID IN (SELECT ID FROM EMRMasterT WHERE Deleted = 0 AND Status <> 2) AND \r\n"
			"          EMRDetailsT.ID = @nCalledFromDetailID\r\n"
			"         )\r\n"
			"   SET @nError = @@ERROR IF @nError <> 0 BEGIN RAISERROR('@@ERROR was %li!', 16, 1, @nError) ROLLBACK TRAN RETURN END\r\n"
			"   DELETE FROM EmrSelectT \r\n"
			"   WHERE EMRDataID IN (SELECT OldDataID FROM @tDeleted) AND \r\n"
			"         EmrDetailID IN (\r\n"
			"          SELECT ID FROM EmrDetailsT WHERE Deleted = 0 AND EMRID IN (SELECT ID FROM EMRMasterT WHERE Deleted = 0 AND Status <> 2) AND \r\n"
			"          EMRDetailsT.ID = @nCalledFromDetailID\r\n"
			"         )\r\n"
			"   SET @nError = @@ERROR IF @nError <> 0 BEGIN RAISERROR('@@ERROR was %li!', 16, 1, @nError) ROLLBACK TRAN RETURN END\r\n"
			"END \r\n"

			//(e.lally 2009-05-11) PLID 28553 - If we are removing DrugList records, Delete from Order Set Templates first
			//	I can't actually find a scenario in which the drug list has records removed, but it could be for some
			//	legacy reason.
			"DELETE FROM OrderSetTemplateMedicationsT WHERE MedicationID IN(SELECT ID FROM DrugList WHERE EMRDataID IN (SELECT OldDataID FROM @tDeleted));\r\n"
			"SET @nError = @@ERROR IF @nError <> 0 BEGIN RAISERROR('@@ERROR was %li!', 16, 1, @nError) ROLLBACK TRAN RETURN END\r\n"
			
			// (c.haag 2007-04-11 12:09) - PLID 25575 - We need to check other tables which link with EmrDataT
			// and delete those corresponding records too. Notice that we don't delete from PatientAllergyT or
			// PatientMedications; we want this to fail if records exist because we should not delete historic
			// patient data
			// (c.haag 2009-03-12 09:49) - PLID 32589 - Delete all actions that spawn this drug
			"DELETE FROM DrugAllergyT WHERE DrugID IN (SELECT ID FROM DrugList WHERE EMRDataID IN (SELECT OldDataID FROM @tDeleted)) \r\n"
			"SET @nError = @@ERROR IF @nError <> 0 BEGIN RAISERROR('@@ERROR was %li!', 16, 1, @nError) ROLLBACK TRAN RETURN END\r\n"
			"DELETE FROM DrugAllergyT WHERE AllergyID IN (SELECT ID FROM AllergyT WHERE EmrDataID IN (SELECT OldDataID FROM @tDeleted)) \r\n"
			"SET @nError = @@ERROR IF @nError <> 0 BEGIN RAISERROR('@@ERROR was %li!', 16, 1, @nError) ROLLBACK TRAN RETURN END\r\n"
			"UPDATE EMRActionsT SET Deleted = 1 WHERE DestType = 7 AND DestID IN (SELECT ID FROM DrugList WHERE EMRDataID IN (SELECT OldDataID FROM @tDeleted))\r\n"
			"SET @nError = @@ERROR IF @nError <> 0 BEGIN RAISERROR('@@ERROR was %li!', 16, 1, @nError) ROLLBACK TRAN RETURN END\r\n"
			"DELETE FROM DrugList WHERE EMRDataID IN (SELECT OldDataID FROM @tDeleted) \r\n"
			"SET @nError = @@ERROR IF @nError <> 0 BEGIN RAISERROR('@@ERROR was %li!', 16, 1, @nError) ROLLBACK TRAN RETURN END\r\n"
			"DELETE FROM AllergyT WHERE EMRDataID IN (SELECT OldDataID FROM @tDeleted) \r\n"
			"SET @nError = @@ERROR IF @nError <> 0 BEGIN RAISERROR('@@ERROR was %li!', 16, 1, @nError) ROLLBACK TRAN RETURN END\r\n"

			//* /
			"END \r\n"

			//
			//0b)  DRT 1/30/2008 - PLID 28602 - We also need to fix up any deleted hotspots
			// Save time by only running the deletion queries if there is anything in the @tDeleted table
			"IF (EXISTS (SELECT * FROM @tDeletedSpots)) BEGIN \r\n"
				// Delete from all appropriate tables where the new hotspot id doesn't exist because the user deleted it
				"DELETE FROM EMRHotSpotTemplateSelectT WHERE EmrImageHotSpotID IN (SELECT OldHotSpotID FROM @tDeletedSpots) \r\n"
				"SET @nError = @@ERROR IF @nError <> 0 BEGIN RAISERROR('@@ERROR was %li!', 16, 1, @nError) ROLLBACK TRAN RETURN END\r\n"

				// Include only those hot spots from the one EMN detail that we're editing now (if we're editing one)
				"IF (@nCalledFromDetailID != -1) BEGIN \r\n"
				"   DELETE FROM EMRHotSpotSelectT \r\n"
				"   WHERE EmrImageHotSpotID IN (SELECT OldHotSpotID FROM @tDeletedSpots) AND \r\n"
				"         EmrDetailID IN (\r\n"
				"          SELECT ID FROM EmrDetailsT WHERE Deleted = 0 AND EMRID IN (SELECT ID FROM EMRMasterT WHERE Deleted = 0 AND Status <> 2) AND \r\n"
				"          EMRDetailsT.ID = @nCalledFromDetailID\r\n"
				"         )\r\n"
				"   SET @nError = @@ERROR IF @nError <> 0 BEGIN RAISERROR('@@ERROR was %li!', 16, 1, @nError) ROLLBACK TRAN RETURN END\r\n"
				"END \r\n"
			"END \r\n"


			//1a)  Reassign any data elements selected on templates
			"UPDATE EMRTemplateSelectT SET EmrDataID = NewDataID \r\n"
			"FROM EMRTemplateSelectT INNER JOIN @tDataIDs T ON EMRTemplateSelectT.EmrDataID = T.OldDataID \r\n"
			"WHERE EmrTemplateDetailID IN (SELECT ID FROM EmrTemplateDetailsT WHERE TemplateID IN (SELECT ID FROM EMRTemplateT WHERE Deleted = 0)) \r\n"
			"SET @nError = @@ERROR IF @nError <> 0 BEGIN RAISERROR('@@ERROR was %li!', 16, 1, @nError) ROLLBACK TRAN RETURN END\r\n"

			//1a-i)  DRT 1/30/2008 - PLID 28602 - Reassign hotspots on templates
			"UPDATE EMRHotSpotTemplateSelectT SET EmrImageHotSpotID = NewHotSpotID \r\n"
			"FROM EMRHotSpotTemplateSelectT INNER JOIN @tHotSpotIDs T ON EMRHotSpotTemplateSelectT.EmrImageHotSpotID = T.OldHotSpotID \r\n"
			"WHERE EmrDetailID IN (SELECT ID FROM EmrTemplateDetailsT WHERE TemplateID IN (SELECT ID FROM EMRTemplateT WHERE Deleted = 0)) \r\n"
			"SET @nError = @@ERROR IF @nError <> 0 BEGIN RAISERROR('@@ERROR was %li!', 16, 1, @nError) ROLLBACK TRAN RETURN END\r\n"

			//1b)  Reassign any data elements selected on the current detail
			"IF (@nCalledFromDetailID != -1) BEGIN \r\n"
				//if we are editing a detail directly, then we will update just that item
			"   UPDATE EmrSelectT SET EmrDataID = NewDataID \r\n"
			"   FROM EmrSelectT INNER JOIN @tDataIDs T ON EmrSelectT.EmrDataID = T.OldDataID \r\n"
			"   WHERE EmrDetailID IN (\r\n"
			"     SELECT ID FROM EmrDetailsT \r\n"
			"     WHERE Deleted = 0 AND \r\n"
			"      EMRID IN (SELECT ID FROM EMRMasterT WHERE Deleted = 0 AND Status <> 2) AND \r\n"
			"      EMRDetailsT.ID = @nCalledFromDetailID\r\n"
			"     ) \r\n"
			"   SET @nError = @@ERROR IF @nError <> 0 BEGIN RAISERROR('@@ERROR was %li!', 16, 1, @nError) ROLLBACK TRAN RETURN END\r\n"
			"END \r\n"

			//1b-i)  DRT 1/30/2008 - PLID 28602 - Reassign hotspots on current detail
			"IF (@nCalledFromDetailID != -1) BEGIN \r\n"
				//if we are editing a detail directly, then we will update just that item
			"   UPDATE EMRHotSpotSelectT SET EmrImageHotSpotID = NewHotSpotID \r\n"
			"   FROM EMRHotSpotSelectT INNER JOIN @tHotSpotIDs T ON EMRHotSpotSelectT.EmrImageHotSpotID = T.OldHotSpotID \r\n"
			"   WHERE EmrDetailID IN (\r\n"
			"     SELECT ID FROM EmrDetailsT \r\n"
			"     WHERE Deleted = 0 AND \r\n"
			"      EMRID IN (SELECT ID FROM EMRMasterT WHERE Deleted = 0 AND Status <> 2) AND \r\n"
			"      EMRDetailsT.ID = @nCalledFromDetailID\r\n"
			"     ) \r\n"
			"   SET @nError = @@ERROR IF @nError <> 0 BEGIN RAISERROR('@@ERROR was %li!', 16, 1, @nError) ROLLBACK TRAN RETURN END\r\n"
			"END \r\n"


			//1c)  Reassign any table dropdown elements selected on templates
			// (b.cardillo 2007-08-23 11:42) - PLID 27081 - Sometimes sql attempts the (Data = OldDropdownID) part of the join before 
			// the (EMRDataID_Y = T.OldDataID) part which can result in an error because many Data values for other types of records 
			// are non-numeric and it tries to convert them to an INT for the comparison.  This isn't a problem on every database, but 
			// it definitely can happen.  So I've changed the string-to-integer comparison to a safer string-to-string comparison by 
			// converting the OldDropdownID value to NVARCHAR.
			// (c.haag 2008-01-16 13:04) - PLID 17936 - The Data field is now in CSV format. We will need to use a more advanced filter
			// to find the records we need, and also used a stored procedure to build the new CSV values
			// (c.haag 2008-02-21 16:01) - PLID 17936 - The former clause did not work. We need to update CSV values in a loop rather than a single
			// update statement. This code will use variables with the prefix @cv.
			"DECLARE @cvData nvarchar(4000) \r\n"
			"DECLARE @cvID INT \r\n"
			"DECLARE @cvOldDropdownID INT \r\n"
			"DECLARE @cvNewDropdownID INT \r\n"
			"DECLARE csrEmrTemplateTableData CURSOR FOR \r\n"
			"   SELECT EMRTemplateTableDefaultsT.ID, T.OldDropdownID, T.NewDropdownID FROM EMRTemplateTableDefaultsT INNER JOIN @tDropdownT T ON " + TABLEDROPDOWN_JOIN_ON_ELEMENT("EMRTemplateTableDefaultsT.Data", "CONVERT(NVARCHAR, T.OldDropdownID)") + " AND EMRTemplateTableDefaultsT.EMRDataID_Y = T.OldDataID \r\n"
			"	WHERE EmrTemplateDetailID IN (SELECT ID FROM EmrTemplateDetailsT WHERE TemplateID IN (SELECT ID FROM EMRTemplateT WHERE Deleted = 0)) \r\n"
			"FOR READ ONLY \r\n"
			"OPEN csrEmrTemplateTableData \r\n"
			"FETCH NEXT FROM csrEmrTemplateTableData INTO @cvID, @cvOldDropdownID, @cvNewDropdownID \r\n"
			"WHILE @@FETCH_STATUS = 0 BEGIN \r\n"
			"   UPDATE EMRTemplateTableDefaultsT SET Data = dbo.CSVReplaceInt(Data, @cvOldDropdownID, @cvNewDropdownID) WHERE EMRTemplateTableDefaultsT.ID = @cvID \r\n"
			"FETCH NEXT FROM csrEmrTemplateTableData INTO @cvID, @cvOldDropdownID, @cvNewDropdownID \r\n"
			"END \r\n"
			"CLOSE csrEmrTemplateTableData \r\n"
			"DEALLOCATE csrEmrTemplateTableData \r\n"
			// Old, bad code here
			//"UPDATE EMRTemplateTableDefaultsT SET Data = dbo.CSVReplaceInt(Data, T.OldDropdownID, NewDropdownID) FROM EMRTemplateTableDefaultsT INNER JOIN @tDropdownT T ON " + TABLEDROPDOWN_JOIN_ON_ELEMENT("EMRTemplateTableDefaultsT.Data", "CONVERT(NVARCHAR, T.OldDropdownID)") + " AND EMRTemplateTableDefaultsT.EMRDataID_Y = T.OldDataID \r\n"
			//"WHERE EmrTemplateDetailID IN (SELECT ID FROM EmrTemplateDetailsT WHERE TemplateID IN (SELECT ID FROM EMRTemplateT WHERE Deleted = 0)) \r\n"
			"SET @nError = @@ERROR IF @nError <> 0 BEGIN RAISERROR('@@ERROR was %li!', 16, 1, @nError) ROLLBACK TRAN RETURN END\r\n"

			//1d)  Reassign any table dropdown elements selected on the current detail
			//if we are editing a detail directly, then we will update just that item
			// (b.cardillo 2007-08-23 11:42) - PLID 27081 - Sometimes sql attempts the (Data = OldDropdownID) part of the join before 
			// the (EMRDataID_Y = T.OldDataID) part which can result in an error because many Data values for other types of records 
			// are non-numeric and it tries to convert them to an INT for the comparison.  This isn't a problem on every database, but 
			// it definitely can happen.  So I've changed the string-to-integer comparison to a safer string-to-string comparison by 
			// converting the OldDropdownID value to NVARCHAR.
			// (c.haag 2008-01-16 13:04) - PLID 17936 - The Data field is now in CSV format. We will need to use a more advanced filter
			// to find the records we need, and also used a stored procedure to build the new CSV values
			"IF (@nCalledFromDetailID != -1) BEGIN \r\n"
			// (c.haag 2008-02-21 16:15) - PLID 17936 - The former clause did not work. We need to update CSV values in a loop rather than a single
			// update statement. This code will use variables with the prefix @cv.
			"DECLARE csrEmrDetailTableData CURSOR FOR\r\n"
			"   SELECT EMRDetailTableDataT.ID, T.OldDropdownID, T.NewDropdownID FROM EMRDetailTableDataT INNER JOIN @tDropdownT T ON " + TABLEDROPDOWN_JOIN_ON_ELEMENT("EMRDetailTableDataT.Data", "CONVERT(NVARCHAR, T.OldDropdownID)") + " AND EMRDataID_Y = T.OldDataID \r\n"
			"   WHERE EmrDetailID IN (SELECT ID FROM EmrDetailsT WHERE Deleted = 0 AND EMRID IN (SELECT ID FROM EMRMasterT WHERE Deleted = 0 AND Status <> 2) AND EMRDetailsT.ID = @nCalledFromDetailID) \r\n"
			"FOR READ ONLY \r\n"
			"OPEN csrEmrDetailTableData \r\n"
			"FETCH NEXT FROM csrEmrDetailTableData INTO @cvID, @cvOldDropdownID, @cvNewDropdownID \r\n"
			"WHILE @@FETCH_STATUS = 0 BEGIN \r\n"
			"	UPDATE EMRDetailTableDataT SET Data = dbo.CSVReplaceInt(Data, @cvOldDropdownID, @cvNewDropdownID) WHERE EMRDetailTableDataT.ID = @cvID \r\n"
			"FETCH NEXT FROM csrEmrDetailTableData INTO @cvID, @cvOldDropdownID, @cvNewDropdownID \r\n"
			"END \r\n"
			"CLOSE csrEmrDetailTableData \r\n"
			"DEALLOCATE csrEmrDetailTableData \r\n"

			"   SET @nError = @@ERROR IF @nError <> 0 BEGIN RAISERROR('@@ERROR was %li!', 16, 1, @nError) ROLLBACK TRAN RETURN END\r\n"
			"END \r\n"

			//1f)  Continue reassignment of table information on templates
			"UPDATE EMRTemplateTableDefaultsT SET EmrDataID_X = NewDataID FROM EMRTemplateTableDefaultsT INNER JOIN @tDataIDs T ON EMRTemplateTableDefaultsT.EmrDataID_X = T.OldDataID \r\n"
			"WHERE EmrTemplateDetailID IN (SELECT ID FROM EmrTemplateDetailsT WHERE TemplateID IN (SELECT ID FROM EMRTemplateT WHERE Deleted = 0)) \r\n"
			"SET @nError = @@ERROR IF @nError <> 0 BEGIN RAISERROR('@@ERROR was %li!', 16, 1, @nError) ROLLBACK TRAN RETURN END\r\n"

			"UPDATE EMRTemplateTableDefaultsT SET EmrDataID_Y = NewDataID FROM EMRTemplateTableDefaultsT INNER JOIN @tDataIDs T ON EMRTemplateTableDefaultsT.EmrDataID_Y = T.OldDataID \r\n"
			"WHERE EmrTemplateDetailID IN (SELECT ID FROM EmrTemplateDetailsT WHERE TemplateID IN (SELECT ID FROM EMRTemplateT WHERE Deleted = 0)) \r\n"
			"SET @nError = @@ERROR IF @nError <> 0 BEGIN RAISERROR('@@ERROR was %li!', 16, 1, @nError) ROLLBACK TRAN RETURN END\r\n"

			//1g)  Reassign any table column widths
			"UPDATE EMRTemplateTableColumnWidthsT SET EMRDataID_Y = NewDataID FROM EMRTemplateTableColumnWidthsT INNER JOIN @tDataIDs T ON EMRTemplateTableColumnWidthsT.EMRDataID_Y = T.OldDataID \r\n"
			"WHERE EmrDetailID IN (SELECT ID FROM EmrTemplateDetailsT WHERE TemplateID IN (SELECT ID FROM EMRTemplateT WHERE Deleted = 0)) \r\n"
			"SET @nError = @@ERROR IF @nError <> 0 BEGIN RAISERROR('@@ERROR was %li!', 16, 1, @nError) ROLLBACK TRAN RETURN END\r\n"
			// (c.haag 2008-10-22 15:08) - PLID 31708 - EMRDataID_X
			"UPDATE EMRTemplateTableColumnWidthsT SET EMRDataID_X = NewDataID FROM EMRTemplateTableColumnWidthsT INNER JOIN @tDataIDs T ON EMRTemplateTableColumnWidthsT.EMRDataID_X = T.OldDataID \r\n"
			"WHERE EmrDetailID IN (SELECT ID FROM EmrTemplateDetailsT WHERE TemplateID IN (SELECT ID FROM EMRTemplateT WHERE Deleted = 0)) \r\n"
			"SET @nError = @@ERROR IF @nError <> 0 BEGIN RAISERROR('@@ERROR was %li!', 16, 1, @nError) ROLLBACK TRAN RETURN END\r\n"

			// (z.manning 2012-07-12 14:24) - PLID 50404 - I moved 3 (updating details' info IDs) before 1h (updating detail
			// table data) becaus there is now a trigger on EmrDetailTableDataT to ensure the info IDs of the row/column and
			// the detail are in sync. By updating EmrDetailsT first, we prevent this trigger from firing.
			//3) now reassign details' references to EMRInfoID
			
			//TES 12/5/2006 - PLID 23724 - Template details now just reference the EmrInfoMasterID, which hasn't changed.
			//3a) Reassign the EMRInfoT-referencing records in EMRTemplateDetailsT
			/*ExecuteSql("UPDATE EmrTemplateDetailsT SET EMRInfoID = %d WHERE EMRInfoID = %d AND TemplateID IN "
				"(SELECT ID FROM EMRTemplateT WHERE Deleted = 0)",
				nNewInfoID, nOldInfoID);*/

			//3b) Reassign the EMRInfoT-referencing in EMRDetailsT for the current detail
			//if we are editing a detail directly, then we will update just that item
			"IF (@nCalledFromDetailID != -1) BEGIN \r\n"
			"   UPDATE EMRDetailsT SET EMRInfoID = {INT} WHERE Deleted = 0 AND EMRInfoID = {INT} AND \r\n"
			"      EMRID IN (SELECT ID FROM EMRMasterT WHERE Deleted = 0 AND Status <> 2) AND \r\n"
			"      EMRDetailsT.ID = @nCalledFromDetailID \r\n"
			"   SET @nError = @@ERROR IF @nError <> 0 BEGIN RAISERROR('@@ERROR was %li!', 16, 1, @nError) ROLLBACK TRAN RETURN END\r\n"
			"END \r\n"

			//1h)  Continue reassignment of table information on the current detail
			//if we are editing a detail directly, then we will update just that item
			// Reassign any table column widths
			"IF (@nCalledFromDetailID != -1) BEGIN \r\n"
			"   UPDATE EMRDetailTableDataT SET EmrDataID_Y = NewDataID FROM EMRDetailTableDataT INNER JOIN @tDataIDs T ON EMRDetailTableDataT.EmrDataID_Y = T.OldDataID \r\n"
			"   WHERE EmrDetailID IN (\r\n"
			"          SELECT ID FROM EmrDetailsT WHERE Deleted = 0 AND \r\n"
			"           EMRID IN (SELECT ID FROM EMRMasterT WHERE Deleted = 0 AND Status <> 2) AND \r\n"
			"           EMRDetailsT.ID = @nCalledFromDetailID) \r\n"
			"   SET @nError = @@ERROR IF @nError <> 0 BEGIN RAISERROR('@@ERROR was %li!', 16, 1, @nError) ROLLBACK TRAN RETURN END\r\n"
			"   UPDATE EMRDetailTableDataT SET EmrDataID_X = NewDataID FROM EMRDetailTableDataT INNER JOIN @tDataIDs T ON EMRDetailTableDataT.EmrDataID_X = T.OldDataID \r\n"
			"   WHERE EmrDetailID IN (\r\n"
			"          SELECT ID FROM EmrDetailsT WHERE Deleted = 0 AND \r\n"
			"           EMRID IN (SELECT ID FROM EMRMasterT WHERE Deleted = 0 AND Status <> 2) AND \r\n"
			"           EMRDetailsT.ID = @nCalledFromDetailID\r\n"
			"          ) \r\n"
			"   SET @nError = @@ERROR IF @nError <> 0 BEGIN RAISERROR('@@ERROR was %li!', 16, 1, @nError) ROLLBACK TRAN RETURN END\r\n"
			"   UPDATE EMRTableColumnWidthsT SET EMRDataID_Y = NewDataID FROM EMRTableColumnWidthsT INNER JOIN @tDataIDs T ON EMRTableColumnWidthsT.EMRDataID_Y = T.OldDataID \r\n"
			"   WHERE EmrDetailID IN (\r\n"
			"          SELECT ID FROM EmrDetailsT WHERE Deleted = 0 AND EMRID IN (SELECT ID FROM EMRMasterT WHERE Deleted = 0 AND Status <> 2) AND \r\n"
			"           EMRDetailsT.ID = @nCalledFromDetailID) \r\n"
			"   SET @nError = @@ERROR IF @nError <> 0 BEGIN RAISERROR('@@ERROR was %li!', 16, 1, @nError) ROLLBACK TRAN RETURN END\r\n"
			// (c.haag 2008-10-22 13:55) - PLID 31708 - EmrDataID_X
			"	UPDATE EMRTableColumnWidthsT SET EmrDataID_X = NewDataID FROM EMRTableColumnWidthsT INNER JOIN @tDataIDs T ON EMRTableColumnWidthsT.EMRDataID_X = T.OldDataID \r\n"
			"   WHERE EmrDetailID IN (\r\n"
			"          SELECT ID FROM EmrDetailsT WHERE Deleted = 0 AND EMRID IN (SELECT ID FROM EMRMasterT WHERE Deleted = 0 AND Status <> 2) AND \r\n"
			"           EMRDetailsT.ID = @nCalledFromDetailID) \r\n"
			"   SET @nError = @@ERROR IF @nError <> 0 BEGIN RAISERROR('@@ERROR was %li!', 16, 1, @nError) ROLLBACK TRAN RETURN END\r\n"
			"END \r\n"

			//1i) (c.haag 2007-01-30 17:15) - PLID 24423 - Update the DrugList table
			"UPDATE DrugList SET EMRDataID = NewDataID FROM DrugList INNER JOIN @tDataIDs T ON DrugList.EMRDataID = T.OldDataID \r\n"
			"SET @nError = @@ERROR IF @nError <> 0 BEGIN RAISERROR('@@ERROR was %li!', 16, 1, @nError) ROLLBACK TRAN RETURN END\r\n"

			// (c.haag 2007-04-03 09:36) - PLID 25468 - Update the AllergyT table
			"UPDATE AllergyT SET EMRDataID = NewDataID FROM AllergyT INNER JOIN @tDataIDs T ON AllergyT.EMRDataID = T.OldDataID \r\n"
			"SET @nError = @@ERROR IF @nError <> 0 BEGIN RAISERROR('@@ERROR was %li!', 16, 1, @nError) ROLLBACK TRAN RETURN END\r\n"

			//TES 12/5/2006 - PLID 23724 - Action destinations now just reference the EmrInfoMasterID, which hasn't changed.
			/*// (j.jones 2006-09-21 14:11) - PLID 22640
			//4) reassign actions' references to EMRInfoID as a destination type
			ExecuteSql("UPDATE EMRActionsT SET DestID = %li WHERE DestType = %li AND DestID = %li", nNewInfoID, eaoEmrItem, nOldInfoID);*/

			// (a.walling 2009-07-01 16:50) - PLID 34759
			"IF {INT} <> (SELECT ActiveEmrInfoID FROM EmrInfoMasterT WHERE ID = {INT}) BEGIN RAISERROR('Item is out of date', 16, 41) ROLLBACK TRAN RETURN END; "

			//TES 12/6/2006 - PLID 23724 - Also, this is now the active version of this item.
			"UPDATE EmrInfoMasterT SET ActiveEmrInfoID = {INT} WHERE ID = {INT} \r\n"
			"SET @nError = @@ERROR IF @nError <> 0 BEGIN RAISERROR('@@ERROR was %li!', 16, 1, @nError) ROLLBACK TRAN RETURN END\r\n"

			"SET NOCOUNT OFF \r\n",
			
			strChangedDataIDXML, strChangeDropdownIDXML, strChangedHotSpotIDXML, GetCalledFromDetailID(),
			nNewInfoID, nOldInfoID, nOldInfoID, m_nEmrInfoMasterID, nNewInfoID, m_nEmrInfoMasterID);

		bSaved = TRUE;

	END_TRANS_CATCH_ALL("ReassignEmrInfoItem")

	//TES 10/28/2010 - PLID 41174 - Special logging
	if(IsSystemCurrentMedicationsItem()) {
		Log_CurrentMedicationsEdit("ReassignEmrInfoItem() returning " + CString(bSaved?"TRUE":"FALSE"));
	}
	return bSaved;
}

void CEmrItemEntryDlg::ClearChangedIDMap()
{
	if(m_pChangedIDMap) {
		// (a.walling 2007-11-05 16:08) - PLID 27980 - VS2008 - for() loops
		long i = 0;

		for (i=m_pChangedIDMap->aryChangedDataIDs.GetSize()-1; i>=0; i--) {

			EMRInfoChangedData *pData = (EMRInfoChangedData*)(m_pChangedIDMap->aryChangedDataIDs.GetAt(i));

			if(pData) {

				// (a.walling 2007-11-05 16:08) - PLID 27980 - VS2008 - for() loops
				long j = 0;

				for (j=pData->aryChangedActionIDs.GetSize()-1; j>=0; j--) {

					EMRInfoChangedAction *pAction = ((EMRInfoChangedAction*)pData->aryChangedActionIDs.GetAt(j));

					if(pAction) {						

						delete pAction;
						pAction = NULL;
					}
				}

				for (j=pData->aryChangedDropdownIDs.GetSize()-1; j>=0; j--) {

					EMRInfoChangedDropdown *pDropdown = ((EMRInfoChangedDropdown*)pData->aryChangedDropdownIDs.GetAt(j));

					if(pDropdown) {						

						// (z.manning 2009-02-12 14:48) - PLID 33058 - Clear out actions
						for(int nActionIndex = 0; nActionIndex < pDropdown->aryChangedActions.GetSize(); nActionIndex++) {
							EMRInfoChangedAction *pAction = pDropdown->aryChangedActions.GetAt(nActionIndex);
							if(pAction != NULL) {
								delete pAction;
							}
						}

						delete pDropdown;
						pDropdown = NULL;
					}
				}

				delete pData;
				pData = NULL;
			}
		}

		for (i=m_pChangedIDMap->aryChangedActionIDs.GetSize()-1; i>=0; i--) {

			EMRInfoChangedAction *pAction = ((EMRInfoChangedAction*)m_pChangedIDMap->aryChangedActionIDs.GetAt(i));

			if(pAction) {			

				delete pAction;
				pAction = NULL;
			}
		}

		//DRT 1/29/2008 - PLID 28602 - Cleanup hotspots & actions
		for(i = 0; i < m_pChangedIDMap->aryChangedHotSpotIDs.GetSize(); i++) {
			EMRInfoChangedHotSpot *pChangedSpot = m_pChangedIDMap->aryChangedHotSpotIDs.GetAt(i);

			//Delete all action objects for this hotspot
			int j = 0;
			for(j = 0; j < pChangedSpot->aryChangedActionIDs.GetSize(); j++) {
				EMRInfoChangedAction *pSpotAction = pChangedSpot->aryChangedActionIDs.GetAt(j);
				delete pSpotAction;
			}

			//delete the hotspot itself
			delete pChangedSpot;
		}

		delete m_pChangedIDMap;
		m_pChangedIDMap = NULL;
	}
}

EMRInfoChangedIDMap* CEmrItemEntryDlg::GetChangedIDMap()
{
	return m_pChangedIDMap;
}

// (b.cardillo 2007-01-11 11:24) - PLID 17929 - Added advanced spell checking (the behavior is 
// implemented in the CEmrItemEntryDlgSpellCheckHandler class, so here we begin the spell check 
// passing an object of that class as the spell-check handler).
void CEmrItemEntryDlg::OnSpellCheckBtn()
{
	//TES 3/15/2011 - PLID 42784 - A spell check is now happening, and hasn't made any changes to the datalist yet.
	m_bSpellCheckInProgress = true;
	m_bSpellCheckMadeChange = false;
		
	try {
		CWaitCursor wc;

		// Perform an advanced spell check of all controls on the screen in the designated order
		CEmrItemEntryDlgSpellCheckHandler handler(this);
		short nResult = PerformSpellCheck(this, handler);
		if (nResult >= 0) {
			// Report successful completion
			MessageBox("The spell check is complete.", NULL, MB_OK|MB_ICONINFORMATION);
		} else if (nResult != wSpellCancelErr) {
			// Report the error
		}
		//TES 3/15/2011 - PLID 42784 - The spell check is done.
		m_bSpellCheckInProgress = false;
		//TES 3/15/2011 - PLID 42784 - If it made changes that need to be reflected in the list, do so now.
		if(m_bSpellCheckMadeChange) {
			m_bSpellCheckMadeChange = false;
			ReflectDataElementList(sdeidPriorSelection);
		}
		return;
	}NxCatchAll(__FUNCTION__);

	//TES 3/15/2011 - PLID 42784 - There was an error in the spell checking, but we still want to reflect that it's done now.
	m_bSpellCheckInProgress = false;
	//TES 3/15/2011 - PLID 42784 - Now let's try and reflect any changes that were made before the error happened.  If this fails, so be it,
	// but at least it won't crash the dialog entirely.
	try {
		if(m_bSpellCheckMadeChange) {
			m_bSpellCheckMadeChange = false;
			ReflectDataElementList(sdeidPriorSelection);
		}
	}NxCatchAll(__FUNCTION__);
}

// (a.walling 2007-03-12 09:42) - PLID 19884 - Return whether this item is inactive
BOOL CEmrItemEntryDlg::GetInactive()
{
	return m_bInactive;
}

BOOL CEmrItemEntryDlg::IsSystemCurrentMedicationsItem() const
{
	return (eistCurrentMedicationsTable == (EmrInfoSubType)m_DataSubType) ? TRUE : FALSE;
}

BOOL CEmrItemEntryDlg::IsSystemAllergiesItem() const
{
	// (c.haag 2007-04-03 09:05) - PLID 25468 - Return TRUE if this is the system
	// allergies item that we're editing
	return (eistAllergiesTable == (EmrInfoSubType)m_DataSubType) ? TRUE : FALSE;
}

BOOL CEmrItemEntryDlg::GetAutoAlphabetizeRowData() const
{
	return m_bAutoAlphabetizeListData;
}

BOOL CEmrItemEntryDlg::GetAutoAlphabetizeColumnData() const
{
	// (c.haag 2007-04-11 12:36) - PLID 25468 - Also consider the system Allergies item
	return (m_bAutoAlphabetizeListData && !IsSystemCurrentMedicationsItem() && !IsSystemAllergiesItem()) ? TRUE : FALSE;
}

// (c.haag 2015-07-07) - PLID 65572 - We now allow the caller to pass in objects so that lookups are not required
CString CEmrItemEntryDlg::GetAuditSourceTypeText(EmrActionObject type, const CString& strSourceID,
	const CEmrInfoDataElement* peideSourceEmrDataItem /* = NULL */, const CEmrTableDropDownItem* pddiSourceTableDropdownItem /* = NULL */) const
{
	//
	// (c.haag 2007-03-06 12:04) - PLID 23943 - Calculates text used for auditing given a source type and source ID
	//

	// Calculate the EMR info item name
	CString strName;
	GetDlgItemText(IDC_ITEM_NAME, strName);
	strName.TrimRight();
	strName.TrimLeft();

	// Calculate the text
	CString strSourceTypeText;
	switch (type) {
	case eaoEmrItem:
		// If we get here, the action occurs when the item itself is added to a topic
		strSourceTypeText.Format("'%s' EMR Item", strName);
		break;
	case eaoEmrDataItem: 
	{
		// If we get here, the action occurs when a list item is selected
		if (NULL != peideSourceEmrDataItem)
		{
			// (c.haag 2015-07-07) - PLID 65572 - Use the input object
			strSourceTypeText.Format("'%s' List Item", peideSourceEmrDataItem->m_strData);
		}
		else
		{
			long nOrig = m_aryDataElements.FindDataElement(atoi(strSourceID), 0);
			if (nOrig != -1) {
				// Compare
				CEmrInfoDataElement *peideOriginal = m_aryDataElements.GetAt(nOrig);
				if (NULL == peideOriginal) {
					ASSERT(FALSE); // This should never happen
					ThrowNxException("Attempted to access a null data element while auditing changes!");
				}
				strSourceTypeText.Format("'%s' List Item", peideOriginal->m_strData);
			}
			else {
				ASSERT(FALSE); // This should never happen
				ThrowNxException("Attempted to access a non-existent data element while auditing changes!");
			}
		}
	} break;
	case eaoEmrImageHotSpot:
		//DRT 1/17/2008 - PLID 28602 - Added image hot spots
		strSourceTypeText.Format("Hot Spot for '%s' EMR Item", strName);
		break;
	case eaoEmrTableDropDownItem:
	{
		if (NULL != peideSourceEmrDataItem && NULL != pddiSourceTableDropdownItem)
		{
			// (c.haag 2015-07-07) - PLID 65572 - Use the input object
			strSourceTypeText.Format("'%s' Dropdown Item For '%s' Table Element", pddiSourceTableDropdownItem->strData, peideSourceEmrDataItem->m_strData);
		}
		else
		{
			// (z.manning 2009-02-12 10:00) - PLID 33029
			CEmrTableDropDownItem *pddi = NULL;
			CEmrInfoDataElement *peide = NULL;
			for (int nColIndex = 0; nColIndex < m_aryCurColumnDataElements.GetSize() && pddi == NULL; nColIndex++) {
				peide = m_aryCurColumnDataElements.GetAt(nColIndex);
				// (a.walling 2014-06-30 10:21) - PLID 62497
				pddi = peide->m_arypEMRDropDownList.FindDropdownElement(AsLong(_bstr_t(strSourceID)));
			}
			if (pddi == NULL) {
				ASSERT(FALSE);
				ThrowNxException("CEmrItemEntryDlg::GetAuditSourceTypeText - Could not find dropdown element with ID %s", strSourceID);
			}
			strSourceTypeText.Format("'%s' Dropdown Item For '%s' Table Element", pddi->strData, peide->m_strData);
		}
	} break;
	default: {
		// We should never get here
		ASSERT(FALSE);
		CString strErr;
		strErr.Format("Could not audit EMR action with a source type of %d!", (int)type);
		ThrowNxException(strErr);
		} break;
	}
	return strSourceTypeText;
}

CString CEmrItemEntryDlg::GetAuditDestTypeText(EmrActionObject type, long nDestID) const
{
	//
	// (c.haag 2007-03-06 12:04) - PLID 23943 - Calculates text used for auditing given a dest destination and destination ID.
	// If a field is nullable, its default value for GetTableField will be an empty string. If a field is not nullable, then
	// GetTableField can return a NULL variant if the record was deleted by someone. In that rare case, we can't tell the
	// difference between null and deleted records. So, we will still return an empty string for a nullable field, but return
	// a <deleted> placeholder value for non-nullable fields.
	//
	CString strActionText;
	switch (type) {
	case eaoCpt: // CPT Code / Inventory item
		strActionText.Format("charge '%s'", VarString(GetTableField("ServiceT", "Name", "ID", nDestID), "<deleted>"));
		break;
	// (b.savon 2014-07-14 11:12) - PLID 62706 - Deprecate the old Diag DestType and handle the changes Practice wide
	//case eaoDiag: // Diagnosis code
	//	strActionText.Format("diagnosis code '%s'", VarString(GetTableField("DiagCodes", "CodeDesc", "ID", nDestID), "<deleted>"));
	//	break;
	case eaoDiagnosis:
		strActionText.Format("diagnosis code '%s'",
			VarString(
				GetTableField(
					R"(EmrActionDiagnosisDataT 
						LEFT JOIN DiagCodes AS ICD9Q ON EmrActionDiagnosisDataT.DiagCodeID_ICD9 = ICD9Q.ID
						LEFT JOIN DiagCodes AS ICD10Q ON EmrActionDiagnosisDataT.DiagCodeID_ICD10 = ICD10Q.ID)",
					R"(CASE WHEN ICD10Q.CodeNumber IS NOT NULL AND ICD9Q.CodeNumber IS NOT NULL THEN (ICD10Q.CodeNumber + ' - ' + ICD10Q.CodeDesc + ' (' + ICD9Q.CodeNumber + ')') ELSE
						CASE WHEN ICD10Q.CodeNumber IS NOT NULL THEN (ICD10Q.CodeNumber + ' - ' + ICD10Q.CodeDesc) ELSE 
						CASE WHEN ICD9Q.CodeNumber IS NOT NULL THEN (ICD9Q.CodeNumber + ' - ' + ICD9Q.CodeDesc) END END END)",
					"EmrActionID",
					nDestID
				),
				"<deleted>"
			)
		);
		break;
	case eaoEmrItem: // EMR item
		strActionText.Format("EMR item '%s'", VarString(GetTableField("EmrInfoT", "Name", "ID", nDestID), "<deleted>"));
		break;
	case eaoProcedure: // Procedure
		strActionText.Format("procedure '%s'", VarString(GetTableField("ProcedureT", "Name", "ID", nDestID),""));
		break;
	case eaoMint: // Create new EMN's
		strActionText.Format("new EMN '%s'", VarString(GetTableField("EmrTemplateT", "Name", "ID", nDestID),""));
		break;
	case eaoMedication: // Medication
		strActionText.Format("new medication '%s'", VarString(GetTableField("(EMRDataT INNER JOIN DrugList ON DrugList.EmrDataID = EmrDataT.ID)", "Data", "DrugList.ID", nDestID), "<deleted>"));
		break;
	case eaoMintItems: // EMR items from templates
		strActionText.Format("EMR items from template '%s'", VarString(GetTableField("EmrTemplateT", "Name", "ID", nDestID),""));
		break;
	case eaoTodo: // (c.haag 2008-06-04 10:01) - PLID 30221 - Spawn todo alarms
		strActionText.Format("EMR todo alarms");
		break;
	case eaoLab: // (z.manning 2008-10-01 14:58) - PLID 31556
		strActionText.Format("lab '%s'", VarString(GetTableField("LabProceduresT", "Name", "ID", nDestID), ""));
		break;
	default: {
		// We should never get here
		ASSERT(FALSE);
		CString strErr;
		strErr.Format("Could not audit EMR action with a destination type of %d!", (int)type);
		ThrowNxException(strErr);
		} break;
	}
	return strActionText;
}

// (j.jones 2007-08-13 17:29) - PLID 27052 - added E/M categories
void CEmrItemEntryDlg::OnEditEmrEmCategories() 
{
	try {

		// (j.jones 2011-03-08 12:25) - PLID 42282 - added m_eEMCodeUseTableCategories,
		// which requires special handling in this function

		NXDATALIST2Lib::IRowSettingsPtr pRow = m_pdlEMCategoryCombo->CurSel;

		long nCurEMCodeCategoryID = -1;
		EMCodeUseTableCategories eCurEMCodeUseTableCategories = emcutcNone;
		if(pRow) {
			nCurEMCodeCategoryID = VarLong(pRow->GetValue(emcccID),-1);			
			eCurEMCodeUseTableCategories = (EMCodeUseTableCategories)VarLong(pRow->GetValue(emcccUseTableCategories), (long)emcutcNone);
		}

		CEMREMCodeCategorySetupDlg dlg(this);
		dlg.DoModal();

		m_pdlEMCategoryCombo->Requery();

		// (j.jones 2011-03-08 12:25) - PLID 42282 - because the row/column lists do not requery,
		// we must force the E/M category combo to reload its sql
		RequeryTableEMCategoryComboColumns();

		// (j.jones 2011-03-08 12:25) - PLID 42282 - if a table, ensure
		// we have the rows for configuring categories per row or column
		EnsureEMCodeUseTableCategoriesListOptions(m_nDataType == 7);

		if(pRow) {
			if(m_nDataType == 7 && eCurEMCodeUseTableCategories != emcutcNone) {				
				NXDATALIST2Lib::IRowSettingsPtr pRow = m_pdlEMCategoryCombo->SetSelByColumn(emcccUseTableCategories, (long)eCurEMCodeUseTableCategories);
				//ASSERT to make sure we have the row we are looking for
				ASSERT(pRow != NULL);
			}
			else {
				m_pdlEMCategoryCombo->SetSelByColumn(emcccID, (long)nCurEMCodeCategoryID);
			}
		}

	} NxCatchAll("CEmrItemEntryDlg::OnEditEmrEmCategories");
}

// (j.jones 2007-08-13 17:29) - PLID 27052 - added E/M categories
void CEmrItemEntryDlg::OnSelChosenEmrEmCategories(LPDISPATCH lpRow) 
{
	try {

		//if nothing selected, warn them, because we can't save this item
		//with the E/M settings enabled and no E/M category, and we can't
		//access the category without the E/M settings enabled

		NXDATALIST2Lib::IRowSettingsPtr pRow(lpRow);

		if(pRow == NULL) {
			AfxMessageBox("An item that calculates E/M elements must have an E/M category selected.\n\n"
				"If you do not select a category, and do not disable this item's setting to calculate E/M elements,\n"
				"you will not be permitted to save your changes.");
		}

		// (j.jones 2011-03-08 12:25) - PLID 42282 - now this selection might alter our row/column lists,
		// so call ReflectEMCodeInterface to update the columns properly
		ReflectEMCodeInterface();

	} NxCatchAll("CEmrItemEntryDlg::OnSelChosenEmrEmCategories");
}

// (j.jones 2007-08-14 10:14) - PLID 27053 - added setup for E/M Coding
void CEmrItemEntryDlg::OnCheckUseForEmCoding() 
{
	try {

		//enable/disable controls accordingly
		ReflectEMCodeInterface();

	} NxCatchAll("CEmrItemEntryDlg::OnCheckUseForEmCoding");
}

// (j.jones 2007-08-14 10:14) - PLID 27053 - added setup for E/M Coding
void CEmrItemEntryDlg::OnSelChosenEmrEmCodeType(LPDISPATCH lpRow) 
{
	try {

		//if nothing selected, warn them, because we can't save this item
		//with the E/M settings enabled and no code type selected, and we can't
		//access the code type without the E/M settings enabled

		NXDATALIST2Lib::IRowSettingsPtr pRow(lpRow);

		if(pRow == NULL) {
			AfxMessageBox("An item that calculates E/M elements must have an E/M coding method selected.\n\n"
				"If you do not select a coding method, and do not disable this item's setting to calculate E/M elements,\n"
				"you will not be permitted to save your changes.");

			//hide the row/column E/M settings

			return;
		}

		//if we have a row, and the item is a table, show or hide the row/column E/M settings
		ReflectDataElementList(sdeidPriorSelection); // refresh

	} NxCatchAll("CEmrItemEntryDlg::OnSelChosenEmrEmCodeType");
}

// (j.jones 2007-08-14 12:00) - PLID 27053 - enables/disables E/M controls, and rebuilds the E/M code type combo based on the data type
void CEmrItemEntryDlg::ReflectEMCodeInterface() {

	try {

		// (j.jones 2013-01-17 15:35) - PLID 54676 - narratives do not use E/M either
		long nCurDataType = CalcDataTypeByCurSelection();
		if(nCurDataType == eitImage || nCurDataType == eitNarrative) {
			CheckDlgButton(IDC_CHECK_USE_FOR_EM_CODING, FALSE);
			GetDlgItem(IDC_CHECK_USE_FOR_EM_CODING)->EnableWindow(FALSE);
		}
		else {
			GetDlgItem(IDC_CHECK_USE_FOR_EM_CODING)->EnableWindow(TRUE);
			CRect rect;
			GetDlgItem(IDC_CHECK_USE_FOR_EM_CODING)->GetWindowRect(&rect);
			ScreenToClient(&rect);
			InvalidateRect(&rect);
		}

		//display controls accordingly
		BOOL bEnableEMControls = IsDlgButtonChecked(IDC_CHECK_USE_FOR_EM_CODING);

		//enable/disable the category controls
		m_pdlEMCategoryCombo->Enabled = bEnableEMControls;
		GetDlgItem(IDC_EDIT_EMR_EM_CATEGORIES)->EnableWindow(bEnableEMControls);

		// (j.jones 2011-03-08 12:25) - PLID 42282 - preserve the current selection
		NXDATALIST2Lib::IRowSettingsPtr pRow = m_pdlEMCodeTypeCombo->CurSel;
		EMCodingTypes eCurEMCodeTypeID = emctUndefined;
		if(pRow) {
			eCurEMCodeTypeID = (EMCodingTypes)VarLong(pRow->GetValue(0),emctUndefined);
		}

		//clear the current dropdown options
		m_pdlEMCodeTypeCombo->Clear();

		//if E/M Coding is disabled, don't populate the dropdown, instead hide it completely
		if(!bEnableEMControls) {
			GetDlgItem(IDC_EMR_EM_CODE_TYPE_CAPTION)->ShowWindow(SW_HIDE);
			GetDlgItem(IDC_EMR_EM_CODE_TYPE)->ShowWindow(SW_HIDE);
			return;
		}

		// (j.jones 2011-03-08 12:25) - PLID 42282 - if a table, ensure
		// we have the rows for configuring categories per row or column
		EnsureEMCodeUseTableCategoriesListOptions(nCurDataType == 7);
		
		//build accordingly by the current data type

		switch(nCurDataType) {
			case 1:	//text
			case 2:	//single-select
			case 4: //image
			case 5: //slider
			case 6: //narrative

				//leave the dropdown blank, and hide it
				GetDlgItem(IDC_EMR_EM_CODE_TYPE_CAPTION)->ShowWindow(SW_HIDE);
				GetDlgItem(IDC_EMR_EM_CODE_TYPE)->ShowWindow(SW_HIDE);
				break;
			
			case 3: //multi-select list

				//one element for the detail, when the multi-select detail has data selected
				AddEMCodeRow(emctMultiSelectOnePerDetail);				

				//one element for each selected list item in a multi-select detail
				AddEMCodeRow(emctMultiSelectOnePerListItem);

				//and now display the dropdown
				GetDlgItem(IDC_EMR_EM_CODE_TYPE_CAPTION)->ShowWindow(SW_SHOW);
				GetDlgItem(IDC_EMR_EM_CODE_TYPE)->ShowWindow(SW_SHOW);

				break;
					
			case 7:
				
				// (j.jones 2011-03-08 12:25) - PLID 42282 - we now have different rules
				// if they picked a category per row or per column
				if(NeedTableRowEMCodeCategoryColumn()) {

					//one element for the detail, for each category selected on any row
					AddEMCodeRow(emctTableOnePerDetail_PerRowCategory);

					//one element for each row that has at least one cell filled in, for the category selected on that row
					AddEMCodeRow(emctTableOnePerRow_PerRowCategory);

					//one element for each cell filled in per row, for the category selected on that row
					AddEMCodeRow(emctTableOnePerCell_PerRowCategory);

					//one element for each row that has all cells filled in, for the category selected on that row
					AddEMCodeRow(emctTableOnePerCompleteRow_PerRowCategory);
				}
				else if(NeedTableColumnEMCodeCategoryColumn()) {

					//one element for the detail, for each category selected on any column
					AddEMCodeRow(emctTableOnePerDetail_PerColumnCategory);

					//one element for each column that has at least one cell filled in, for the category selected on that column
					AddEMCodeRow(emctTableOnePerColumn_PerColumnCategory);

					//one element for each cell filled in per column, for the category selected on that column
					AddEMCodeRow(emctTableOnePerCell_PerColumnCategory);

					//one element for each column that has all cells filled in, for the category selected on that column
					AddEMCodeRow(emctTableOnePerCompleteColumn_PerColumnCategory);
				}
				else {
					//one element for the detail, when the table has any data filled
					AddEMCodeRow(emctTableOnePerDetail);

					//one element for the detail, when the table has any data filled, if the data is in a specified row				
					AddEMCodeRow(emctTableOnePerDetail_SpecifyRow);

					//one element for the detail, when the table has any data filled, if the data is in a specified column
					AddEMCodeRow(emctTableOnePerDetail_SpecifyColumn);

					//one element for each cell filled in on the table
					AddEMCodeRow(emctTableOnePerCell);

					//one element for each cell filled in, if the cell is in a specified row
					AddEMCodeRow(emctTableOnePerCell_SpecifyRow);

					//one element for each cell filled in, if the cell is in a specified column
					AddEMCodeRow(emctTableOnePerCell_SpecifyColumn);

					//one element for each row that has at least one cell filled in, if the cell is in a specified row
					AddEMCodeRow(emctTableOnePerRow_SpecifyRow);

					//one element for each column that has at least one cell filled in, if the cell is in a specified column
					AddEMCodeRow(emctTableOnePerColumn_SpecifyColumn);

					//one element for each row that has all cells filled in, if the row is specified
					AddEMCodeRow(emctTableOnePerCompleteRow_SpecifyRow);

					//one element for each column that has all cells filled in, if the column is specified
					AddEMCodeRow(emctTableOnePerCompleteColumn_SpecifyColumn);
				}

				//and now display the dropdown
				GetDlgItem(IDC_EMR_EM_CODE_TYPE_CAPTION)->ShowWindow(SW_SHOW);
				GetDlgItem(IDC_EMR_EM_CODE_TYPE)->ShowWindow(SW_SHOW);

				break;
		}

		// (j.jones 2011-03-08 12:25) - PLID 42282 - try to preserve the previous selection
		if(eCurEMCodeTypeID != emctUndefined) {
			m_pdlEMCodeTypeCombo->SetSelByColumn(0, (long)eCurEMCodeTypeID);
		}

		// (j.jones 2011-03-08 12:25) - PLID 42282 - if the selection is blank, but there are
		// rule options, select the first value
		if(m_pdlEMCodeTypeCombo->GetRowCount() > 0 && m_pdlEMCodeTypeCombo->GetCurSel() == NULL) {
			m_pdlEMCodeTypeCombo->CurSel = m_pdlEMCodeTypeCombo->GetFirstRow();
		}

		// (j.jones 2011-03-08 12:25) - PLID 42282 - ensure our data element list is displayed properly
		ReflectDataElementList(sdeidPriorSelection);

	} NxCatchAll("CEmrItemEntryDlg::ReflectEMCodeInterface");
}

// (j.jones 2007-08-15 11:17) - PLID 27053 - returns the name associated with each code type
// (j.jones 2007-09-17 11:52) - PLID 27336 - renamed all references to "detail" to say "EMR item"
// (j.jones 2013-01-04 14:48) - PLID 28135 - changed all references to say E/M, and not use an ampersand
CString CEmrItemEntryDlg::GetEMCodeTypeName(EMCodingTypes emctCodeType)
{
	// (c.haag 2008-10-27 17:45) - PLID 31708 - Change the language based on table flipping state
	CString strRowType = IsDlgButtonChecked(IDC_TABLE_ROWS_AS_FIELDS) ? "column" : "row";
	CString strColType = IsDlgButtonChecked(IDC_TABLE_ROWS_AS_FIELDS) ? "row" : "column";

	switch(emctCodeType) {

		case emctMultiSelectOnePerDetail:
			//one element for the detail, when the multi-select detail has data selected
			return "Count 1 element for the EMR item, when any list item is checked";
			break;
		case emctMultiSelectOnePerListItem:
			//one element for each selected list item in a multi-select detail
			return "Count 1 element for each list item that is checked";
			break;

		case emctTableOnePerDetail:
			//one element for the detail, when the table has any data filled
			return "Count 1 element for the EMR item, when any table cell is filled";
			break;

		case emctTableOnePerDetail_SpecifyRow:
			//one element for the detail, when the table has any data filled, if the data is in a specified row
			return "Count 1 element for the EMR item, when any cell is filled in the checked E/M " + strRowType + "s";
			break;
				
		case emctTableOnePerDetail_SpecifyColumn:
			//one element for the detail, when the table has any data filled, if the data is in a specified column
			return "Count 1 element for the EMR item, when any cell is filled in the checked E/M " + strColType + "s";
			break;

		case emctTableOnePerCell:
			//one element for each cell filled in on the table
			return "Count 1 element for each table cell that is filled in";
			break;

		case emctTableOnePerCell_SpecifyRow:
			//one element for each cell filled in, if the cell is in a specified row
			return "Count 1 element for each table cell that is filled for a checked E/M " + strRowType;
			break;

		case emctTableOnePerCell_SpecifyColumn:
			//one element for each cell filled in, if the cell is in a specified column
			return "Count 1 element for each table cell that is filled for a checked E/M " + strColType;
			break;
				
		case emctTableOnePerRow_SpecifyRow:
			//one element for each row that has at least one cell filled in, if the cell is in a specified row
			return "Count 1 element for each checked E/M " + strRowType + ", when any cell is filled in that " + strRowType;
			break;
				
		case emctTableOnePerColumn_SpecifyColumn:
			//one element for each column that has at least one cell filled in, if the cell is in a specified column
			return "Count 1 element for each checked E/M " + strColType + ", when any cell is filled in that " + strColType;
			break;

		case emctTableOnePerCompleteRow_SpecifyRow:
			//one element for each row that has all cells filled in, if the row is specified
			return "Count 1 element for each checked E/M " + strRowType + " that has all of its cells filled in";
			break;
				
		case emctTableOnePerCompleteColumn_SpecifyColumn:
			//one element for each column that has all cells filled in, if the column is specified
			return "Count 1 element for each checked E/M " + strColType + " that has all of its cells filled in";
			break;

		// (j.jones 2011-03-08 12:25) - PLID 42282 - added new rules for when a table has E/M categories configured per row or per column
		case emctTableOnePerDetail_PerRowCategory:
			//one element for the detail, for each category selected on any row
			return "Count 1 element for the EMR item, for each category selected on any " + strRowType;
			break;

		case emctTableOnePerRow_PerRowCategory:
			//one element for each row that has at least one cell filled in, for the category selected on that row
			return "Count 1 element for each " + strRowType + " with a category selected, when any cell is filled in that " + strRowType;
			break;

		case emctTableOnePerCell_PerRowCategory:
			//one element for each cell filled in per row, for the category selected on that row
			return "Count 1 element for each cell that is filled for a " + strRowType + " with a category selected";
			break;

		case emctTableOnePerCompleteRow_PerRowCategory:
			//one element for each row that has all cells filled in, for the category selected on that row
			return "Count 1 element for each " + strRowType + " with a category selected, that has all of its cells filled in";
			break;

		case emctTableOnePerDetail_PerColumnCategory:
			//one element for the detail, for each category selected on any column
			return "Count 1 element for the EMR item, for each category selected on any " + strColType;
			break;

		case emctTableOnePerColumn_PerColumnCategory:
			//one element for each column that has at least one cell filled in, for the category selected on that column
			return "Count 1 element for each " + strColType + " with a category selected, when any cell is filled in that " + strColType;
			break;

		case emctTableOnePerCell_PerColumnCategory:
			//one element for each cell filled in per column, for the category selected on that column
			return "Count 1 element for each cell that is filled for a " + strColType + " with a category selected";
			break;

		case emctTableOnePerCompleteColumn_PerColumnCategory:
			//one element for each column that has all cells filled in, for the category selected on that column
			return "Count 1 element for each " + strColType + " with a category selected, that has all of its cells filled in";
			break;

		default:
			return "";
			break;
	}
}

// (j.jones 2007-08-15 11:23) - PLID 27053 - adds an E/M code type row to the code type combo
void CEmrItemEntryDlg::AddEMCodeRow(EMCodingTypes emctCodeType)
{
	NXDATALIST2Lib::IRowSettingsPtr pRow;
	pRow = m_pdlEMCodeTypeCombo->GetNewRow();
	pRow->PutValue(emctcID, (long)emctCodeType);
	pRow->PutValue(emctcDesc, _bstr_t(GetEMCodeTypeName(emctCodeType)));
	m_pdlEMCodeTypeCombo->AddRowAtEnd(pRow, NULL);
}

// (j.jones 2007-08-15 13:04) - PLID 27053 - determine if we require the E/M column for a table row
// (c.haag 2008-10-27 17:54) - PLID 31708 - Note: This pertains to the LOGICAL, not the DATALIST, detail data row
BOOL CEmrItemEntryDlg::NeedTableRowEMColumn()
{
	if(IsDlgButtonChecked(IDC_CHECK_USE_FOR_EM_CODING) && IsDlgButtonChecked(IDC_RADIO_TABLE)) {
		NXDATALIST2Lib::IRowSettingsPtr pEMCodeRow = m_pdlEMCodeTypeCombo->CurSel;
		if(pEMCodeRow) {

			EMCodingTypes emctCodeType = (EMCodingTypes)VarLong(pEMCodeRow->GetValue(emctcID), emctUndefined);

			//find the specify-row types
			if(emctCodeType == emctTableOnePerDetail_SpecifyRow
				|| emctCodeType == emctTableOnePerCell_SpecifyRow
				|| emctCodeType == emctTableOnePerRow_SpecifyRow
				|| emctCodeType == emctTableOnePerCompleteRow_SpecifyRow) {

				return TRUE;
			}
		}
	}

	//if we get here, we do not need the E/M column for table rows
	return FALSE;
}

// (j.jones 2007-08-15 13:04) - PLID 27053 - determine if we require the E/M column for a table column
// (c.haag 2008-10-27 17:54) - PLID 31708 - Note: This pertains to the LOGICAL, not the DATALIST, detail data column
BOOL CEmrItemEntryDlg::NeedTableColumnEMColumn()
{
	if(IsDlgButtonChecked(IDC_CHECK_USE_FOR_EM_CODING) && IsDlgButtonChecked(IDC_RADIO_TABLE)) {
		NXDATALIST2Lib::IRowSettingsPtr pEMCodeRow = m_pdlEMCodeTypeCombo->CurSel;
		if(pEMCodeRow) {

			EMCodingTypes emctCodeType = (EMCodingTypes)VarLong(pEMCodeRow->GetValue(emctcID), emctUndefined);

			//find the specify-column types
			if(emctCodeType == emctTableOnePerDetail_SpecifyColumn
				|| emctCodeType == emctTableOnePerCell_SpecifyColumn
				|| emctCodeType == emctTableOnePerColumn_SpecifyColumn
				|| emctCodeType == emctTableOnePerCompleteColumn_SpecifyColumn) {

				return TRUE;
			}
		}
	}

	//if we get here, we do not need the E/M column for table columns
	return FALSE;
}

// (j.jones 2011-03-08 12:25) - PLID 42282 - supported E/M categories per item
BOOL CEmrItemEntryDlg::NeedTableRowEMCodeCategoryColumn()
{
	//return true if the E/M category says to assign a category per row

	if(IsDlgButtonChecked(IDC_CHECK_USE_FOR_EM_CODING) && IsDlgButtonChecked(IDC_RADIO_TABLE)) {
		NXDATALIST2Lib::IRowSettingsPtr pRow = m_pdlEMCategoryCombo->GetCurSel();
		if(pRow) {
			// (j.jones 2011-03-08 12:25) - PLID 42282 - added m_eEMCodeUseTableCategories
			EMCodeUseTableCategories eCurEMCodeUseTableCategories = (EMCodeUseTableCategories)VarLong(pRow->GetValue(emcccUseTableCategories), (long)emcutcNone);
			if(eCurEMCodeUseTableCategories == emcutcPerRow) {
				return TRUE;
			}
		}
	}

	return FALSE;
}

BOOL CEmrItemEntryDlg::NeedTableColumnEMCodeCategoryColumn()
{
	//return true if the E/M category says to assign a category per column

	if(IsDlgButtonChecked(IDC_CHECK_USE_FOR_EM_CODING) && IsDlgButtonChecked(IDC_RADIO_TABLE)) {
		NXDATALIST2Lib::IRowSettingsPtr pRow = m_pdlEMCategoryCombo->GetCurSel();
		if(pRow) {
			// (j.jones 2011-03-08 12:25) - PLID 42282 - added m_eEMCodeUseTableCategories
			EMCodeUseTableCategories eCurEMCodeUseTableCategories = (EMCodeUseTableCategories)VarLong(pRow->GetValue(emcccUseTableCategories), (long)emcutcNone);
			if(eCurEMCodeUseTableCategories == emcutcPerColumn) {
				return TRUE;
			}
		}
	}

	return FALSE;
}

//DRT - 1/11/2008 - PLID 28602 - Allow the user to define hotspots for the image
void CEmrItemEntryDlg::OnModifyHotspots() 
{
	try {
		//DRT 2/19/2008 - PLID 28602
		if(m_strCurImagePath.IsEmpty() || m_btnEmrImage.m_image == NULL) {
			AfxMessageBox("You must select an image before attempting to place hotspots.");
			return;
		}

		CEMRImageHotspotSetupDlg dlg(this);

		dlg.m_strBackgroundImage = m_strCurImagePath;
		dlg.m_pCurrentEMN = m_pCurrentEMN;
		dlg.m_nInfoID = m_nID;
		dlg.m_strSourceItemName = m_strName;
		//DRT 2/26/2008 - PLID 28603 - Give a ptr to the array so that hotspots aren't deleted if they're in use.
		dlg.m_paryCurrentImageDetails = &m_aryCurrentImageDetails;
		dlg.m_bMaintainCurrentImage = m_bMaintainCurrentImage;

		//We will fill the "current" hotspot array by reviewing the 4 arrays we have kept in this dialog for change tracking.  This is
		//	fairly complex, because we need to keep a lot of data in case they open & close the dialog repeatedly.
		int i = 0;
		//	1)  Start by filling it with all of the last saved ones.
		for(i = 0; i < m_aryLastSavedHotSpots.GetSize(); i++) {
			CEMRHotSpot *pSpot = m_aryLastSavedHotSpots.GetAt(i);
			//	2)  Now remove everything that has been deleted since we started and don't add them.
			bool bAdd = true;
			for(int nDeletedIdx = 0; nDeletedIdx < m_aryRemovedHotSpots.GetSize(); nDeletedIdx++) {
				if(m_aryRemovedHotSpots.GetAt(nDeletedIdx)->GetID() == pSpot->GetID()) {
					//This particular hotspot has been deleted by the user, in a previous opening of the dialog.  Don't
					//	show it again.
					bAdd = false;
				}
			}

			if(bAdd) {
				dlg.m_aryStartingHotSpots.Add(pSpot);
			}
		}
		//	3)  We need not worry about the changed ones, because we're referencing the same pointers.  Note that only actions
		//		can change for a hotspot, you cannot move or reposition it once placed.  If we some day allow that functionality, 
		//		you'll have to do some copying out of the m_aryLastSaved..., possibly no longer using pointers.

		//	4)  Add all of the new hotspots.
		for(i = 0; i < m_aryNewHotSpots.GetSize(); i++) {
			dlg.m_aryStartingHotSpots.Add(m_aryNewHotSpots.GetAt(i));
		}

		if(dlg.DoModal() == IDOK) {
			//Save data
			CArray<CEMRHotSpot*, CEMRHotSpot*> *pary;

			//1)  Parse the removal list, and drop anything in here from our change or add lists.
			pary = &dlg.m_aryRemovedSpots;
			for(i = 0; i < pary->GetSize(); i++) {
				CEMRHotSpot *pSpot = pary->GetAt(i);

				//Search our add list for any matches.  Note that an item cannot be both new and changed, so
				//	we do not need to search both lists if we find in the first.
				bool bDone = false;
				for(int nAddIdx = 0; nAddIdx < m_aryNewHotSpots.GetSize() && !bDone; nAddIdx++) {
					if(m_aryNewHotSpots.GetAt(nAddIdx) == pSpot) {
						//Found it, so drop it.
						m_aryNewHotSpots.RemoveAt(nAddIdx);
						bDone = true;

						//Extra!  We are in charge of memory allocation / deallocation.  Therefore if a new spot
						//	were allocated and then deleted, its memory needs cleaned up now, since the final
						//	saving of this dialog will not touch it.
						delete pSpot;
						pSpot = NULL;

						//I'm not bothering to drop this from the dialog's array of removed spots, as this is the 
						//	1 and only traversal of that array before it goes out of scope.
					}
				}

				//Search our change list for any matches
				for(int nChangeIdx = 0; nChangeIdx < m_aryNewHotSpots.GetSize() && !bDone; nChangeIdx++) {
					if(m_aryNewHotSpots.GetAt(nChangeIdx) == pSpot) {
						//Found it, so drop it.
						m_aryNewHotSpots.RemoveAt(nChangeIdx);
						bDone = true;

						//We do not need to cleanup memory for changed spots, they will be cleaned from our m_aryLastSaved...
					}
				}

				if(!bDone) {
					//It was not found in our existing lists, so it must be a previously saved HotSpot.  Save it so the ItemEntry savin
					//	can remove it from data.
					m_aryRemovedHotSpots.Add(pSpot);
				}
			}

			//2)  Parse the change list, and make sure it exists in our change list.
			pary = &dlg.m_aryChangedSpots;
			for(i = 0; i < pary->GetSize(); i++) {
				//Things could change multiple times.  Make sure it doesn't already exist
				bool bFound = false;
				for(int nChangeIdx = 0; nChangeIdx < m_aryChangedHotSpots.GetSize() && bFound == false; nChangeIdx++) {
					if(m_aryChangedHotSpots.GetAt(nChangeIdx) == pary->GetAt(i)) {
						bFound = true;
					}
				}

				if(!bFound) {
					m_aryChangedHotSpots.Add(pary->GetAt(i));
				}
			}

			//3)  Parse the new list and add them all to our add list
			pary = &dlg.m_aryNewSpots;
			for(i = 0; i < pary->GetSize(); i++) {
				m_aryNewHotSpots.Add(pary->GetAt(i));
			}

			//And that's it.  The saving handler of this dialog will work with those arrays to 
			//	put them in data.
		}
	} NxCatchAll("Error in OnModifyHotSpots");
}

void CEmrItemEntryDlg::OnBtnEditTableCalculatedField() 
{
	try
	{
		OpenCalculatedFieldEditor(NULL);

	}NxCatchAll("CEmrItemEntryDlg::OnBtnEditTableCalculatedField");
}

void CEmrItemEntryDlg::OpenCalculatedFieldEditor(CEmrInfoDataElement *peide)
{
	if(!AtLeastOneActiveRowAndColumn()) {
		return;
	}

	// (z.manning 2011-05-04 15:41) - PLID 43560 - If this table doesn't have any formulas then we probably haven't
	// set the visible indices, so we must do that now before we open the formula editor.
	if(!m_bHasFormulas) {
		UpdateVisibleIndices(TRUE);
	}

	// (j.jones 2011-07-08 13:18) - PLID 43032 - now we pass in m_DataSubType
	CEmrTableEditCalculatedFieldDlg dlg(m_aryCurDataElements, m_aryCurColumnDataElements, this, m_DataSubType);
	// (c.haag 2008-10-23 15:02) - PLID 31735 - The dialog needs to know whether the table is flipped
	dlg.m_bTableRowsAsFields = IsDlgButtonChecked(IDC_TABLE_ROWS_AS_FIELDS) ? TRUE : FALSE;
	if(peide != NULL) {
		if(peide->m_nListType >= 3) {
			dlg.SetEditingColumn(peide->m_nSortOrder);
		}
		else {
			dlg.SetEditingRow(peide->m_nSortOrder);
		}
	}

	// (z.manning, 05/22/2008) - PLID 30145 - Open the formula editor dialog
	if(dlg.DoModal() == IDOK)
	{
		// (z.manning 2011-05-04 15:11) - PLID 43560 - Reset the has formula flag since they may have just changed some.
		m_bHasFormulas = FALSE;

		// (z.manning 2008-06-05 09:25) - Update all Row formulas
		for(int nRow = 0; nRow < dlg.GetRows()->GetSize(); nRow++)
		{
			long nArrayIndex = GetCurDataElementArrayIndex(dlg.GetRows()->GetAt(nRow)->m_nSortOrder, FALSE);
			CEmrInfoDataElement *pRowData = m_aryCurDataElements.GetAt(nArrayIndex);
			pRowData->m_strFormula = dlg.GetRows()->GetAt(nRow)->m_strFormula;
			pRowData->m_nDecimalPlaces = dlg.GetRows()->GetAt(nRow)->m_nDecimalPlaces;
			// (z.manning 2011-05-26 15:12) - PLID 43865 - Handle flags as well
			pRowData->m_nFlags = dlg.GetRows()->GetAt(nRow)->m_nFlags;
			if(!pRowData->m_strFormula.IsEmpty()) {
				// (z.manning 2011-05-04 15:26) - PLID 43560 - Flag this item as having a formula.
				m_bHasFormulas = TRUE;
			}
		}
		// (z.manning 2008-06-05 09:25) - Update all column formulas
		for(int nCol = 0; nCol < dlg.GetColumns()->GetSize(); nCol++)
		{
			long nArrayIndex = GetCurDataElementArrayIndex(dlg.GetColumns()->GetAt(nCol)->m_nSortOrder, TRUE);
			CEmrInfoDataElement *pColumnData = m_aryCurColumnDataElements.GetAt(nArrayIndex);
			pColumnData->m_strFormula = dlg.GetColumns()->GetAt(nCol)->m_strFormula;
			pColumnData->m_nDecimalPlaces = dlg.GetColumns()->GetAt(nCol)->m_nDecimalPlaces;
			// (z.manning 2011-05-26 15:12) - PLID 43865 - Handle flags as well
			pColumnData->m_nFlags = dlg.GetColumns()->GetAt(nCol)->m_nFlags;
			if(!pColumnData->m_strFormula.IsEmpty()) {
				// (z.manning 2011-05-04 15:26) - PLID 43560 - Flag this item as having a formula.
				m_bHasFormulas = TRUE;
			}
		}
	}
}

// (z.manning, 05/30/2008) - PLID 16443 - Will go through all columns and update the visible index
// for each element.
void CEmrItemEntryDlg::UpdateVisibleIndices(BOOL bForceUpdate /* = FALSE */)
{
	// (z.manning 2011-05-04 15:28) - PLID 43560 - There is no need to do this if this item does not have any formulas.
	// (j.gruber 2013-09-27 07:46) - PLID 58676 - now needed for table cells
	if((!m_bHasFormulas && (m_TableCellCodes.size() == 0 && m_SavedCellCodes.size() == 0)) && !bForceUpdate) {
		return;
	}

	long nIndex;
	for(nIndex = 0; nIndex < m_aryCurColumnDataElements.GetSize(); nIndex++)
	{
		CEmrInfoDataElement *peide = m_aryCurColumnDataElements.GetAt(nIndex);
		peide->m_nVisibleIndex = GetCurVisibleIndex(peide->m_nSortOrder, TRUE);
	}

	for(nIndex = 0; nIndex < m_aryCurDataElements.GetSize(); nIndex++)
	{
		CEmrInfoDataElement *peide = m_aryCurDataElements.GetAt(nIndex);
		peide->m_nVisibleIndex = GetCurVisibleIndex(peide->m_nSortOrder, FALSE);
	}


	
}

// (z.manning, 05/29/2008) - PLID 16443 - Returns the visible index (i.e. ignore inactive) of the
// current column list or -1 of the specified sort order doesn't exist or is inactive.
long CEmrItemEntryDlg::GetCurVisibleIndex(const long nSortOrder, BOOL bColumnList)
{
	// (z.manning, 05/30/2008) - Start at one to account for the row title column which is not
	// stored in our array.
	// (z.manning 2010-11-29 14:49) - PLID 39025 - I reworked this function slightly. It used to be
	// based on the data element arrays, which are always in order of the elements' sort orders, however
	// the sort order doesn't mean anything if auto-alphabatize is enabled so this now uses the datalists
	// themselves to determine the visible index.

	//TES 3/14/2011 - PLID 42784 - Converted to datalist2
	NXDATALIST2Lib::_DNxDataListPtr pdlData;
	if(bColumnList) {
		pdlData = m_pdlColumnDataElementList;
	}
	else {
		pdlData = m_pdlDataElementList;
	}

	long nVisibleIndex = 1;
	NXDATALIST2Lib::IRowSettingsPtr pRow = pdlData->GetFirstRow();
	while(pRow)
	{
		BOOL bInactive = VarBool(pRow->GetValue(bColumnList ? cdelcInactive : delcInactive));
		const long nCurrentSortOrder = VarLong(pRow->GetValue(bColumnList ? cdelcSortOrder : delcSortOrder));
		if(nCurrentSortOrder == nSortOrder) {
			if(bInactive) {
				return -1;
			}
			else {
				return nVisibleIndex;
			}
		}

		if(!bInactive) {
			nVisibleIndex++;
		}
		pRow = pRow->GetNextRow();
	}

	// (z.manning, 05/29/2008) - The specified sort order must not have existed.
	return -1;
}

// (z.manning, 05/30/2008) - PLID 16443 - This function will go through all calculated field columns
// and swap references to each column in all calculated field formulas for the item.
void CEmrItemEntryDlg::UpdateFormulaReferences(CEmrInfoDataElement *peideIgnore /* = NULL */)
{
	long nCalcFieldIndex;
	for(nCalcFieldIndex = 0; nCalcFieldIndex < m_aryCurColumnDataElements.GetSize(); nCalcFieldIndex++)
	{
		CEmrInfoDataElement *peideCalc = m_aryCurColumnDataElements.GetAt(nCalcFieldIndex);
		if(!peideCalc->m_strFormula.IsEmpty())
		{
			// (z.manning, 05/30/2008) - This is a calculated field so let's create our expression.
			CNxExpression expression(peideCalc->m_strFormula);

			// (z.manning, 05/30/2008) - Now loop through all column elements and look for any
			// whose visible location has changed.
			for(long nIndex = 0; nIndex < m_aryCurColumnDataElements.GetSize(); nIndex++)
			{
				CEmrInfoDataElement *peide = m_aryCurColumnDataElements.GetAt(nIndex);
				if(!peide->m_bInactive && peide != peideIgnore)
				{
					long nCurVisibleIndex = GetCurVisibleIndex(peide->m_nSortOrder, TRUE);
					// (z.manning, 05/30/2008) - The visible index should have been set. If it's -1 then
					// either it wasn't set or the formula refers to an inactive row, neither of which
					// should have happened.
					ASSERT(peide->m_nVisibleIndex >= 0);
					if(peide->m_nVisibleIndex != nCurVisibleIndex)
					{
						// (z.manning, 05/30/2008) - This column has changed locations so tell the expression
						// to replace the all instances of it.
						CString strOld = GetColumnOperand(peide->m_nVisibleIndex);
						CString strNew = GetColumnOperand(nCurVisibleIndex);
						expression.AddOperandReplacement(strOld, strNew);
					}
				}
				else {
					CString strTemp;
					ASSERT(!IsDataElementReferencedInAnyFormula(peide, m_aryCurDataElements, m_aryCurColumnDataElements, strTemp));
				}
			}

			peideCalc->m_strFormula = expression.GetInfixExpression();
		}
	}
	
	for(nCalcFieldIndex = 0; nCalcFieldIndex < m_aryCurDataElements.GetSize(); nCalcFieldIndex++)
	{
		CEmrInfoDataElement *peideCalc = m_aryCurDataElements.GetAt(nCalcFieldIndex);
		if(!peideCalc->m_strFormula.IsEmpty())
		{
			// (z.manning, 05/30/2008) - This is a calculated field so let's create our expression.
			CNxExpression expression(peideCalc->m_strFormula);

			// (z.manning, 05/30/2008) - Now loop through all row elements and look for any
			// whose visible location has changed.
			for(long nIndex = 0; nIndex < m_aryCurDataElements.GetSize(); nIndex++)
			{
				CEmrInfoDataElement *peide = m_aryCurDataElements.GetAt(nIndex);
				if(!peide->m_bInactive && peide != peideIgnore)
				{
					long nCurVisibleIndex = GetCurVisibleIndex(peide->m_nSortOrder, FALSE);
					// (z.manning, 05/30/2008) - The visible index should have been set. If it's -1 then
					// either it wasn't set or the formula refers to an inactive row, neither of which
					// should have happened.
					ASSERT(peide->m_nVisibleIndex >= 0);
					if(peide->m_nVisibleIndex != nCurVisibleIndex)
					{
						// (z.manning, 05/30/2008) - This column has changed locations so tell the expression
						// to replace the all instances of it.
						CString strOld = GetRowOperand(peide->m_nVisibleIndex);
						CString strNew = GetRowOperand(nCurVisibleIndex);
						expression.AddOperandReplacement(strOld, strNew);
					}
				}
				else {
					CString strTemp;
					ASSERT(!IsDataElementReferencedInAnyFormula(peide, m_aryCurDataElements, m_aryCurColumnDataElements, strTemp));
				}
			}

			peideCalc->m_strFormula = expression.GetInfixExpression();
		}
	}

	UpdateVisibleIndices();
}

BOOL CEmrItemEntryDlg::AtLeastOneActiveRowAndColumn()
{
	// (a.walling 2007-11-05 16:08) - PLID 27980 - VS2008 - for() loops
	long i = 0;

	BOOL bOK = FALSE;

	// (z.manning 2010-03-02 10:05) - PLID 37228 - Smart stamp tables are not required to have a row
	if(!m_bIsSmartStampTable) {
		//TES 3/14/2011 - PLID 42784 - Converted to datalist2
		NXDATALIST2Lib::IRowSettingsPtr pRow = m_pdlDataElementList->GetFirstRow();
		while(pRow && !bOK) {
			if(!VarBool(pRow->GetValue(delcInactive))) {
				bOK = TRUE;
			}
			pRow = pRow->GetNextRow();
		}

		if(!bOK) {
			AfxMessageBox("A table must have at least one active row before doing this.");
			return bOK;
		}
	}

	bOK = FALSE;	
	//TES 3/14/2011 - PLID 42784 - Converted to datalist2
	NXDATALIST2Lib::IRowSettingsPtr pRow = m_pdlColumnDataElementList->GetFirstRow();
	while(pRow && !bOK) {
		if(!VarBool(pRow->GetValue(cdelcInactive))) {
			bOK = TRUE;
		}
		pRow = pRow->GetNextRow();
	}

	if(!bOK) {
		AfxMessageBox("A table must have at least one active column before doing this.");
		return bOK;
	}

	return bOK;
}

// (c.haag 2008-07-18 10:16) - PLID 30724 - Returns the string used when auditing new or deleted problem actions
CString CEmrItemEntryDlg::GetProblemActionAuditString(const EmrAction& ea, const EmrProblemAction& epa)
{
	_RecordsetPtr prsStatus = CreateParamRecordset("SELECT Name FROM EMRProblemStatusT WHERE ID = {INT}", epa.nStatus);
	CString strStatus;
	if (!prsStatus->eof) {
		strStatus = AdoFldString(prsStatus, "Name");
	} else {
		// This normally would never happen
	}
	return FormatString("Status: %s   Description: %s   Associate With: %s", strStatus, epa.strDescription, GetEmrActionObjectName((epa.bSpawnToSourceItem) ? ea.eaoSourceType : ea.eaoDestType, TRUE));
}

// (j.jones 2008-09-23 08:49) - PLID 31476 - added OnRememberForPatient
void CEmrItemEntryDlg::OnRememberForPatient() 
{
	try {

		BOOL bRememberForPatient = m_checkRememberPerPatient.GetCheck();

		// (j.jones 2010-02-26 08:33) - PLID 37231 - if a SmartStamp Image, the changes here will apply to
		// the linked SmartStamp table, provided that the table is not linked to another image
		if(m_pdlSmartStampTable->GetCurSel() != NULL) {
			long nSmartStampTableMasterID = VarLong(m_pdlSmartStampTable->GetCurSel()->GetValue(sstcMasterID), -1);
			if(m_btnEnableSmartStamps.GetCheck() && nSmartStampTableMasterID != -1) {
				//find out if this table has a different remember setting than what we're changing to,
				//and if it is linked to another image in data - if both are true, we can't change
				//the remember setting
				_RecordsetPtr rs = CreateParamRecordset("SELECT TOP 1 EMRInfoT.ID, RememberForPatient, RememberForEMR "
					"FROM EMRInfoT "
					"INNER JOIN EMRInfoMasterT ON EMRInfoT.ID = EMRInfoMasterT.ActiveEMRInfoID "
					"WHERE RememberForPatient <> {INT} AND EMRInfoMasterT.ID = {INT} "
					"AND EMRInfoMasterT.ID IN ("
						"SELECT ChildEMRInfoMasterID FROM EMRInfoT "
						"INNER JOIN EMRInfoMasterT ON EMRInfoT.ID = EMRInfoMasterT.ActiveEMRInfoID "
						"WHERE SmartStampsEnabled = 1 AND ChildEMRInfoMasterID Is Not Null AND EMRInfoMasterT.ID <> {INT} "
					")",
					bRememberForPatient ? 1 : 0, nSmartStampTableMasterID,
					m_nEmrInfoMasterID);  //it's ok if m_nEmrInfoMasterID is -1
				if(!rs->eof) {
					//we found a match, so we can't change the setting, revert it and warn
					bRememberForPatient = !bRememberForPatient;
					m_checkRememberPerPatient.SetCheck(bRememberForPatient);

					BOOL bTableRememberForPatient = AdoFldBool(rs, "RememberForPatient", FALSE);
					BOOL bTableRememberForEMR = AdoFldBool(rs, "RememberForEMR", FALSE);
					CString strTableText;
					if(bTableRememberForPatient) {
						strTableText = "is set to remember per patient";
					}
					else if(bTableRememberForEMR) {
						strTableText = "is set to remember per EMR";
					}
					else {
						strTableText = "is not set to remember its value";
					}

					CString strWarn;
					strWarn.Format("The 'Remember this item's value' setting cannot be changed because the linked SmartStamp Table "
						"%s, and is linked to another SmartStamp Image item.\n\n"
						"SmartStamp Images and Tables cannot have different 'Remember this item's value' settings.", strTableText);
					AfxMessageBox(strWarn);
				}
				rs->Close();
			}
		}
		
		//both checkboxes can't be checked together, so if you check one, uncheck the other
		if(bRememberForPatient) {
			m_checkRememberPerEMR.SetCheck(FALSE);
		}

		UpdateDontSpawnRememberedValuesCheck();

	}NxCatchAll("Error in CEmrItemEntryDlg::OnRememberForPatient");
}

// (j.jones 2008-09-23 08:49) - PLID 31476 - added OnRememberForEmr
void CEmrItemEntryDlg::OnRememberForEmr() 
{
	try {

		BOOL bRememberForEMR = m_checkRememberPerEMR.GetCheck();

		// (j.jones 2010-02-26 08:33) - PLID 37231 - if a SmartStamp Image, the changes here will apply to
		// the linked SmartStamp table, provided that the table is not linked to another image
		if(m_pdlSmartStampTable->GetCurSel() != NULL) {
			long nSmartStampTableMasterID = VarLong(m_pdlSmartStampTable->GetCurSel()->GetValue(sstcMasterID), -1);
			if(m_btnEnableSmartStamps.GetCheck() && nSmartStampTableMasterID != -1) {
				//find out if this table has a different remember setting than what we're changing to,
				//and if it is linked to another image in data - if both are true, we can't change
				//the remember setting
				_RecordsetPtr rs = CreateParamRecordset("SELECT TOP 1 EMRInfoT.ID, RememberForPatient, RememberForEMR "
					"FROM EMRInfoT "
					"INNER JOIN EMRInfoMasterT ON EMRInfoT.ID = EMRInfoMasterT.ActiveEMRInfoID "
					"WHERE RememberForEMR <> {INT} AND EMRInfoMasterT.ID = {INT} "
					"AND EMRInfoMasterT.ID IN ("
						"SELECT ChildEMRInfoMasterID FROM EMRInfoT "
						"INNER JOIN EMRInfoMasterT ON EMRInfoT.ID = EMRInfoMasterT.ActiveEMRInfoID "
						"WHERE SmartStampsEnabled = 1 AND ChildEMRInfoMasterID Is Not Null AND EMRInfoMasterT.ID <> {INT} "
					")",
					bRememberForEMR ? 1 : 0, nSmartStampTableMasterID,
					m_nEmrInfoMasterID);  //it's ok if m_nEmrInfoMasterID is -1
				if(!rs->eof) {
					//we found a match, so we can't change the setting, revert it and warn
					bRememberForEMR = !bRememberForEMR;
					m_checkRememberPerEMR.SetCheck(bRememberForEMR);
					
					BOOL bTableRememberForPatient = AdoFldBool(rs, "RememberForPatient", FALSE);
					BOOL bTableRememberForEMR = AdoFldBool(rs, "RememberForEMR", FALSE);
					CString strTableText;
					if(bTableRememberForPatient) {
						strTableText = "is set to remember per patient";
					}
					else if(bTableRememberForEMR) {
						strTableText = "is set to remember per EMR";
					}
					else {
						strTableText = "is not set to remember its value";
					}

					CString strWarn;
					strWarn.Format("The 'Remember this item's value' setting cannot be changed because the linked SmartStamp Table "
						"%s, and is linked to another SmartStamp Image item.\n\n"
						"SmartStamp Images and Tables cannot have different 'Remember this item's value' settings.", strTableText);
					AfxMessageBox(strWarn);
				}
				rs->Close();
			}
		}

		//both checkboxes can't be checked together, so if you check one, uncheck the other
		if(bRememberForEMR) {
			m_checkRememberPerPatient.SetCheck(FALSE);
		}

		UpdateDontSpawnRememberedValuesCheck();

	}NxCatchAll("Error in CEmrItemEntryDlg::OnRememberForEmr");
}

// (c.haag 2008-10-21 15:41) - PLID 31708 - Called when the user toggles table flipping
void CEmrItemEntryDlg::OnTableRowsAsFields()
{
	try {
		CString strLongForm;
		GetDlgItemText(IDC_SENTENCE, strLongForm);

		if (IsDlgButtonChecked(IDC_TABLE_ROWS_AS_FIELDS)) {
			SetDlgItemText(IDC_ROW_LABEL, "Columns");
			SetDlgItemText(IDC_COLUMN_LABEL, "Rows");

			// (z.manning 2010-09-02 10:35) - PLID 40206 - Let's update the sentence format for them
			// if they have the field name in it anywhere.
			strLongForm.Replace(ROW_NAME_FIELD, COLUMN_NAME_FIELD);

			// (r.gonet 04/29/2013) - PLID 44897 - Update column sentence formats to reflect the orientation change
			NXDATALIST2Lib::IRowSettingsPtr pDataElementRow = m_pdlColumnDataElementList->FindAbsoluteFirstRow(VARIANT_TRUE);
			while(pDataElementRow) {
				CEmrInfoDataElement *pDataElement = m_aryCurColumnDataElements.GetAt(GetCurDataElementArrayIndex(VarLong(pDataElementRow->GetValue(cdelcSortOrder)), TRUE));
				pDataElement->m_strLongForm.Replace(ROW_NAME_FIELD, COLUMN_NAME_FIELD);
				pDataElementRow = m_pdlColumnDataElementList->FindAbsoluteNextRow(pDataElementRow, VARIANT_TRUE);
			}
		}
		else {
			SetDlgItemText(IDC_ROW_LABEL, "Rows");
			SetDlgItemText(IDC_COLUMN_LABEL, "Columns");

			// (z.manning 2010-09-02 10:35) - PLID 40206 - Let's update the sentence format for them
			// if they have the field name in it anywhere.
			strLongForm.Replace(COLUMN_NAME_FIELD, ROW_NAME_FIELD);

			// (r.gonet 04/29/2013) - PLID 44897 - Update column sentence formats to reflect the orientation change
			NXDATALIST2Lib::IRowSettingsPtr pDataElementRow = m_pdlColumnDataElementList->FindAbsoluteFirstRow(VARIANT_TRUE);
			while(pDataElementRow) {
				CEmrInfoDataElement *pDataElement = m_aryCurColumnDataElements.GetAt(GetCurDataElementArrayIndex(VarLong(pDataElementRow->GetValue(cdelcSortOrder)), TRUE));
				pDataElement->m_strLongForm.Replace(COLUMN_NAME_FIELD, ROW_NAME_FIELD);
				pDataElementRow = m_pdlColumnDataElementList->FindAbsoluteNextRow(pDataElementRow, VARIANT_TRUE);
			}
		}

		SetDlgItemText(IDC_SENTENCE, strLongForm);

		// (j.jones 2011-03-08 12:25) - PLID 42282 - ReflectEMCodeInterface now always
		// preserves the current rule selection
		ReflectEMCodeInterface();
	}
	NxCatchAll("Error in CEmrItemEntryDlg::OnTableRowsAsFields");
}

// (a.walling 2008-10-22 12:15) - PLID 31794 - Returns SQL to update template detail preview flags
CString CEmrItemEntryDlg::UpdatePreviewFlagsOnTemplates(DWORD dwFlagsToAdd, DWORD dwFlagsToRemove)
{
	CString str;
	str.Format(
		"UPDATE EMRTemplateDetailsT "
			"SET PreviewFlags = ((PreviewFlags | 0x%08x) & 0x%08x) "
		"WHERE EMRTemplateDetailsT.EmrInfoMasterID = %li",
		dwFlagsToAdd, ~dwFlagsToRemove, m_nEmrInfoMasterID);

	return str;
}

// (z.manning 2009-01-13 15:11) - PLID 32719 - Added function to open the input mask editor
void CEmrItemEntryDlg::OpenInputMaskEditor(CEmrInfoDataElement *peide)
{
	CEmrTableInputMaskDlg dlg(this);
	dlg.SetInitialInputMask(peide->m_strInputMask);
	if(dlg.DoModal() == IDOK) {
		peide->m_strInputMask = dlg.GetInputMask();
	}
}

// (z.manning 2009-02-10 15:02) - PLID 33026 - Added an accesor the current EMN
CEMN* CEmrItemEntryDlg::GetCurrentEMN()
{
	return m_pCurrentEMN;
}

void CEmrItemEntryDlg::OnSelChosenListEmrDataCodes(LPDISPATCH lpRow)
{
	// (a.walling 2009-05-28 16:22) - PLID 34389
	try {
		NXDATALIST2Lib::IRowSettingsPtr pRow(lpRow);

		if (pRow) {
			/*
			CString strCurrentDataUnit;
			m_nxeditDataUnit.GetWindowText(strCurrentDataUnit);

			if (strCurrentDataUnit.IsEmpty() || m_strEmrDataCodeUnit.IsEmpty()) {
				CString strNewUnit = VarString(pRow->GetValue(lcDefaultUnit), "");
				m_nxeditDataUnit.SetWindowText(strNewUnit);
			}
			*/
			
			CString strNewUnit = VarString(pRow->GetValue(lcDefaultUnit), "");
			m_nxeditDataUnit.SetWindowText(strNewUnit);
		}
	} NxCatchAll("OnSelChosenListEmrDataCodes");
}

// (j.gruber 2009-11-18 14:29) - PLID 35945 - added function
BOOL CEmrItemEntryDlg::IsTOPSCode(CString strCode) {

	try {
		
		//check to see if the code is one of our 'special' tops codes
		if (strCode == "TOPS_ProcedureDuration"
			|| strCode == "TOPS_AnesthesiaProvidedBy"
			|| strCode == "TOPS_ModeOfAnesthesia"
			|| strCode == "TOPS_TobaccoUse"
			|| strCode == "TOPS_HasDiabetes"
			|| strCode == "TOPS_DiabetesMedication"
			|| strCode == "TOPS_PatientASAStatus"
			//(e.lally 2010-01-14) PLID 36839
			|| strCode == "TOPS_VTEProphylaxis"
			|| strCode == "TOPS_ProcRelatedWtLoss"
			|| strCode == "TOPS_PrevBariatricSurg"
			|| strCode == "TOPS_LipoplastyVolInfused"
			|| strCode == "TOPS_LipoplastyIVIntake"
			|| strCode == "TOPS_LipoplastyAspirated"
			|| strCode == "TOPS_BreastImplantRight"
			|| strCode == "TOPS_BreastImplantLeft"
			|| strCode == "TOPS_ImplantMfrRight"
			|| strCode == "TOPS_ImplantMfrLeft"
			|| strCode == "TOPS_ImplantSerialRight"
			|| strCode == "TOPS_ImplantSerialLeft"
			|| strCode == "TOPS_ImplantShellRight"
			|| strCode == "TOPS_ImplantShellLeft"
			|| strCode == "TOPS_ImplantShapeRight"
			|| strCode == "TOPS_ImplantShapeLeft"
			|| strCode == "TOPS_ImplantFillerRight"
			|| strCode == "TOPS_ImplantFillerLeft"
			|| strCode == "TOPS_PostOpAdjRight"
			|| strCode == "TOPS_PostOpAdjLeft"
			|| strCode == "TOPS_ImplantPositionRight"
			|| strCode == "TOPS_ImplantPositionLeft"
			|| strCode == "TOPS_FillerVolumeRight"
			|| strCode == "TOPS_FillerVolumeLeft") {

				return TRUE;
		}
		else {
			return FALSE;
		}
	}NxCatchAll(__FUNCTION__);

	return FALSE;

}



// (j.gruber 2010-04-27 16:49) - PLID 38377
BOOL CEmrItemEntryDlg::IsBOLDCode(CString strCode) {

	try {
		
		//check to see if the code is one of our 'special' BOLD codes
		//since there are over 100 BOLD codes, we are just going to check if the first 4 letters start with BOLD
		//if someone creates a code that starts with that, they are just out of luck
		if (strCode.Left(5) == "BOLD_") {
				return TRUE;
		}
		else {
			return FALSE;
		}
	}NxCatchAll(__FUNCTION__);

	return FALSE;

}



// (j.gruber 2009-12-22 10:06) - PLID 35771 - added function
// (j.gruber 2010-01-18 10:07) - PLID 36929 - removed report and thus codes
/*BOOL CEmrItemEntryDlg::IsReportCode(CString strCode) {

	try {
		
		//check to see if the code is one of our 'special' report codes
		// (j.gruber 2009-12-23 16:28) - PLID 35767 - added code for educational resources
		// (j.gruber 2009-12-23 16:28) - PLID 35769 - added code for summaries
		if (strCode == "REPORT_Transitions" ||
			strCode == "REPORT_EdResources" ||
			strCode == "REPORT_ClinicalSummary") {

			return TRUE;
		}
		else {
			return FALSE;
		}
	}NxCatchAll(__FUNCTION__);

	return FALSE;

}*/


// (j.gruber 2009-11-18 14:29) - PLID 35945 - added function
// (j.gruber 2009-12-22 10:08) - PLID 35771 - renamed function and included report codes
// (j.gruber 2010-01-18 10:09) - PLID 36929 - changed function name back to not include reports
BOOL CEmrItemEntryDlg::CheckTOPSCodeAgainstType(CString strCode, CString strAdditionalMessage) {

	try {

		
		long nType = CalcDataTypeByCurSelection();
		CString strType;

		if (IsTOPSCode(strCode)) {

			//get the type of item we are checking
			
			switch (nType) {

				case 1:
				case 2:
				case 3:			
				case 5:
					return TRUE;
				break;

				case 4:
					strType = "Image";
				break;
				case 6:
					strType = "Narrative";
				break;
				case 7:
					strType = "Table";
				break;
			}

			MsgBox("The selected data code is a TOPS code.  TOPS codes cannot be associated with an item type of %s.\n%s", strType, strAdditionalMessage);		
		}
		
	}NxCatchAll(__FUNCTION__);

	return FALSE;
}


// (j.gruber 2010-04-27 16:53) - PLID 38377
BOOL CEmrItemEntryDlg::CheckBOLDCodeAgainstType(CString strCode, CString strAdditionalMessage) {

	try {

		
		long nType = CalcDataTypeByCurSelection();
		CString strType;

		if (IsBOLDCode(strCode)) {

			//get the type of item we are checking
			
			switch (nType) {

				case 1:
				case 2:
				case 3:			
				case 5:
					return TRUE;
				break;

				case 4:
					strType = "Image";
				break;
				case 6:
					strType = "Narrative";
				break;
				case 7:
					strType = "Table";
				break;
			}
			//(a.wilson 2011-9-2) PLID 45307 - changed bold to export
			MsgBox("The selected data code is an export code.  Export codes cannot be associated with an item type of %s.\n%s", strType, strAdditionalMessage);		
		}
		
	}NxCatchAll(__FUNCTION__);

	return FALSE;
}


// (j.gruber 2009-11-18 14:29) - PLID 35945 - added function
void CEmrItemEntryDlg::SelChangingListEmrdatacodes(LPDISPATCH lpOldSel, LPDISPATCH* lppNewSel)
{
	try {

		if (*lppNewSel == NULL) {			
			SafeSetCOMPointer(lppNewSel, lpOldSel);
			return;
		}

		// (j.gruber 2009-11-18 14:29) - PLID 35945 - check to see if this is a TOPS code and then check the type of item this is
		NXDATALIST2Lib::IRowSettingsPtr pRow(*lppNewSel);

		if (pRow) {

			//get the code
			CString strCode = VarString(pRow->GetValue(lcCode), "");

			// (j.gruber 2009-12-22 10:20) - PLID SOMETHING - added report codes
			// (j.gruber 2010-01-18 10:25) - PLID 36929 - took out report and thus codes
			
			if (IsTOPSCode(strCode) /*|| IsReportCode(strCode)*/) {

				if (!CheckTOPSCodeAgainstType(strCode, "Your selection will be reverted.")) {

					//we can't have this type with a tops code
					//the function already popped up a message for us, so just set it back
					SafeSetCOMPointer(lppNewSel, lpOldSel);
				}
			}

			// (j.gruber 2010-04-27 16:54) - PLID 38377 - added bold codes
			if (IsBOLDCode(strCode)) {

				if (!CheckBOLDCodeAgainstType(strCode, "Your selection will be reverted.")) {

					//we can't have this type with a BOLD code
					//the function already popped up a message for us, so just set it back
					SafeSetCOMPointer(lppNewSel, lpOldSel);
				}
			}
		}	
	}NxCatchAll(__FUNCTION__);
}

void CEmrItemEntryDlg::OnEnableSmartStamps()
{
	try {

		// (j.jones 2010-02-17 11:55) - PLID 37318 - prevent changing the linked smart stamp table
		if(m_bPreventSmartStampTableChange) {
			GetDlgItem(IDC_ENABLE_SMART_STAMPS)->EnableWindow(FALSE);		
			m_pdlSmartStampTable->PutEnabled(VARIANT_FALSE);
			m_btnEditSmartStampTable.EnableWindow(FALSE);
			m_btnNewSmartStampTable.EnableWindow(FALSE);
		}
		else {
			// (z.manning 2010-02-09 13:39) - PLID 37228 - Enable the edit table button if smart stamps are enabled
			BOOL bEnable = IsDlgButtonChecked(IDC_ENABLE_SMART_STAMPS) == BST_CHECKED;
			m_btnEditSmartStampTable.EnableWindow(bEnable);
			m_btnNewSmartStampTable.EnableWindow(bEnable);
			GetDlgItem(IDC_SMART_STAMP_TABLE_COMBO)->EnableWindow(bEnable);

			if(bEnable) {

				_variant_t varCurrentSmartStampTableMasterID = g_cvarNull;
				if(m_pdlSmartStampTable->GetCurSel() != NULL) {
					varCurrentSmartStampTableMasterID = m_pdlSmartStampTable->GetCurSel()->GetValue(sstcMasterID);
				}

				long nSmartStampTableMasterID = VarLong(varCurrentSmartStampTableMasterID, -1);
				if(nSmartStampTableMasterID != -1) {

					//Find out if this table has a different remember setting than what our image has,
					//and if it is linked to another image as well. If it's not linked to another image,
					//we'll be able to change the setting, but otherwise we can't. Warn about this.
					CString strImage, strTable;
					if(!CompareSmartStampRememberSettings(nSmartStampTableMasterID, strImage, strTable)) {
						CString strWarn;
						strWarn.Format("%s %s\n\n"
							"Because this table is also linked to another Image, the setting cannot be changed on the table.\n"
							"You will need to change the 'remember this item's value' settings for this Image or else you will "
							"be unable to save the link to this table.", strImage, strTable);
						AfxMessageBox(strWarn);
					}
				}
			}
		}

	}NxCatchAll(__FUNCTION__);
}

int CEmrItemEntryDlg::OpenItemEntryDialogForSmartStampTable(long nEmrInfoMasterID, EEmrItemEntryDlgBehavior eBehavior/* = eEmrItemEntryDlgBehavior_Normal*/)
{
	CWaitCursor wc;
	CEmrItemEntryDlg dlg(this);
	dlg.m_bIsSmartStampTable = TRUE;

	// (j.jones 2010-02-26 08:33) - PLID 37231 - we need to track the "remember" settings
	// for the SmartStamp Image parent, as the table cannot be different
	dlg.m_bSmartStampImage_RememberForPatient = IsDlgButtonChecked(IDC_REMEMBER_FOR_PATIENT);
	dlg.m_bSmartStampImage_RememberForEMR = IsDlgButtonChecked(IDC_REMEMBER_FOR_EMR);

	dlg.m_bPreventTypeChange = TRUE;
	dlg.m_eitDefaultDataType = eitTable;
	if(m_pCurrentEMN != NULL) {
		dlg.SetCurrentEMN(m_pCurrentEMN);
	}

	int nResult = dlg.OpenWithMasterID(nEmrInfoMasterID, eBehavior);
	if(nResult == IDOK) {
		if(nEmrInfoMasterID == -1) {
			// (z.manning 2010-02-10 09:57) - PLID 37228 - They created a new table so add
			// the row for it to the list and select it.
			NXDATALIST2Lib::IRowSettingsPtr pNewRow = m_pdlSmartStampTable->GetNewRow();
			pNewRow->PutValue(sstcMasterID, dlg.GetInfoMasterID());
			pNewRow->PutValue(sstcName, _bstr_t(dlg.GetName()));
			pNewRow = m_pdlSmartStampTable->AddRowSorted(pNewRow, NULL);
			// (z.manning 2012-11-28 16:03) - PLID 52262 - Do not select this row if the smart stamp image
			// is already on a template.
			if(m_nEmrInfoMasterID == -1 || !IsSmartStampImageInUseOnEmnTemplate(m_nEmrInfoMasterID)) {
				m_pdlSmartStampTable->PutCurSel(pNewRow);
			}
		}
		else {
			NXDATALIST2Lib::IRowSettingsPtr pExistingRow = m_pdlSmartStampTable->GetCurSel();
			pExistingRow->PutValue(sstcName, _bstr_t(dlg.GetName()));
		}
	}

	return nResult;
}

// (z.manning 2010-02-09 17:16) - PLID 37228
void CEmrItemEntryDlg::OnEditSmartStampTable()
{
	try
	{
		NXDATALIST2Lib::IRowSettingsPtr pRow = m_pdlSmartStampTable->GetCurSel();
		if(pRow == NULL) {
			MessageBox("You must select a smart stamp table first.");
			return;
		}

		OpenItemEntryDialogForSmartStampTable(VarLong(pRow->GetValue(sstcMasterID)));

	}NxCatchAll(__FUNCTION__);
}

// (z.manning 2010-02-09 17:16) - PLID 37228
void CEmrItemEntryDlg::OnNewSmartStampTable()
{
	try
	{
		OpenItemEntryDialogForSmartStampTable(-1);

	}NxCatchAll(__FUNCTION__);
}

void CEmrItemEntryDlg::RequeryFinishedSmartStampTableCombo(short nFlags)
{
	try
	{
		// (z.manning 2010-02-10 14:46) - PLID 37228 - We may need to handle setting the selection here
		// if this list was still requerying during the load process.
		if(m_varSmartStampTableMasterIDForRequeryFinished.vt != VT_NULL) {
			m_pdlSmartStampTable->SetSelByColumn(sstcMasterID, m_varSmartStampTableMasterIDForRequeryFinished);
			m_varSmartStampTableMasterIDForRequeryFinished.vt = VT_NULL;
		}

	}NxCatchAll(__FUNCTION__);
}

// (j.jones 2010-02-26 09:28) - PLID 37231 - added OnSelChosenSmartStampTableCombo
void CEmrItemEntryDlg::OnSelChosenSmartStampTableCombo(LPDISPATCH lpRow)
{
	try {

		NXDATALIST2Lib::IRowSettingsPtr pRow(lpRow);
		if(pRow == NULL) {
			return;
		}

		BOOL bValidChange = TRUE;

		// (z.manning 2012-11-19 12:47) - PLID 52262 - If this smart stamp image/table combo is already in use
		// on a template do not allow them to change the linked smart stamp table.
		long nOldSmartStampTableInfoMasterID = GetSmartStampTableMasterID();
		if(m_nEmrInfoMasterID != -1 && nOldSmartStampTableInfoMasterID != -1)
		{
			if(IsSmartStampImageInUseOnEmnTemplate(m_nEmrInfoMasterID)) {
				MessageBox("This smart stamp image and table combination is in use on at least one EMN template.  "
					"You may not change the linked smart stamp table", NULL, MB_ICONWARNING);
				bValidChange = FALSE;
			}
		}

		if(!bValidChange) {
			m_pdlSmartStampTable->SetSelByColumn(sstcMasterID, nOldSmartStampTableInfoMasterID);
			return;
		}

		long nSmartStampTableMasterID = VarLong(pRow->GetValue(sstcMasterID), -1);
		if(nSmartStampTableMasterID != -1) {

			//Find out if this table has a different remember setting than what our image has,
			//and if it is linked to another image as well. If it's not linked to another image,
			//we'll be able to change the setting, but otherwise we can't. Warn about this.
			CString strImage, strTable;
			if(!CompareSmartStampRememberSettings(nSmartStampTableMasterID, strImage, strTable)) {
				CString strWarn;
				strWarn.Format("%s %s\n\n"
					"Because this table is also linked to another Image, the setting cannot be changed on the table.\n"
					"You will need to change the 'remember this item's value' settings for this Image or else you will "
					"be unable to save the link to this table.", strImage, strTable);
				AfxMessageBox(strWarn);
			}
		}

	}NxCatchAll(__FUNCTION__);
}


// (j.jones 2010-02-26 09:43) - PLID 37231 - used to determine if we are allowed
// to save a link to a SmartStamp Table, based on the 'remember' settings
BOOL CEmrItemEntryDlg::CompareSmartStampRememberSettings(long nSmartStampTableMasterID, CString &strImageText, CString &strTableText)
{
	if(nSmartStampTableMasterID == -1) {
		//should not have been called
		ASSERT(FALSE);
		return TRUE;
	}

	BOOL bRememberForPatient = IsDlgButtonChecked(IDC_REMEMBER_FOR_PATIENT);
	BOOL bRememberForEMR = IsDlgButtonChecked(IDC_REMEMBER_FOR_EMR);

	//Find out if this table has a different remember setting than what our image has,
	//and if it is linked to another image as well.
	_RecordsetPtr rs = CreateParamRecordset("SELECT TOP 1 EMRInfoT.ID,"
		"RememberForPatient, RememberForEMR "
		"FROM EMRInfoT "
		"INNER JOIN EMRInfoMasterT ON EMRInfoT.ID = EMRInfoMasterT.ActiveEMRInfoID "
		"WHERE (RememberForPatient <> {INT} OR RememberForEMR <> {INT}) "
		"AND EMRInfoMasterT.ID = {INT} "
		"AND EMRInfoMasterT.ID IN ("
			"SELECT ChildEMRInfoMasterID FROM EMRInfoT "
			"INNER JOIN EMRInfoMasterT ON EMRInfoT.ID = EMRInfoMasterT.ActiveEMRInfoID "
			"WHERE SmartStampsEnabled = 1 AND ChildEMRInfoMasterID Is Not Null AND EMRInfoMasterT.ID <> {INT} "
		")",
		bRememberForPatient ? 1 : 0, bRememberForEMR ? 1 : 0,
		nSmartStampTableMasterID,
		m_nEmrInfoMasterID);  //it's ok if m_nEmrInfoMasterID is -1
	if(!rs->eof) {
		//don't disallow selecting this table, just tell them they won't be able
		//to save their changes without making this image's remember settings match
		BOOL bTableRememberForPatient = AdoFldBool(rs, "RememberForPatient", FALSE);
		BOOL bTableRememberForEMR = AdoFldBool(rs, "RememberForEMR", FALSE);
		if(bRememberForPatient) {
			strImageText = "This Image item is currently set to remember this item's value per patient,";
		}
		else if(bRememberForEMR) {
			strImageText = "This Image item is currently set to remember this item's value per EMR,";
		}
		else {
			strImageText = "This Image item is currently set to not remember this item's value,";
		}

		if(bTableRememberForPatient) {
			strTableText = "but your selected table is set to remember per patient.";
		}
		else if(bTableRememberForEMR) {
			strTableText = "but your selected table is set to remember per EMR.";
		}
		else {
			strTableText = "but your selected table is not set to remember its value.";
		}

		return FALSE;
	}
	rs->Close();

	return TRUE;
}

// (z.manning 2010-03-02 08:23) - PLID 37320
CString CEmrItemEntryDlg::EnsureUniqueDataName(const CString &strDataName, BOOL bColumnList)
{
	CEmrInfoDataElementArray *pary;
	if(bColumnList) {
		pary = &m_aryCurColumnDataElements;
	}
	else {
		pary = &m_aryCurDataElements;
	}

	CString strValidDataName = strDataName;
	int nCount = 1;
	while(pary->FindDataElement(strValidDataName) != -1)
	{
		strValidDataName = FormatString("%s_%li", strDataName, nCount++);
		if(nCount > 1000) {
			ThrowNxException("CEmrItemEntryDlg::EnsureUniqueDataName - Failed to generate unique data name for %s", strDataName);
		}
	}
	return strValidDataName;
}

// (z.manning 2010-03-22 14:13) - PLID 37228
long CEmrItemEntryDlg::GetSmartStampTableMasterID()
{
	return VarLong(m_varSmartStampTableMasterID, -1);
}

// (z.manning 2010-05-07 09:49) - PLID 38759 - The cancel button is no longer IDCANCEL
void CEmrItemEntryDlg::OnBnClickedCancelEmrItemEntry()
{
	try
	{
		CNxDialog::OnCancel();

	}NxCatchAll(__FUNCTION__);
}

void CEmrItemEntryDlg::OnCancel()
{
	try
	{
		// (z.manning 2010-05-07 09:55) - PLID 28759 - Warn before cancelling
		int nResult = AfxMessageBox("Do you want to save your changes?\r\n\r\n"
			"'Yes' will save any changes and close the item.\r\n"
			"'No' will discard any changes and close the item.\r\n"
			"'Cancel' will cancel this action and leave the item open."
			, MB_YESNOCANCEL|MB_ICONQUESTION);
		switch(nResult)
		{
			case IDYES:
				OnOK();
				break;

			case IDNO:
				OnBnClickedCancelEmrItemEntry();
				break;

			case IDCANCEL:
			default:
				// (z.manning 2010-05-07 10:01) - PLID 28759 - Do nothing
				break;
		}

	}NxCatchAll(__FUNCTION__);
}

// (z.manning 2010-07-29 09:49) - PLID 36150
void CEmrItemEntryDlg::EditDataElementSentenceFormat(CEmrInfoDataElement *peide, BOOL bIsColumnElement)
{
	// (r.gonet 04/29/2013) - PLID 44897 - Pass in some extra arguments so the editor can show the table specific fields.
	bool bIsTable = IsDlgButtonChecked(IDC_RADIO_TABLE) ? true : false;
	bool bTableFlipped = (IsDlgButtonChecked(IDC_TABLE_ROWS_AS_FIELDS) == BST_CHECKED);

	CEmrEditSentenceFormatDlg dlg(this, bIsTable, bTableFlipped);
	dlg.SetInitialSentenceFormat(peide->m_strLongForm);
	dlg.SetInitialSpawnedItemsSeparator(peide->m_strSpawnedItemsSeparator);
	if(dlg.DoModal() == IDOK) {
		peide->m_strLongForm = dlg.GetSentenceFormat();
		SetDlgItemText(IDC_DATA_LONGFORM, dlg.GetSentenceFormat());
		// (z.manning 2011-11-07 11:09) - PLID 46309 - SpawnedItemsSeparator
		peide->m_strSpawnedItemsSeparator = dlg.GetSpawnedItemsSeparator();
	}
}

// (z.manning 2010-08-11 12:14) - PLID 40074
void CEmrItemEntryDlg::EditAutoNumberSettings(CEmrInfoDataElement *peide)
{
	CEmrEditAutoNumberSettingsDlg dlg(this);
	dlg.m_eType = (EEmrTableAutoNumberType)peide->m_nAutoNumberType;
	dlg.m_strPrefix = peide->m_strAutoNumberPrefix;
	if(dlg.DoModal() == IDOK)
	{
		peide->m_nAutoNumberType = dlg.m_eType;
		peide->m_strAutoNumberPrefix = dlg.m_strPrefix;
	}
}

// (j.jones 2011-03-08 12:25) - PLID 42282 - If bShow is true,
// the E/M category dropdown will show the options for configuring
// categories per row or column. If false, these options will be removed
void CEmrItemEntryDlg::EnsureEMCodeUseTableCategoriesListOptions(BOOL bShow)
{
	NXDATALIST2Lib::IRowSettingsPtr pTableCatRow = m_pdlEMCategoryCombo->FindByColumn(emcccUseTableCategories, (long)emcutcPerRow, m_pdlEMCategoryCombo->GetFirstRow(), FALSE);
	NXDATALIST2Lib::IRowSettingsPtr pTableCatColumn = m_pdlEMCategoryCombo->FindByColumn(emcccUseTableCategories, (long)emcutcPerColumn, m_pdlEMCategoryCombo->GetFirstRow(), FALSE);

	if(!bShow) {
		//remove these categories if we have them		
		if(pTableCatRow) {
			m_pdlEMCategoryCombo->RemoveRow(pTableCatRow);
		}
		
		if(pTableCatColumn) {
			m_pdlEMCategoryCombo->RemoveRow(pTableCatColumn);
		}
	}
	else {
		//add the per row or per column category options if we do not already have them		
		if(pTableCatRow == NULL) {
			pTableCatRow = m_pdlEMCategoryCombo->GetNewRow();
			pTableCatRow->PutValue(emcccID, (long)-1);
			//emcccDesc is updated momentarily
			pTableCatRow->PutValue(emcccUseTableCategories, (long)emcutcPerRow);
			m_pdlEMCategoryCombo->AddRowSorted(pTableCatRow, NULL);
		}
		if(pTableCatColumn == NULL) {
			pTableCatColumn = m_pdlEMCategoryCombo->GetNewRow();
			pTableCatColumn->PutValue(emcccID, (long)-1);
			//emcccDesc is updated momentarily
			pTableCatColumn->PutValue(emcccUseTableCategories, (long)emcutcPerColumn);
			m_pdlEMCategoryCombo->AddRowSorted(pTableCatColumn, NULL);
		}

		//even if we already had them, make sure the descriptions are right
		//such that we properly handle flipped rows/columns
		if(!IsDlgButtonChecked(IDC_TABLE_ROWS_AS_FIELDS)) {
			//normal
			pTableCatRow->PutValue(emcccDesc, " <Configure Categories Per Row>");
			pTableCatColumn->PutValue(emcccDesc, " <Configure Categories Per Column>");
		}
		else {
			//flipped
			pTableCatRow->PutValue(emcccDesc, " <Configure Categories Per Column>");
			pTableCatColumn->PutValue(emcccDesc, " <Configure Categories Per Row>");
		}
	}
}

// (j.jones 2011-03-08 12:25) - PLID 42282 - this will force the embedded E/M category
// combos to requery for the row & column lists
void CEmrItemEntryDlg::RequeryTableEMCategoryComboColumns()
{
	CString strEmbeddedEMCategoryComboSql = "SELECT -1 AS ID, ' <No E/M Category>' AS Name "
		"UNION SELECT ID, Name FROM EMCodeCategoryT ORDER BY Name";
	//TES 3/14/2011 - PLID 42784 - Converted to datalist2
	NXDATALIST2Lib::IColumnSettingsPtr pCol = m_pdlDataElementList->GetColumn(delcEMCodeCategoryID);
	pCol->PutComboSource((LPCTSTR)strEmbeddedEMCategoryComboSql);

	pCol = m_pdlColumnDataElementList->GetColumn(cdelcEMCodeCategoryID);
	pCol->PutComboSource((LPCTSTR)strEmbeddedEMCategoryComboSql);
}

void CEmrItemEntryDlg::OnAssociateWithGlassesOrder()
{
	try {
		//TES 3/11/2011 - PLID 42757 - Show/Hide Glasses-Order-related fields
		ReflectGlassesOrderCheck();
	}NxCatchAll(__FUNCTION__);
}

void CEmrItemEntryDlg::ReflectGlassesOrderCheck()
{
	//TES 3/11/2011 - PLID 42757 - Show/Hide Glasses-Order-related fields
	BOOL bChecked = FALSE;
	//TES 4/6/2012 - PLID 49367 - There's a different checkbox on tables now.
	if(IsDlgButtonChecked(IDC_RADIO_TABLE)) {
		bChecked = IsDlgButtonChecked(IDC_ASSOCIATE_WITH_GLASSES_ORDER_OR_CL);
	}
	else {
		bChecked = (m_btnAssociateWithGlassesOrder.GetCheck() == BST_CHECKED);
	}
	GetDlgItem(IDC_GLASSES_ORDER_LENS)->EnableWindow(bChecked);

	//TES 4/6/2012 - PLID 49367 - Update the hyperlink to switch between Glasses Order and Contact Lens data
	if(bChecked) {
		m_nxlGOCLToggle.SetType(dtsHyperlink);
		m_nxlGOCLToggle.Invalidate();
		//TES 6/26/2012 - PLID 49367 - We need to restore the contact lens data flag
		m_bHasContactLensData = (m_nxlGOCLToggle.GetText() == "Contact Lens Data");			
	}
	else {
		m_nxlGOCLToggle.SetType(dtsDisabledHyperlink);
		m_nxlGOCLToggle.Invalidate();
		m_bHasContactLensData = false;
	}

	//TES 3/11/2011 - PLID 42757 - This will show/hide the Glasses-order-related columns in the data lists.
	ReflectDataElementList(sdeidPriorSelection);
	
}

//TES 3/14/2011 - PLID 42757 - Global map so that we're only configuring the IFormatSettings once for each type
CMap<GlassesOrderDataType, GlassesOrderDataType, NXDATALIST2Lib::IFormatSettingsPtr, NXDATALIST2Lib::IFormatSettingsPtr> g_mapDataTypeFormats;

//TES 3/11/2011 - PLID 42757 - Update the format of a GlassesOrderDataID field based on the selected GlassesOrderDataType
void CEmrItemEntryDlg::ReflectGlassesOrderDataType(NXDATALIST2Lib::IRowSettingsPtr pRow, BOOL bIsColumn)
{
	//TES 3/11/2011 - PLID 42757 - Format the Data ID column based on the Data Type column.
	GlassesOrderDataType godt = (GlassesOrderDataType)VarLong(pRow->GetValue(bIsColumn?cdelcGlassesOrderDataType:delcGlassesOrderDataType),(long)godtInvalid);
	//TES 3/14/2011 - PLID 42757 - Special case: if this is a dropdown column, treat it as invalid (the records are set for the individual items).
	//TES 3/17/2011 - PLID 42757 - Correction: If the type is RxNumber, then we will still enable the ID column to select the appropriate RxNumber,
	// the dropdowns will then be treated as text.
	if(godt != godtInvalid && godt != godtRxNumber && bIsColumn && VarLong(pRow->GetValue(cdelcType)) == LIST_TYPE_DROPDOWN) {
		godt = godtInvalid;
	}
	//TES 4/6/2012 - PLID 49367 - There are actually two different formats for godtRxNumber, depending on whether or not this is a contact lens.
	// So, we'll use our special godtContactLensRxNumber just to have an extra entry in our global map
	if(godt == godtRxNumber && m_bHasContactLensData) {
		godt = godtContactLensRxNumber;
	}
	NXDATALIST2Lib::IFormatSettingsPtr pFormat(__uuidof(NXDATALIST2Lib::FormatSettings));
	//TES 3/14/2011 - PLID 42757 - Have we already set up this Format?
	if(!g_mapDataTypeFormats.Lookup(godt, pFormat)) {
		//TES 3/14/2011 - PLID 42757 - Nope, set it up.  Fill the Combo with the types of records corresponding to the type.
		switch(godt) {
			case godtLens:
				pFormat->FieldType = NXDATALIST2Lib::cftComboSimple;
				pFormat->DataType = VT_I4;
				pFormat->PutConnection(_variant_t((LPDISPATCH)GetRemoteData()));
				pFormat->ComboSource = _bstr_t(FormatString("%i;%s;%i;%s;",golOD,GetGlassesOrderLensDescription(golOD),
					golOS,GetGlassesOrderLensDescription(golOS)));
				pFormat->Editable = g_cvarTrue;
				break;
			//TES 4/6/2012 - PLID 49367 - These two enums are basically the same, just slightly different contacts in the dropdown
			case godtRxNumber:
			case godtContactLensRxNumber:
				{
					pFormat->FieldType = NXDATALIST2Lib::cftComboSimple;
					pFormat->DataType = VT_I4;
					pFormat->PutConnection(_variant_t((LPDISPATCH)GetRemoteData()));
					CString strComboSource;
					for(GlassesOrderRxNumber gorn = gornSphere; gorn < gorn_LastEnum; gorn = (GlassesOrderRxNumber)(gorn+1)) {
						//TES 4/6/2012 - PLID 49367 - Only add the number if it's supported for the current order type
						if(IsRxNumberSupported(gorn, m_bHasContactLensData)) {
							strComboSource += FormatString("%i;%s;", gorn, GetGlassesOrderRxNumberDescription(gorn));
						}
					}
					pFormat->ComboSource = _bstr_t(strComboSource);
					pFormat->Editable = g_cvarTrue;
				}
				break;
			case godtDesign:
				pFormat->FieldType = NXDATALIST2Lib::cftComboSimple;
				pFormat->DataType = VT_I4;
				pFormat->PutConnection(_variant_t((LPDISPATCH)GetRemoteData()));
				//TES 5/18/2011 - PLID 42757 - Sort the list
				pFormat->ComboSource = _bstr_t("SELECT ID, DesignName FROM GlassesCatalogDesignsT ORDER BY DesignName ASC");
				pFormat->Editable = g_cvarTrue;
				break;
			case godtMaterial:
				pFormat->FieldType = NXDATALIST2Lib::cftComboSimple;
				pFormat->DataType = VT_I4;
				pFormat->PutConnection(_variant_t((LPDISPATCH)GetRemoteData()));
				//TES 5/18/2011 - PLID 42757 - Sort the list
				pFormat->ComboSource = _bstr_t("SELECT ID, MaterialName FROM GlassesCatalogMaterialsT ORDER BY MaterialName ASC");
				pFormat->Editable = g_cvarTrue;
				break;
			case godtTreatment:
				pFormat->FieldType = NXDATALIST2Lib::cftComboSimple;
				pFormat->DataType = VT_I4;
				pFormat->PutConnection(_variant_t((LPDISPATCH)GetRemoteData()));
				//TES 5/18/2011 - PLID 42757 - Sort the list
				pFormat->ComboSource = _bstr_t("SELECT ID, TreatmentName FROM GlassesCatalogTreatmentsT ORDER BY TreatmentName ASC");
				pFormat->Editable = g_cvarTrue;
				break;
			case godtInvalid:
				//TES 3/14/2011 - PLID 42757 - Just disable the dropdown.
				pFormat->Editable = g_cvarFalse;
				break;
		}
		//TES 3/14/2011 - PLID 42757 - Remember this format
		g_mapDataTypeFormats.SetAt(godt, pFormat);
	}
	//TES 3/14/2011 - PLID 42757 - We've got our format now, so set it on the cell.
	short nCol = bIsColumn?cdelcGlassesOrderDataID:delcGlassesOrderDataID;
	pRow->PutRefCellFormatOverride(nCol, pFormat);

	//TES 3/14/2011 - PLID 42757 - Now, if there's no data type selected, visually reflect that the data ID field is not editable.
	switch(godt) {
		case godtInvalid:
			pRow->PutCellBackColor(nCol, DISABLED_COLOR);
			pRow->PutCellBackColorSel(nCol, DISABLED_COLOR_SEL);
			break;
		default:
			pRow->PutCellBackColor(nCol, NXDATALIST2Lib::dlColorNotSet);
			pRow->PutCellBackColorSel(nCol, NXDATALIST2Lib::dlColorNotSet);
			break;		
	}
}

// (r.gonet 08/03/2012) - PLID 51735 - When the wound care coding checkbox is checked, then show or hide the column from the columns datalist
void CEmrItemEntryDlg::ReflectUseWithWoundCareCodingCheck()
{
	ReflectDataElementList(sdeidPriorSelection);
}

//TES 3/14/2011 - PLID 42757 - Global map so that we're only configuring the IFormatSettings once for each type
CMap<long, long, NXDATALIST2Lib::IFormatSettingsPtr, NXDATALIST2Lib::IFormatSettingsPtr> g_mapColumnTypeFormats;

//TES 5/1/2012 - PLID 49367 - This isn't saved to data, just used to distinguish in g_mapColumnTypeFormats between CL and GO options.
#define LIST_TYPE_DROPDOWN_CL	-2

void CEmrItemEntryDlg::ReflectColumnType(NXDATALIST2Lib::IRowSettingsPtr pRow)
{
	long nColumnType = VarLong(pRow->GetValue(cdelcType));
	//TES 3/16/2011 - PLID 42757 - If this row is a label, pretend the type is Checkbox (just because that behaves the same way; i.e., 
	// disabling the Glasses Order fields).
	if(VarBool(pRow->GetValue(cdelcIsLabel))) {
		nColumnType = LIST_TYPE_CHECKBOX;
	}
	//TES 5/1/2012 - PLID 49367 - Dropdowns have different combo sources for Contact Lens data
	if(nColumnType == LIST_TYPE_DROPDOWN && m_bHasContactLensData) {
		nColumnType = LIST_TYPE_DROPDOWN_CL;
	}
	NXDATALIST2Lib::IFormatSettingsPtr pFormat(__uuidof(NXDATALIST2Lib::FormatSettings));
	//TES 3/14/2011 - PLID 42757 - Have we already set up this Format?
	if(!g_mapColumnTypeFormats.Lookup(nColumnType, pFormat)) {
		//TES 3/14/2011 - PLID 42757 - Nope, set it up based on the column type.
		switch(nColumnType) {
			case LIST_TYPE_TEXT:
				//TES 3/14/2011 - PLID 42757 - Text fields can only be an Rx Number
				pFormat->FieldType = NXDATALIST2Lib::cftComboSimple;
				pFormat->DataType = VT_I4;
				pFormat->PutConnection(_variant_t((LPDISPATCH)GetRemoteData()));
				pFormat->ComboSource = _bstr_t(FormatString("-1;;%i;%s",godtRxNumber,GetGlassesOrderDataTypeDescription(godtRxNumber)));
				pFormat->Editable = g_cvarTrue;
				break;
			case LIST_TYPE_DROPDOWN:
				//TES 3/14/2011 - PLID 42757 - Dropdowns can be Rx Number, Design, Material, or Treatment
				//TES 4/16/2012 - PLID 49367 - On Contact Lens items, Rx Number is the only supported field
				pFormat->FieldType = NXDATALIST2Lib::cftComboSimple;
				pFormat->DataType = VT_I4;
				pFormat->PutConnection(_variant_t((LPDISPATCH)GetRemoteData()));
				pFormat->ComboSource = _bstr_t(FormatString("-1;;%i;%s;%i;%s;%i;%s;%i;%s",
					godtRxNumber,GetGlassesOrderDataTypeDescription(godtRxNumber),
					godtDesign,GetGlassesOrderDataTypeDescription(godtDesign),
					godtMaterial,GetGlassesOrderDataTypeDescription(godtMaterial),
					godtTreatment,GetGlassesOrderDataTypeDescription(godtTreatment)));
				pFormat->Editable = g_cvarTrue;
				break;
			case LIST_TYPE_DROPDOWN_CL:
				pFormat->FieldType = NXDATALIST2Lib::cftComboSimple;
				pFormat->DataType = VT_I4;
				pFormat->PutConnection(_variant_t((LPDISPATCH)GetRemoteData()));
				pFormat->ComboSource = _bstr_t(FormatString("-1;;%i;%s",godtRxNumber,GetGlassesOrderDataTypeDescription(godtRxNumber)));
				pFormat->Editable = g_cvarTrue;
				break;
			default:
				pFormat->Editable = g_cvarFalse;
				break;
		}
		//TES 3/14/2011 - PLID 42757 - Remember that we've set this up.
		g_mapColumnTypeFormats.SetAt(nColumnType, pFormat);
	}

	//TES 3/14/2011 - PLID 42757 - We've got our format now, so set it on the cell.
	pRow->PutRefCellFormatOverride(cdelcGlassesOrderDataType, pFormat);
	//TES 3/14/2011 - PLID 42757 - Now, if the list type can't be associated with a Glasses Order, visually reflect that the cell can't be edited.
	switch(nColumnType) {
		case LIST_TYPE_TEXT:
		case LIST_TYPE_DROPDOWN:
		case LIST_TYPE_DROPDOWN_CL:
			pRow->PutCellBackColor(cdelcGlassesOrderDataType, NXDATALIST2Lib::dlColorNotSet);
			pRow->PutCellBackColorSel(cdelcGlassesOrderDataType, NXDATALIST2Lib::dlColorNotSet);
			break;
		default:
			pRow->PutCellBackColor(cdelcGlassesOrderDataType, DISABLED_COLOR);
			pRow->PutCellBackColorSel(cdelcGlassesOrderDataType, DISABLED_COLOR_SEL);
			break;
	}
}



void CEmrItemEntryDlg::OnSelChangedEmrDataList(LPDISPATCH lpOldSel, LPDISPATCH lpNewSel)
{
	try {
		//TES 3/14/2011 - PLID 42784 - Converted to datalist2 (and added error handling)
		ReflectDataElementSelection();
	}NxCatchAll(__FUNCTION__);
}

void CEmrItemEntryDlg::OnRButtonDownEmrDataList(LPDISPATCH lpRow, short nCol, long x, long y, long nFlags)
{
	//TES 3/14/2011 - PLID 42784 - Converted to datalist2
	try {
		// Get the pointer to the window, because we'll be using it more than once
		CWnd *pWnd = GetDlgItem(IDC_EMR_DATA_LIST);
		// Give the datalist focus
		pWnd->SetFocus();
		// Set the selection to the row that was clicked on
		//TES 3/14/2011 - PLID 42784 - Converted to datalist2
		NXDATALIST2Lib::IRowSettingsPtr pRow(lpRow);
		NXDATALIST2Lib::IRowSettingsPtr pOldRow = m_pdlDataElementList->CurSel;
		m_pdlDataElementList->CurSel = pRow;
		// Simulate the event handler for the selection change
		OnSelChangedEmrDataList(pOldRow, pRow);
	} NxCatchAll("CEmrItemEntryDlg::OnRButtonDownEmrDataList");
}

void CEmrItemEntryDlg::OnEditingFinishedEmrDataList(LPDISPATCH lpRow, short nCol, const VARIANT& varOldValue, const VARIANT& varNewValue, BOOL bCommit)
{
	//TES 3/14/2011 - PLID 42784 - Converted to datalist2
	try {
		// This should really be impossible but we should probably check just in case
		NXDATALIST2Lib::IRowSettingsPtr pRow(lpRow);
		if (pRow == NULL) {
			//DRT 6/10/2008 - PLID 29851 - This assertion was hit on 4/30/2008 by y.majeed.  No idea how, my best guess is that she somehow used
			//	inactivate or delete and managed to delete the row faster than this event was fired by the datalist.  Just an FYI if it happens again.
			ASSERT(FALSE);
			return;
		}

		switch (nCol) {
		
		// The data text itself
		case delcData:
			{
				// Get the data element we're working with
				long nSortOrder = VarLong(pRow->GetValue(delcSortOrder));
				long nArrayIndex = GetCurDataElementArrayIndex(nSortOrder, FALSE);
				CEmrInfoDataElement *peide = m_aryCurDataElements.GetAt(nArrayIndex);

				// Add it to the current list if applicable
				BOOL bAddToCurrentList = FALSE;
				// (c.haag 2006-07-05 16:51) - PLID 19862 - This is obselete since we no longer have a current list
				//if(m_bMaintainCurrentList) {
				//	if(m_pSelectListTab->GetCurSel() == sltCurrentList) {
				//		bAddToCurrentList = TRUE;
				//	}
				//}

				// We're dealing with the delcData column, so see if this was a new entry (we'll use this later)
				BOOL bWasNewEntry;
				if (VarLong(pRow->GetValue(delcID)) == -2) {
					bWasNewEntry = TRUE;
				} else {
					bWasNewEntry = FALSE;
				}

				CString strToUse = AsString(varNewValue);
				strToUse.TrimLeft();
				strToUse.TrimRight();

				// (c.haag 2007-03-19 14:55) - PLID 24695 - We now allow users to make whitespace only names, but not empty names.
				// The reason we just don't take out the trimming outright is to prevent users from entering names like "200     "
				// (c.haag 2007-09-26 15:42) - The decision to do this has been reversed now that the importer supports it and
				// by request from the EMR group
				//if (strToUse.IsEmpty()) {
				//	strToUse = AsString(varNewValue);
				//}

				// See if the user committed or canceled
				if (bCommit && !(bWasNewEntry && strToUse == AsString(varOldValue))) {
					// The user committed a change to a data cell
					peide->m_strData = strToUse;

					// (j.gruber 2013-09-27 08:34) - PLID 58676 - update our table cells
					m_TableCellCodes.UpdateRowName(AsString(varOldValue), strToUse);
					//we also have to update the saved one too, since we will be comparing at the end
					m_SavedCellCodes.UpdateRowName(AsString(varOldValue), strToUse);

					// And if it was a new entry we have to update the id, and possibly create another new entry
					if (bWasNewEntry) {
						// It is a new entry, and the user just committed it, so change its ID to be the official 
						// sentinel value that means it's set, rather than the one saying the user hasn't committed 
						// her decision to even create this item yet.
						pRow->PutValue(delcID, (long)-1);
						peide->m_nID = -1;

						// Prompt to add to the current list as will if applicable.
						if(m_bMaintainCurrentList) {
							// (c.haag 2006-07-05 16:51) - PLID 19862 - This is obselete since we no longer have a current list
							//if(m_pSelectListTab->GetCurSel() == sltAdminList) {
							//	if(IDNO != DontShowMeAgain("Would you like to add this item to the current list as well?"
							//		"\r\nIf yes, the item will be added once you save this EMN."
							//		"\r\n\r\n(Checking 'Don't Show Me Again' will always add in the future.)", "AddToCurrentListToo", "Practice", FALSE, TRUE))
							//	{
									bAddToCurrentList = TRUE;
							//	}
							//}
							//else if(m_pSelectListTab->GetCurSel() == sltCurrentList) {
							//	if(IDNO == DontShowMeAgain("Adding an item to the current list requires it to be added to the admin list."
							//		"\r\nDo you still wish to add this item?"
							//		"\r\n\r\n(Checking 'Don't Show Me Again' will always add in the future.)", "AddToAdminListToo", "Practice", FALSE, TRUE))
							//	{
							//		// Cancel the operation
							//		delete peide;
							//		m_aryCurDataElements.RemoveAt(nArrayIndex);
							//		m_pdlDataElementList->RemoveRow(nRow);
							//		m_bAddingMultipleDataElements = FALSE;
							//		ReflectDataElementSelection();
							//		bAddToCurrentList = FALSE;
							//	}
							//}
						}

						// And see if we're in an add-multiple loop
						if (m_bAddingMultipleDataElements) {
							// Go again!
							// (j.jones 2009-08-13 15:53) - PLID 31730 - pass in the next sort order
							OnAddDataItem(FALSE, nSortOrder+1);
						}

					} else {
						// It wasn't a new entry, so we just do nothing because everything is taken care of by the 
						// user in combination with the datalist default behavior

						// (z.manning, 09/22/05, PLID 17249)
						// Actually, there's now one thing we need to do. If a data element was renamed, we need to 
						// also make sure it's renamed in the current list if applicable.
						long nIndex = FindInCurrentList(AsString(varOldValue));
						if(nIndex != -1) {
							CurrentListItem cli = m_aryCurrentList[nIndex];
							//TES 8/11/2006 - Set to strToUse (which is what we will be saving, with the spaces trimmed), NOT varNewValue.
							cli.strData = strToUse;
							m_aryCurrentList.SetAt(nIndex, cli);
						}

						// (j.jones 2012-09-20 12:58) - PLID 52316 - if a label, update the ParentLabelID column's
						// dropdown list with all current labels
						if(peide->m_bIsLabel) {
							RecalculateAndApplyParentLabelComboSql();
						}

						// (j.gruber 2014-08-04 14:48) - PLID 62632 - check for a keyword override
						if (VarString(varOldValue) != strToUse) 
						{
							if (peide->m_bUseKeyword && !peide->m_strKeywordOverride.IsEmpty())
							{
								MsgBox(KEYWORD_OVERRIDE_WARNING);
							}
						}
					}
				} else {
					// User canceled
					if (bWasNewEntry) {
						// It was a new entry and the user canceled it, so delete it

						// (j.jones 2009-08-13 10:02) - PLID 31730 - update the sort orders of all subsequent elements in the cur list
						for (long i=0; i<m_aryCurDataElements.GetSize(); i++) {
							if(m_aryCurDataElements.GetAt(i)->m_nSortOrder > peide->m_nSortOrder)
								m_aryCurDataElements.GetAt(i)->m_nSortOrder--;
						}

						//TES 3/14/2011 - PLID 42784 - Converted to datalist2
						NXDATALIST2Lib::IRowSettingsPtr pTmp = m_pdlDataElementList->GetFirstRow();
						while(pTmp) {
							long nPriorSortOrder = VarLong(pTmp->GetValue(delcSortOrder));
							if (nPriorSortOrder > peide->m_nSortOrder) {
								pTmp->PutValue(delcSortOrder, (long)(nPriorSortOrder - 1));
							}
							pTmp = pTmp->GetNextRow();
						}
						
						// Remove the entry from the array
						delete peide;
						m_aryCurDataElements.RemoveAt(nArrayIndex);

						// Remove the row from the datalist
						m_pdlDataElementList->RemoveRow(pRow);

						// And if we were in an "add-multple" loop then get out of it (because the user canceled)
						m_bAddingMultipleDataElements = FALSE;

						// (j.jones 2009-08-13 15:48) - PLID 31730 - reset the sort order of the last multiply-added row
						m_nLastMultiplyAddedItemSortOrder = -1;

						// Reflect the correct state to the surrounding controls
						ReflectDataElementSelection();

						UpdateFormulaReferences();

						// Make sure it won't be added to the current list (if applicable)
						bAddToCurrentList = FALSE;
					} else {
						// Wasn't a new entry so the cancel is already taken care of by the user in combination with 
						// the datalist default bahavior
					}
				}
				if(bAddToCurrentList) {
					CurrentListItem cli;
					cli.strData = peide->m_strData;
					cli.bSelected = false;
					cli.bSelectedOnTopic = cli.bSelected; // (a.walling 2008-02-07 11:06) - PLID 14982 - Match the selected value
					m_aryCurrentList.Add(cli);
				}
				if(!m_bAddingMultipleDataElements) {
					ReflectDataElementList(sdeidPriorSelection);
				}
			}
			break;

		// The 'inactive' checkbox
		case delcInactive:
			if (bCommit) {
				BOOL bOld = AsBool(varOldValue);
				BOOL bNew = AsBool(varNewValue);
				if (bOld && !bNew) {
					// Switched from inactive to active
					m_pdlCurrentDataElementList = m_pdlDataElementList;
					DoActivateDataElement(pRow);
				} else if (!bOld && bNew) {
					// Switched from active to inactive
					m_pdlCurrentDataElementList = m_pdlDataElementList;
					DoInactivateDataElement(pRow);
				} else {
					// Didn't switch so do nothing
				}
			}
			break;

		// (j.gruber 2010-04-27 08:34) - PLID 38336 bold codes
		// The BOLD Code
		case delcBOLDCode:
			if (bCommit) {
				CString strOld = AsString(varOldValue);
				CString strNew = AsString(varNewValue);
				if (strOld != strNew) {
					long nArrayIndex = GetCurDataElementArrayIndex(pRow->GetValue(delcSortOrder), FALSE);
					m_aryCurDataElements.GetAt(nArrayIndex)->m_strBoldCode = strNew;
				}
			}
			break;

		// The 'default' checkbox
		case delcDefault:
			if (bCommit) {
				BOOL bOld = AsBool(varOldValue);
				BOOL bNew = AsBool(varNewValue);
				if (bOld && !bNew) {
					// Switched from default to NOT default
					long nArrayIndex = GetCurDataElementArrayIndex(pRow->GetValue(delcSortOrder), FALSE);
					m_aryCurDataElements.GetAt(nArrayIndex)->m_bDefault = FALSE;
				} else if (!bOld && bNew) {
					// Switched from NOT default to default
					if (IsDlgButtonChecked(IDC_RADIO_LIST_SELECT)) {
						// Single-select means that any other checked options need to be unselected
						NXDATALIST2Lib::IRowSettingsPtr pTmp = m_pdlDataElementList->GetFirstRow();
						while(pTmp) {
							if (pTmp != pRow) {
								if(!VarBool(pRow->GetValue(delcIsLabel))) 
									pTmp->PutValue(delcDefault, _variant_t(VARIANT_FALSE, VT_BOOL));
								long nArrayIndex = GetCurDataElementArrayIndex(pTmp->GetValue(delcSortOrder), FALSE);
								m_aryCurDataElements.GetAt(nArrayIndex)->m_bDefault = FALSE;
							}
							pTmp = pTmp->GetNextRow();
						}
					}
					// Now update the array element
					long nArrayIndex = GetCurDataElementArrayIndex(pRow->GetValue(delcSortOrder), FALSE);
					m_aryCurDataElements.GetAt(nArrayIndex)->m_bDefault = TRUE;
				} else {
					// Didn't switch so do nothing
				}
			}
			break;

		// (j.jones 2007-08-15 11:50) - PLID 27053 - added UseEMCoding
		case delcUseEMCoding:
			if (bCommit) {
				BOOL bOld = AsBool(varOldValue);
				BOOL bNew = AsBool(varNewValue);
				if (bOld != bNew) {
					long nArrayIndex = GetCurDataElementArrayIndex(pRow->GetValue(delcSortOrder), FALSE);
					m_aryCurDataElements.GetAt(nArrayIndex)->m_bUseEMCoding = bNew;
				}
			}
			break;

		// (j.jones 2011-03-08 12:25) - PLID 42282 - added EMCodeCategoryID
		case delcEMCodeCategoryID:
			if (bCommit) {
				long nOld = VarLong(varOldValue);
				long nNew = VarLong(varNewValue);
				if (nOld != nNew) {
					long nArrayIndex = GetCurDataElementArrayIndex(pRow->GetValue(delcSortOrder), FALSE);
					m_aryCurDataElements.GetAt(nArrayIndex)->m_nEMCodeCategoryID = nNew;
				}
			}
			break;

		case delcIsLabel:
			if(bCommit) {
				BOOL bOld = AsBool(varOldValue);
				BOOL bNew = AsBool(varNewValue);
				if(bOld && !bNew) {
					//Switched from being a label to being a normal item.
					long nArrayIndex = GetCurDataElementArrayIndex(pRow->GetValue(delcSortOrder), FALSE);
					m_aryCurDataElements.GetAt(nArrayIndex)->m_bIsLabel = FALSE;
					//Re-enable the two columns.
					pRow->PutValue(delcDefault, _variant_t(m_aryCurDataElements.GetAt(nArrayIndex)->m_bDefault ? VARIANT_TRUE : VARIANT_FALSE , VT_BOOL));
					CString strActions;
					strActions.Format("<%li Action(s)>", m_aryCurDataElements.GetAt(nArrayIndex)->m_arActions.GetSize());
					pRow->PutValue(delcAction, _bstr_t(strActions));
					// (j.gruber 2010-04-27 09:50) - PLID 38336 - BOLD Code
					pRow->PutValue(delcBOLDCode, _variant_t(m_aryCurDataElements.GetAt(nArrayIndex)->m_strBoldCode));
					pRow->PutCellLinkStyle(delcAction, NXDATALIST2Lib::dlLinkStyleTrue);
					//TES 3/16/2011 - PLID 42757 - Restore the Glasses Order field
					pRow->PutCellBackColor(delcGlassesOrderDataType, NXDATALIST2Lib::dlColorNotSet);

					// (j.gruber 2014-09-23 14:01) - PLID 62621 - Keyword column
					pRow->PutValue(delcUseKeyWord, _variant_t(m_aryCurDataElements.GetAt(nArrayIndex)->m_bUseKeyword ? VARIANT_TRUE : VARIANT_FALSE, VT_BOOL));
					//don't need to worry about coloring here, because this is always going to be false, since we clear it when we marked it as a label

					// (j.jones 2012-09-20 12:37) - PLID 52316 - if this label was the parent of any other
					// list entries, clear its parent ID
					TryRemoveParentLabelReferences(m_aryCurDataElements.GetAt(nArrayIndex));

					// (j.jones 2012-09-20 12:39) - PLID 52316 - recalculate the available parents
					RecalculateAndApplyParentLabelComboSql();

					// (j.gruber 2013-10-02 12:15) - PLID 58674
					CString strCodes;
					strCodes.Format("<%li Codes(s)>", m_aryCurDataElements.GetAt(nArrayIndex)->m_aryCodes.GetSize());
					pRow->PutValue(delcCodes, _bstr_t(strCodes));
				}
				else if(!bOld && bNew) {
					//Switched from a normal item to a label.
					long nArrayIndex = GetCurDataElementArrayIndex(pRow->GetValue(delcSortOrder), FALSE);
					m_aryCurDataElements.GetAt(nArrayIndex)->m_bIsLabel = TRUE;
					//Disable the two columns.
					_variant_t varNull;
					varNull.vt = VT_NULL;
					pRow->PutValue(delcDefault, varNull);
					pRow->PutValue(delcAction, varNull);
					// (j.gruber 2010-04-27 09:50) - PLID 38336 - BOLD Code
					pRow->PutValue(delcBOLDCode, varNull);
					pRow->PutCellLinkStyle(delcAction, NXDATALIST2Lib::dlLinkStyleFalse);
					//TES 3/16/2011 - PLID 42757 - Clear out the Glasses Order columns for Labels.
					pRow->PutValue(delcGlassesOrderDataType, varNull);
					pRow->PutCellBackColor(delcGlassesOrderDataType, DISABLED_COLOR);
					pRow->PutCellBackColorSel(delcGlassesOrderDataType, DISABLED_COLOR_SEL);
					pRow->PutCellBackColor(delcGlassesOrderDataID, DISABLED_COLOR);
					pRow->PutCellBackColorSel(delcGlassesOrderDataID, DISABLED_COLOR_SEL);
					pRow->PutValue(delcGlassesOrderDataID, varNull);
					m_aryCurDataElements.GetAt(nArrayIndex)->m_GlassesOrderDataType = godtInvalid;
					m_aryCurDataElements.GetAt(nArrayIndex)->m_nGlassesOrderDataID = -1;
					// (r.gonet 08/03/2012) - PLID 51735
					m_aryCurDataElements.GetAt(nArrayIndex)->m_ewccWoundCareDataType = wcdtNone;

					// (j.jones 2012-09-20 12:39) - PLID 52316 - recalculate the available parents
					RecalculateAndApplyParentLabelComboSql();
					// (j.gruber 2013-10-02 12:16) - PLID 58674
					pRow->PutValue(delcCodes, varNull);
					// (j.gruber 2014-09-23 14:01) - PLID 62621 - Keyword column - clear the keyword 
					m_aryCurDataElements.GetAt(nArrayIndex)->m_bUseKeyword = FALSE;
					pRow->PutValue(delcUseKeyWord, varNull);
					//take off any coloring
					pRow->PutCellBackColor(delcUseKeyWord, HAS_NO_KEYWORD_OVERRIDE_COLOR);

				}
				else {
					//Didn't switch so don't do anything.
				}
			}
			break;
		// (j.gruber 07/15/2014) - plid 62621
		case delcUseKeyWord:
			if (bCommit)
			{
				BOOL bOldVal = AsBool(varOldValue);
				BOOL bNewVal = AsBool(varNewValue);

				if (bOldVal != bNewVal)
				{
					long nArrayIndex = GetCurDataElementArrayIndex(pRow->GetValue(delcSortOrder), FALSE);
					m_aryCurDataElements.GetAt(nArrayIndex)->m_bUseKeyword = bNewVal;					

					// (j.gruber 2014-07-30 13:20) - PLID 62630 - do we already have an override
					if (m_aryCurDataElements.GetAt(nArrayIndex)->m_bUseKeyword && !m_aryCurDataElements.GetAt(nArrayIndex)->m_strKeywordOverride.IsEmpty())
					{ 
						pRow->PutCellBackColor(delcUseKeyWord, HAS_KEYWORD_OVERRIDE_COLOR);
					}
					else
					{
						pRow->PutCellBackColor(delcUseKeyWord, HAS_NO_KEYWORD_OVERRIDE_COLOR);
					}
				}					
			}
			break;
		// (j.jones 2012-09-20 12:37) - PLID 52316 - added ParentLabelID
		case delcParentLabelID:
			if(bCommit) {
				long nArrayIndex = GetCurDataElementArrayIndex(pRow->GetValue(delcSortOrder), FALSE);
				CEmrInfoDataElement *peide = m_aryCurDataElements.GetAt(nArrayIndex);

				//assign the selection to this item
				if(varNewValue.vt == VT_I4) {
					long nNewParentPtr = VarLong(varNewValue, 0);
					if(nNewParentPtr != 0) {
						CEmrInfoDataElement *peideNewParent = (CEmrInfoDataElement*)nNewParentPtr;
						//always assign the pointer
						peide->m_peideParentLabelPtr = peideNewParent;
						//assign the ID, it might be -1 if the parent is new
						peide->m_nParentLabelID = peideNewParent->m_nID;
					}
					else {
						//clear the values
						peide->m_peideParentLabelPtr = NULL;
						peide->m_nParentLabelID = -1;
					}
				}
				else {
					//clear the values
					peide->m_peideParentLabelPtr = NULL;
					peide->m_nParentLabelID = -1;
				}
			}
			break;

		//TES 3/11/2011 - PLID 42757 - Added Glasses Order data
		case delcGlassesOrderDataType:
			if(bCommit) {
				long nOld = VarLong(varOldValue,(long)godtInvalid);
				long nNew = VarLong(varNewValue,(long)godtInvalid);
				if(nOld != nNew) {
					long nArrayIndex = GetCurDataElementArrayIndex(pRow->GetValue(delcSortOrder), FALSE);
					m_aryCurDataElements.GetAt(nArrayIndex)->m_GlassesOrderDataType = (GlassesOrderDataType)nNew;
					//TES 3/14/2011 - PLID 42757 - Since the DataType changed, clear out the DataID, then update the cell format so that the
					// combo has the right fields.
					pRow->PutValue(delcGlassesOrderDataID, g_cvarNull);
					m_aryCurDataElements.GetAt(nArrayIndex)->m_nGlassesOrderDataID = -1;
					ReflectGlassesOrderDataType(pRow, FALSE);
				}
			}
			break;
		case delcGlassesOrderDataID:
			if(bCommit) {
				long nOld = VarLong(varOldValue,-1);
				long nNew = VarLong(varNewValue,-1);
				if(nOld != nNew) {
					long nArrayIndex = GetCurDataElementArrayIndex(pRow->GetValue(delcSortOrder), FALSE);
					m_aryCurDataElements.GetAt(nArrayIndex)->m_nGlassesOrderDataID = nNew;
				}
			}
			break;


		}
	} NxCatchAll("CEmrItemEntryDlg::OnEditingFinishedEmrDataList");
}

void CEmrItemEntryDlg::OnLeftClickEmrDataList(LPDISPATCH lpRow, short nCol, long x, long y, long nFlags)
{
	//TES 3/14/2011 - PLID 42784 - Converted to datalist2
	try {
		// Make sure we clicked a row
		NXDATALIST2Lib::IRowSettingsPtr pRow(lpRow);
		if (pRow == NULL) {
			return;
		}

		// Handle which cell we clicked in
		if (nCol == delcAction) {
			// We clicked in the action cell, which means the user wants to drill into the actions

			CWaitCursor wc;

			// First get the array element we're dealing with
			CEmrInfoDataElement *peide = m_aryCurDataElements.GetAt(GetCurDataElementArrayIndex(VarLong(pRow->GetValue(delcSortOrder)), FALSE));
			
			if(!peide->m_bIsLabel) {
				// Prep the actions dialog
				CEmrActionDlg dlg(this);
				if(m_pCurrentEMN) {
					dlg.SetCurrentEMN(m_pCurrentEMN);
				}
				dlg.m_SourceType = eaoEmrDataItem;
				dlg.m_nSourceID = CEmrActionDlg::bisidNotBoundToData;
				dlg.m_strSourceObjectName = peide->m_strData;
				dlg.m_nOriginatingID = m_nID;
				// (a.walling 2007-11-05 16:08) - PLID 27980 - VS2008 - for() loops
				int i = 0;
				for(i = 0; i < peide->m_arActions.GetSize(); i++) dlg.m_arActions.Add(peide->m_arActions[i]);
				// Pop up the dialog
				if (dlg.DoModal() == IDOK) {
					// The user clicked OK, so write the selected actions back to our data element's array
					peide->m_arActions.RemoveAll();
					for(i=0; i < dlg.m_arActions.GetSize(); i++) peide->m_arActions.Add(dlg.m_arActions[i]);
					pRow->PutValue(delcAction, (LPCTSTR)("<" + AsString((long)peide->m_arActions.GetSize()) + " action(s)>"));
				}
			}
		}

		// (j.gruber 2013-10-02 11:53) - PLID 58674 - codes
		if (nCol == delcCodes)
		{
			CEmrInfoDataElement *peide = m_aryCurDataElements.GetAt(GetCurDataElementArrayIndex(VarLong(pRow->GetValue(delcSortOrder)), FALSE));

			CEMRCodeArray aryOrig;
			aryOrig = peide->m_aryCodes;
			CEMRCodeArray pTmp;
			pTmp = peide->m_aryCodes;
			CEMRCodeEditorDlg dlgCodes(&pTmp);

			if (dlgCodes.DoModal() == IDOK) 
			{
				//did our code array change
				if (aryOrig.IsDifferent(&pTmp)) 
				{
					//remove our current array values
					peide->m_aryCodes.RemoveAll();
					//add the new codes
					peide->m_aryCodes = pTmp;						
				}

				//update the link
				pRow->PutValue(delcCodes, (LPCTSTR)("<" + AsString((long)peide->m_aryCodes.GetSize()) + " code(s)>"));

			}
		}		
		
	} NxCatchAll("CEmrItemEntryDlg::OnLeftClickEmrDataList");
}


void CEmrItemEntryDlg::OnEditingFinishingEmrDataList(LPDISPATCH lpRow, short nCol, const VARIANT& varOldValue, LPCTSTR strUserEntered, VARIANT* pvarNewValue, BOOL* pbCommit, BOOL* pbContinue)
{
	//TES 3/14/2011 - PLID 42784 - Converted to datalist2 (and added exception handling)
	try {
		//TES 3/18/2011 - PLID 42858 - If we're not committing, we don't need to do anything here
		if(*pbCommit == FALSE) {
			return;
		}
		NXDATALIST2Lib::IRowSettingsPtr pRow(lpRow);
		switch (nCol) 
		{
			// (z.manning 2010-05-03 16:30) - PLID 29301 - We do not support labels for allergy or medication rows
			case delcIsLabel:
				if(IsSystemCurrentMedicationsItem() || IsSystemAllergiesItem()) {
					*pbCommit = FALSE;
					*pbContinue = FALSE;
					return;
				}
				break;

			case delcData:
			case delcInactive:
			case delcDefault:
				// (a.walling 2007-04-04 15:19) - PLID 25459 - Check for Medication permission
				// (will prompt for passwords)
				// we may want to allow some operations even if they don't have permission to edit the medication list
				// hence this switch statement.				
				if (IsSystemCurrentMedicationsItem()) {
					if(!CheckCurrentUserPermissions(bioPatientMedication, sptDynamic0)) {
						*pbCommit = FALSE;
						*pbContinue = TRUE;
						return;
					}
				}
				// (z.manning, 08/07/2007) - PLID 25741 - If it's the built-in allergies item, make sure the user has the permission to edit it.
				if(IsSystemAllergiesItem() && _variant_t(varOldValue) != *pvarNewValue) {
					if(!CheckCurrentUserPermissions(bioPatientAllergies, sptDynamic0)) {
						*pbCommit = FALSE;
						*pbContinue = TRUE;
						return;
					}
				}
				break;
		}

		// (j.gruber 2007-08-07 16:40) - PLID 26975 - check if they are trying to change an allergy
		if (IsSystemAllergiesItem()) {

			if (*pbCommit) {
				switch (nCol) {

					case delcData:

						if (VarString(varOldValue, "").Compare(VarString(pvarNewValue, "")) != 0) {

							long nEmrDataID = VarLong(pRow->GetValue(delcID), -1);

							//check if it is in use
							_RecordsetPtr rsCount = CreateParamRecordset("SELECT Count(*) as Count FROM EMRDetailTableDataT "
							"LEFT JOIN EmrDataT ON EmrDataT.ID = EMRDetailTableDataT.EMRDataID_Y "
							"WHERE "
							// The table data belongs to a detail that is not deleted
							"EmrDetailID IN (SELECT ID FROM EMRDetailsT WHERE Deleted = 0 AND EMRID IN (SELECT ID FROM EMRMasterT WHERE Deleted = 0)) "
							// (z.manning 2008-12-10 16:00) - PLID 32389 - We now check for non-blank data in all column types
							// (a.walling 2009-04-03 10:44) - PLID 33831 - blank data is no longer saved to the database
							/*
							"	AND Len(EMRDetailTableDataT.Data) > 0 \r\n"
							"	AND ( \r\n"
							"		(ListType = 4 AND EMRDetailTableDataT.Data <> '0' AND EMRDetailTableDataT.Data <> '-1') \r\n" // dropdown
							"		OR (ListType = 5 AND EMRDetailTableDataT.Data <> '0' AND EMRDetailTableDataT.Data <> '-1') \r\n" // checkbox
							"	) \r\n"					
							*/
							// The table row belongs to this allergy
							"AND EMRDataID_X IN ({INT}) ", nEmrDataID);
							if (!rsCount->eof) {
								long nCount = AdoFldLong(rsCount, "Count", -1);

								if (nCount > 0) {
									CString strMsg;
									strMsg.Format("This allergy is in use by %li patient medical record(s).  You may not rename it", nCount);
									MsgBox(strMsg);
									*pbContinue = TRUE;
									*pbCommit = FALSE;
									return;
								}
							}
							rsCount = CreateParamRecordset("SELECT Count(ID) as Count FROM PatientAllergyT WHERE AllergyID IN (SELECT ID FROM AllergyT WHERE EmrDataID = {INT}) ", nEmrDataID);
							if (!rsCount->eof) {
								long nCount = AdoFldLong(rsCount, "Count", -1);

								if (nCount > 0) {
									CString strMsg;
									strMsg.Format("This allergy is in use by %li patient(s).  You may not rename it", nCount);
									MsgBox(strMsg);
									*pbContinue = TRUE;
									*pbCommit = FALSE;
									return;
								}
							}
						}			
					break;
				}
			}
			else {
				return;
			}
		}

		// (j.gruber 2007-08-09 14:34) - PLID 26973 - make sure they don't rename medications
		if (IsSystemCurrentMedicationsItem()) {

			if (*pbCommit) {
				switch (nCol) {

					case delcData:

						if (VarString(varOldValue, "").Compare(VarString(pvarNewValue, "")) != 0) {
							
							CString strCounts;
							long nEmrDataID = VarLong(pRow->GetValue(delcID), -1);
							_RecordsetPtr rsMedID = CreateParamRecordset("SELECT ID FROM Druglist WHERE EMRDataID = {INT}", nEmrDataID);
							if (! rsMedID->eof) {
								long nMedicationID = AdoFldLong(rsMedID, "ID");
								CString strMessage;
								if (IsMedicationInUse(nMedicationID, strCounts)) {

									strMessage.Format("This medication is in use on:\n%s\nYou may not rename it.", strCounts);
									MsgBox(strMessage);
									*pbCommit = FALSE;
									*pbContinue = TRUE;
									return;
								}
							}
						}
					break;
				}
			}
			else {
				return;
			}
		}


		switch (nCol) {
		case delcData:
			try {
				//TES 3/15/2011 - PLID 42858 - If we're not committing, we don't need to do anything here
				if(*pbCommit == FALSE) {
					return;
				}

				CString strToCheck = strUserEntered;

				// (c.haag 2007-03-19 14:41) - PLID 24695 - If the string is empty, do not let the user save it.
				// Unlike PLID 24423 with medications, we generally allow strings with whitespaces only
				// (c.haag 2007-09-26 15:42) - The decision to do this has been reversed now that the importer supports it and
				// by request from the EMR group
				/*if (strToCheck.IsEmpty()) {
					if(IsDlgButtonChecked(IDC_RADIO_TABLE)) {
						AfxMessageBox("You must assign a name to this row.", MB_OK | MB_ICONHAND);
					} else {
						AfxMessageBox("You must assign a name to this list item.", MB_OK | MB_ICONHAND);
					}
					*pbCommit = FALSE;
					return;
				}*/

				strToCheck.TrimLeft();
				strToCheck.TrimRight();

				// (c.haag 2007-02-14 14:53) - PLID 24423 - Don't allow blank names for medications
				if (IsSystemCurrentMedicationsItem() && cdelcData == nCol && strToCheck.IsEmpty()) {
					AfxMessageBox("You must enter a non-empty name for the medication.");
					*pbCommit = FALSE;
					return;
				}
				// (c.haag 2007-04-03 09:19) - PLID 25468 - Don't allow blank names for allergies
				if (IsSystemAllergiesItem() && cdelcData == nCol && strToCheck.IsEmpty()) {
					AfxMessageBox("You must enter a non-empty name for the allergy.");
					*pbCommit = FALSE;
					return;
				}

				if(strToCheck.CompareNoCase(VarString(varOldValue,"")) != 0) {

					/**** (j.gruber 2013-09-30 10:48) - PLID 58676 - THE TABLE CELL CODES WORK ON THE FACT THAT NO ROWS/COLUMNS HAVE THE SAME NAME
					IF THIS EVER CHANGES IN THE FUTURE, YOU'LL NEED TO CHANGE THAT FUNCTIONALITY ALSO*/

					for(int i=0; i<m_aryCurDataElements.GetSize(); i++) {
						if(strToCheck.CompareNoCase(m_aryCurDataElements.GetAt(i)->m_strData) == 0) {
							CString strWarning;
							if(IsDlgButtonChecked(IDC_RADIO_TABLE)) {
								if(m_aryCurDataElements.GetAt(i)->m_bInactive) {
									strWarning = "This table already has an inactive row with the name you entered.\n"
										"A table cannot have two rows with the same name. You may, however, reactivate the existing row.";
								}
								else {
									strWarning = "This table already has a row with the name you entered.\n"
										"A table cannot have two rows with the same name.";
								}
							}
							else {
								// (z.manning, 9/22/05, PLID 17249)
								// They may be trying to add an item to the current list that is only in the admin list, 
								// in which case, just add it to the current list without warning.
								// (c.haag 2006-07-05 16:51) - PLID 19862 - This is obselete since we no longer have a current list
								//if(m_bMaintainCurrentList && m_pSelectListTab->GetCurSel() == sltCurrentList && FindInCurrentList(strToCheck) == -1) {
								//	CurrentListItem cli;
								//	cli.strData = strToCheck;
								//	cli.bSelected = false;
								//	m_aryCurrentList.Add(cli);
								//	*pbCommit = FALSE;
								//	return;
								//}
								//else {
									if(m_aryCurDataElements.GetAt(i)->m_bInactive) {
										strWarning = "This list already has an item with the name you entered.\n"
											"A list cannot have two items with the same name. You may, however, reactivate the existing item.";
									}
									else {
										strWarning = "This list already has an item with the name you entered.\n"
											"A list cannot have two items with the same name.";
									}
								//}
							}

							AfxMessageBox(strWarning);

							*pbCommit = FALSE;
							return;
						}
					}
				}

				//TES 3/15/2011 - PLID 42858 - Why would we touch this variable here?
				//*pbCommit = TRUE;
				return;
			}
			NxCatchAll("Error in OnEditingFinishingEmrColumnDataList");
			*pbCommit = FALSE;
			break;

		case delcDefault:
			if(VarBool(pRow->GetValue(delcIsLabel))) {
				*pbCommit = FALSE;
			}
			break;

		case delcIsLabel:
			try {
				if(VarBool(varOldValue)) { //switching from label to non-label
					// (j.jones 2012-09-21 13:18) - PLID 52316 - if a label, see if any row is using this label as a parent
					if(IsDlgButtonChecked(IDC_RADIO_LIST_SELECT) || IsDlgButtonChecked(IDC_RADIO_LIST_MULTISELECT)) {
						BOOL bInUse = FALSE;
						long nArrayIndex = GetCurDataElementArrayIndex(pRow->GetValue(delcSortOrder), FALSE);
						CEmrInfoDataElement *peide = m_aryCurDataElements.GetAt(nArrayIndex);
						for(int i=0;i<m_aryCurDataElements.GetSize() && !bInUse; i++) {
							CEmrInfoDataElement *peideCheck = m_aryCurDataElements.GetAt(i);
							if(peideCheck != NULL && peideCheck->m_peideParentLabelPtr == peide) {
								//flag that it is in use
								bInUse = TRUE;
							}
						}

						if(bInUse && IDYES != MessageBox("Removing the label status from this list item will clear the parent selection from all list items referencing this label.\n\n"
							"Are you sure you want to remove the label status?", "Practice", MB_ICONEXCLAMATION|MB_YESNO)) {
							*pbCommit = FALSE;
							return;
						}
					}
				}
				//TES 10/10/2006 - PLID 22362 - These warnings are only meaningful if this record isn't already a label.
				else if(!VarBool(varOldValue)) {
					long nArrayIndex = GetCurDataElementArrayIndex(pRow->GetValue(delcSortOrder), FALSE);
					CEmrInfoDataElement *peide = m_aryCurDataElements.GetAt(nArrayIndex);
					long nEmrDataID = VarLong(pRow->GetValue(delcID), -1);

					// (z.manning 2010-05-04 10:55) - PLID 29301 - Can't be a label if it's used in a formula
					CString strReferencingRow;
					if(IsDataElementReferencedInAnyFormula(peide, m_aryCurDataElements, m_aryCurColumnDataElements, strReferencingRow)) {
						MessageBox(FormatString("This item is referenced in the formula for item '%s.'\r\n\r\n"
							"You may not make this item a label.", strReferencingRow));
						*pbCommit = FALSE;
						return;
					}
					
					//TES 4/30/2008 - PLID 29748 - First, check our current item, since that doesn't require any data access.
					BOOL bInUseByCurrent = FALSE;
					BOOL bInUseByTopic = FALSE;
					CheckDataItemUse(nEmrDataID, false, bInUseByCurrent, bInUseByTopic);
					if(bInUseByCurrent) {
						MsgBox("This item is selected on the item you are currently editing.  It cannot be made into a label.");
						*pbCommit = FALSE;
						return;
					}
					else if(bInUseByTopic) {
						if(IDYES != MsgBox("This data item has been selected on the topic. Changing this item to a label will not revoke any actions associated with it. Do you want to continue?")) {
							*pbCommit = FALSE;
							return;
						}
					}
					
					// (z.manning 2010-04-19 15:08) - PLID 29301 - Moved the logic here to its own function
					if(CheckDataItemUseInDataForLabel(nEmrDataID)) {
						*pbCommit = FALSE;
						return;
					}
					
					// (z.manning 2010-05-04 11:09) - PLID 29301 - We need to clear out the formula if they are making this a label
					if(!peide->m_strFormula.IsEmpty()) {
						if(IDYES != MessageBox("If you this make this item a label it will delete its formula. Are you sure you want to make it a label?", NULL, MB_YESNO)) {
							*pbCommit = FALSE;
							return;
						}
						peide->m_strFormula.Empty();
					}
				}
				//TES 3/15/2011 - PLID 42858 - Why would we touch this variable here?
				//*pbCommit = TRUE;
				return;
			}
			NxCatchAll("Error 2 in OnEditingFinishingEmrDataList");
			*pbCommit  = FALSE;
			break;

		// (j.jones 2012-09-20 12:37) - PLID 52316 - added ParentLabelID
		case delcParentLabelID:
			{
				//disallow selecting the current row as its own parent
				long nArrayIndex = GetCurDataElementArrayIndex(pRow->GetValue(delcSortOrder), FALSE);
				CEmrInfoDataElement *peide = m_aryCurDataElements.GetAt(nArrayIndex);

				if(peide != NULL && pvarNewValue->vt == VT_I4 && VarLong(pvarNewValue,0) != 0) {
					//they've selected a new parent, now check for validity

					if(VarLong(pvarNewValue,0) == (long)peide) {
						MsgBox("You cannot select the same label to be a parent of itself.");
						*pbCommit = FALSE;
						break;
					}
					else if(VarBool(pRow->GetValue(delcIsLabel))) {
						//If this row is a label, you could potentially select a parent that would cause
						//a loop. (ie. Label A with parent of Label B, which has a parent of Label A.)
						//So try to stop that.						
						CEmrInfoDataElement *peideSelectedParent = (CEmrInfoDataElement*)VarLong(pvarNewValue,0);
						CEmrInfoDataElement *peideCurParent = peideSelectedParent;
						while(peideCurParent != NULL && *pbCommit != FALSE) {
							//loop to the top level parent, and break if we find the current label
							if(peideCurParent == peide) {
								//insert price is right failure horns here

								//give a context sensitive message based on whether this is a direct parent, or indirect
								CString strMsg;
								if(peideCurParent == peideSelectedParent->m_peideParentLabelPtr) {
									//it's a direct parent (A->B->A)
									strMsg.Format("You cannot select '%s' as a parent of '%s' because '%s' uses '%s' as a parent.",
										peideSelectedParent->m_strData, peide->m_strData, peideSelectedParent->m_strData, peide->m_strData);
								}
								else {
									//it must be an indirect parent (A->B->C->A)
									strMsg.Format("You cannot select '%s' as a parent of '%s' because '%s' has a parent that is connected to '%s'.",
										peideSelectedParent->m_strData, peide->m_strData, peideSelectedParent->m_strData, peide->m_strData);
								}

								MsgBox(strMsg);
								*pbCommit = FALSE;
								break;
							}
							peideCurParent = peideCurParent->m_peideParentLabelPtr;
						}
					}
				}
			}
			break;

			// (j.gruber 2010-06-02 16:01) - PLID 38336 - warn if they try to change the BOLD code
		case delcBOLDCode:
			{
				if (*pbCommit) {
					//check to see if they are over 50 characters
					CString strEntered = strUserEntered;
					if (strEntered.GetLength() > 50) {
						//(a.wilson 2011-9-1) PLID 45307 - Reworded from BOLD to export
						MessageBox("You have entered an export code over 50 characters in length.  Please correct this.");
						*pbContinue = FALSE;
						*pbCommit = FALSE;
						return;
					}
				
				

					//warn them about changing BOLD Codes
					if (pvarNewValue->vt == VT_BSTR && varOldValue.vt == VT_BSTR) {

						if (VarString(pvarNewValue, "") != VarString(varOldValue, "")) {
							if (m_bWarnBold) {		
								//(a.wilson 2011-9-1) PLID 45307 - Reworded from "is sent to BOLD." to "is exported."
								//only warn once per yes per dialog
								if (IDNO == MessageBox("Changing this data could cause errors in the information that is exported.\r\n"
									"You should not change this information unless instructed to by NexTech personnel. \r\n"
									"Are you sure you want to change this?",						
									"Practice", MB_YESNO)) {							
										*pbCommit = FALSE;
										*pbContinue = TRUE;
										return;
								}
								m_bWarnBold = FALSE;				
							}
						}
					}
				}
			}

			
		break;

		default:
			break;
		}
	}NxCatchAll(__FUNCTION__);
}

void CEmrItemEntryDlg::EditingStartingEmrDataList(LPDISPATCH lpRow, short nCol, VARIANT* pvarValue, BOOL* pbContinue)
{
	//TES 3/14/2011 - PLID 42784 - Converted to datalist2
	try {
		NXDATALIST2Lib::IRowSettingsPtr pRow(lpRow);
		// (j.gruber 2010-04-27 09:54) - PLID 38336 - if its a label, don't allow editing the BOLD Code
		//TES 3/16/2011 - PLID 42757 - Likewise the Glasses Order fields
		if (nCol == delcBOLDCode || nCol == delcGlassesOrderDataType || nCol == delcGlassesOrderDataID) {
			BOOL bLabel = VarBool(pRow->GetValue(delcIsLabel));
			if (bLabel) {
				*pbContinue = FALSE;
			}
			else if(nCol == delcGlassesOrderDataID) {
				//TES 3/11/2011 - PLID 42757 - You can't edit this field if you haven't selected a record type
				if(pRow->GetValue(delcGlassesOrderDataType).vt == VT_NULL) {
					*pbContinue = FALSE;
				}
			}
		}

	}NxCatchAll(__FUNCTION__);
}

void CEmrItemEntryDlg::OnEditingStartingEmrColumnList(LPDISPATCH lpRow, short nCol, VARIANT* pvarValue, BOOL* pbContinue)
{
	//TES 3/14/2011 - PLID 42784 - Converted to datalist2 (and added exception handling)
	try {
		NXDATALIST2Lib::IRowSettingsPtr pRow(lpRow);
		// (c.haag 2007-01-29 16:37) - PLID 24423 - No matter what column we are on, if this is
		// a system Current Medications item and the row is zero (meaning it's the Rx column), then
		// we may not edit the data item
		if (pRow == m_pdlColumnDataElementList->GetFirstRow() && IsSystemCurrentMedicationsItem()) {
			MsgBox("You may not edit the Rx column of the system Current Medications item");		
			*pbContinue = FALSE;
			return;
		}

		// (c.haag 2007-04-05 11:57) - PLID 25468 - If this is a system Allergies item and the row
		// is zero (meaning it's the Yes column), then we may not edit the data item
		if (pRow == m_pdlColumnDataElementList->GetFirstRow() && IsSystemAllergiesItem()) {
			MsgBox("You may not edit the Yes column of the system Allergies item");		
			*pbContinue = FALSE;
			return;
		}

		if(pRow != NULL)
		{
			long nArrayIndex = GetCurDataElementArrayIndex(VarLong(pRow->GetValue(cdelcSortOrder)), TRUE);
			CEmrInfoDataElement *peide = m_aryCurColumnDataElements.GetAt(nArrayIndex);

			// (z.manning 2010-05-04 09:26) - PLID 29301 - Do not let them change the type of a label column
			//TES 3/16/2011 - PLID 42757 - Likewise the Glasses Order fields
			if((nCol == cdelcType || nCol == cdelcGlassesOrderDataType || nCol == cdelcGlassesOrderDataID) && peide->m_bIsLabel) {
				*pbContinue = FALSE;
				return;
			}

			// (z.manning 2010-02-12 11:27) - PLID 37320 - Do not allow them to edit the default built-in
			// columns on smart stamp tables.
			// (z.manning 2011-09-01 12:46) - PLID 45297 - We used to check if this item was actually a smart stamp
			// table here, however, for safety and to avoid confusion we should always do this check on the built-in 
			// smart stamp column types.
			BYTE nListSubType = VarByte(pRow->GetValue(cdelcSubType));
			if(IsSmartStampListSubType(nListSubType))
			{
				switch(nCol)
				{
					// (z.manning 2010-02-12 11:28) - PLID 37320 - J.Jones is fairly certain it's ok for them
					// to still set these columns for E/M coding.
					// (z.manning 2010-04-09 10:45) - PLID 37937 - We now allow them to rename and inactivate these columns.
					case cdelcUseEMCoding:
					case cdelcData:
					case cdelcInactive:
					// (j.jones 2011-03-08 12:25) - PLID 42282 - supported EMCodeCategoryID
					case cdelcEMCodeCategoryID:
					//TES 3/11/2011 - PLID 42757 - Added Glasses Order data
					case cdelcGlassesOrderDataType:
					case cdelcGlassesOrderDataID:
						break;

					default:
						MessageBox("This element is needed for Smart Stamps and may not be edited.");
						*pbContinue = FALSE;
						break;
				}
			}

			// (j.jones 2011-05-03 16:11) - PLID 43527 - disallow editing the Current Meds Sig column
			if(m_DataSubType == eistCurrentMedicationsTable && IsCurrentMedicationListSubType(nListSubType))
			{
				switch(nCol)
				{
					//these columns are permitted to be edited
					case cdelcInactive:
					case cdelcUseEMCoding:
					case cdelcEMCodeCategoryID:
					case cdelcGlassesOrderDataType:
					case cdelcGlassesOrderDataID:
						break;

					//for now we're disallowing renaming the Sig column, though it is arguably
					//safe to let them do it, it would just be confusing
					case cdelcData:
					default:
						MessageBox("This element is needed for Current Medications and may not be edited.");
						*pbContinue = FALSE;
						break;
				}
			}

			switch(nCol) {
				case cdelcGlassesOrderDataID:
					//TES 3/11/2011 - PLID 42757 - You can't edit this field if you haven't selected a record type
					if(pRow->GetValue(cdelcGlassesOrderDataType).vt == VT_NULL) {
						*pbContinue = FALSE;
					}
					break;
			}
		}
	}NxCatchAll(__FUNCTION__);
}

void CEmrItemEntryDlg::OnSelChangedEmrColumnList(LPDISPATCH lpOldSel, LPDISPATCH lpNewSel)
{
	//TES 3/14/2011 - PLID 42784 - Converted to datalist2 (and added exception handling)
	try {
		ReflectDataElementSelection();
	}NxCatchAll(__FUNCTION__);
}

void CEmrItemEntryDlg::OnRButtonDownEmrColumnList(LPDISPATCH lpRow, short nCol, long x, long y, long nFlags)
{
	//TES 3/14/2011 - PLID 42784 - Converted to datalist2
	try {
		NXDATALIST2Lib::IRowSettingsPtr pRow(lpRow);
		// Get the pointer to the window, because we'll be using it more than once
		// (a.walling 2009-01-23 16:29) - PLID 32849 - Setting focus to the wrong window
		CWnd *pWnd = GetDlgItem(IDC_EMR_COLUMN_LIST);
		// Give the datalist focus
		pWnd->SetFocus();
		// Set the selection to the row that was clicked on
		NXDATALIST2Lib::IRowSettingsPtr pOldRow = m_pdlColumnDataElementList->CurSel;
		m_pdlColumnDataElementList->CurSel = pRow;
		// Simulate the event handler for the selection change
		OnSelChangedEmrColumnList(pOldRow, pRow);

	} NxCatchAll("CEmrItemEntryDlg::OnRButtonDownEmrColumnDataList");
}

void CEmrItemEntryDlg::OnEditingFinishingEmrColumnList(LPDISPATCH lpRow, short nCol, const VARIANT& varOldValue, LPCTSTR strUserEntered, VARIANT* pvarNewValue, BOOL* pbCommit, BOOL* pbContinue)
{
	//TES 3/14/2011 - PLID 42784 - Converted to datalist2 (and added exception handling)
	try {
		//TES 3/15/2011 - PLID 42858 - If we're not committing, we don't need to do anything here
		if(*pbCommit == FALSE) {
			return;
		}

		BOOL bTableFlipped = (IsDlgButtonChecked(IDC_TABLE_ROWS_AS_FIELDS) == BST_CHECKED);
		CString strDataType = bTableFlipped ? "row" : "column";

		NXDATALIST2Lib::IRowSettingsPtr pRow(lpRow);
		switch (nCol) {
		case cdelcData:
			try {		

				CString strToCheck = strUserEntered;

				// (c.haag 2007-03-19 14:41) - PLID 24695 - If the string is empty, do not let the user save it
				// (c.haag 2007-09-26 15:42) - The decision to do this has been reversed now that the importer supports it and
				// by request from the EMR group
				/*if (strToCheck.IsEmpty()) {
					AfxMessageBox("You must assign a name to this column.", MB_OK | MB_ICONHAND);
					*pbCommit = FALSE;
					return;
				}*/

				strToCheck.TrimLeft();
				strToCheck.TrimRight();

				if(strToCheck.CompareNoCase(VarString(varOldValue,"")) != 0) {
					
					/**** (j.gruber 2013-09-30 10:48) - PLID 58676 - THE TABLE CELL CODES WORK ON THE FACT THAT NO ROWS/COLUMNS HAVE THE SAME NAME
					IF THIS EVER CHANGES IN THE FUTURE, YOU'LL NEED TO CHANGE THAT FUNCTIONALITY ALSO*/

					for(int i=0; i<m_aryCurColumnDataElements.GetSize(); i++) {
						if(strToCheck.CompareNoCase(m_aryCurColumnDataElements.GetAt(i)->m_strData) == 0) {
							CString strWarning;
							if(m_aryCurColumnDataElements.GetAt(i)->m_bInactive) {
								strWarning = "This table already has an inactive column with the name you entered.\n"
									"A table cannot have two columns with the same name. You may, however, reactivate the existing column.";
							}
							else {
								strWarning = "This table already has an column with the name you entered.\n"
									"A table cannot have two columns with the same name.";
							}
							AfxMessageBox(strWarning);

							*pbCommit = FALSE;
							return;
						}
					}
				}

				//TES 2/25/2010 - PLID 37234 - Make sure this isn't one of the hard-coded sentence fields.
				// (z.manning 2010-08-12 11:02) - PLID 39497 - I am leaving this warning in but am now making it a prompt.
				// The reason being we can't control pre-existing tables with these field names.
				// Also adding handling for the <Data> field and the group begin and end fields.
				if(IsDlgButtonChecked(IDC_RADIO_TABLE) == BST_CHECKED)
				{
					CString strAsField = "<" + strToCheck + ">";

					// (z.manning 2010-09-02 10:11) - PLID 40206 - We also need to check the field name
					BOOL bFieldNameUsed;
					if(bTableFlipped) {
						bFieldNameUsed = (strAsField == COLUMN_NAME_FIELD);
					}
					else {
						bFieldNameUsed = (strAsField == ROW_NAME_FIELD);
					}

					if(bFieldNameUsed || strAsField == AGE_FIELD || strAsField == GENDER_UPPER_FIELD || strAsField == GENDER_LOWER_FIELD ||
						strAsField == SUBJ_UPPER_FIELD || strAsField == SUBJ_LOWER_FIELD || strAsField == OBJ_UPPER_FIELD ||
						strAsField == OBJ_LOWER_FIELD || strAsField == POSS_UPPER_FIELD || strAsField == POSS_LOWER_FIELD ||
						strAsField == SPAWNING_FIELD || strAsField == DATA_FIELD || strAsField == GROUP_BEGIN_FIELD ||
						strAsField == GROUP_END_FIELD || strAsField == SPAWNED_ITEMS_FIELD)
					{
							int nResult = MessageBox("This table has the same name as one of the fields that can be used in the Sentence Format.\r\n"
								"It is recommend that fields whose names conflict with Sentence Format Fields be renamed.\r\n\r\n"
								"Would you like to cancel adding this field?", NULL, MB_YESNO|MB_ICONQUESTION);
							if(nResult == IDYES) {
								*pbCommit = FALSE;
								return;
							}
					}
				}

				//TES 3/15/2011 - PLID 42858 - Why would we touch this variable here?
				//*pbCommit = TRUE;
				return;
			}
			NxCatchAll("Error in OnEditingFinishingEmrColumnDataList");
			*pbCommit = FALSE;
			break;

		case cdelcType:
			try
			{
				// Get the old and the new strings
				long nOld = VarLong(varOldValue);
				long nNew = VarLong(*pvarNewValue);

				long nDataID = VarLong(pRow->GetValue(cdelcID),-1);

				long nIndex = GetCurDataElementArrayIndex(VarLong(pRow->GetValue(cdelcSortOrder)), TRUE);
				CEmrInfoDataElement* pElement = m_aryCurColumnDataElements.GetAt(nIndex);

				// (r.gonet 08/03/2012) - PLID 51735 - Validate that the column type is safe to use with the associated Wound Care Data Type
				if(IsDlgButtonChecked(IDC_USE_WITH_WOUND_CARE_CALC)) {
					EWoundCareDataType ewcc = (EWoundCareDataType)VarLong(pRow->GetValue(cdelcWoundCareDataType), (long)wcdtNone);
					switch(ewcc) {
					case wcdtNone:
						break;
					case wcdtWoundSurfaceArea:
						if(nNew != LIST_TYPE_TEXT) {
							MsgBox("Only a Text %s can be used as the '%s' field.", !IsDlgButtonChecked(IDC_TABLE_ROWS_AS_FIELDS) ? "column" : "row", GetWoundCareDataTypeDescription(ewcc));
							*pbCommit = FALSE;
							return;
						}
						break;
					case wcdtSkinDebridement:
					case wcdtSubQDebridement:
					case wcdtMuscleDebridement:
					case wcdtBoneDebridement:
					case wcdtNoDebridement:
						if(nNew != LIST_TYPE_CHECKBOX) {
							MsgBox("Only a Checkbox %s can be used as the '%s' field.", !IsDlgButtonChecked(IDC_TABLE_ROWS_AS_FIELDS) ? "column" : "row", GetWoundCareDataTypeDescription(ewcc));
							*pbCommit = FALSE;
							return;
						}
						break;
					default:
						break;
					}
				}

				// First see if the user changed anything
				if (nNew != nOld && m_nID != -1 && nDataID != -1)
				{
					//if it is used on an EMN, but not filled in, you may change it
					//if it is used on a template, and no defaults are selected, you may change it
					//otherwise, you cannot change it

					long nEMNUsed = 0;
					long nEMNFilled = 0;
					long nTemplateUsed = 0;
					long nTemplateFilled = 0;
					CString strDetailsUsed;
					CString strDetailsFilled;

					// (c.haag 2006-03-06 16:54) - PLID 19580 - If we have a current table detail;
					// that is, we right-clicked on a table detail and selected "edit", we need to see if
					// ANY DETAIL IN THE EMR WITH THE SAME EMRINFOID's data in the column we're changing.
					// If it does, we must prevent the user from changing it
					//
					if (m_bMaintainCurrentTable)
					{
						if (m_bIsCurrentDetailTemplate) nTemplateUsed++;
						else nEMNUsed++;

						// m_astrCurrentTableState is an array of strings that represent the state of each
						// detail that has our EmrInfoID. Each string is in the form "data_row,data_column,data_value,...".
						// If there is no data for a column element, data_value is empty. Lets scan all the strings for
						// any data where data_column = nDataID.
						//
						int nDetails = m_apCurrentTableDetails.GetSize();
						for (int iDetail=0; iDetail < nDetails; iDetail++) {
							CString str = VarString(m_apCurrentTableDetails[iDetail]->GetState(), "");
							CString strDetailID;
							strDetailID.Format("%d,", (m_bIsCurrentDetailTemplate) ? m_apCurrentTableDetails[iDetail]->m_nEMRTemplateDetailID : m_apCurrentTableDetails[iDetail]->m_nEMRDetailID);
							BOOL bColumnInUse = FALSE;

							// (c.haag 2007-08-25 11:36) - PLID 27112 - Use the table state iterator class
							CEmrTableStateIterator etsi(str);
							long X,Y,nEmrDetailImageStampID,nEmrDetailImageStampPointer,nStampID;
							CString strData;
							// (z.manning 2010-02-18 09:44) - PLID 37427 - Added EmrDetailImageStampID
							while(etsi.ReadNextElement(X,Y,strData,nEmrDetailImageStampID,nEmrDetailImageStampPointer,nStampID) && !bColumnInUse) {
								strData.TrimRight();
								if (nOld == LIST_TYPE_TEXT) {
									// If this was a textbox, only check for an empty string
									if(!strData.IsEmpty() &&
										Y == nDataID) {
										bColumnInUse = TRUE;
									}
								} else {
									if(!strData.IsEmpty() &&
										strData != "-1" && // Usually means user explicitly selected nothing
										strData != "0" && // Usually means user never selected anything
										Y == nDataID) {
										bColumnInUse = TRUE;
									}
								}
							}
							if (bColumnInUse) {
								strDetailsFilled += strDetailID;
							}
							strDetailsUsed += strDetailID;
						}
					}
					if (!strDetailsFilled.IsEmpty()) {
						if (m_bIsCurrentDetailTemplate) nTemplateFilled++;
						else nEMNFilled++;
					}
					strDetailsFilled.TrimRight(",");
					strDetailsUsed.TrimRight(",");
					if (strDetailsFilled.IsEmpty()) strDetailsFilled = "-1";
					if (strDetailsUsed.IsEmpty()) strDetailsUsed = "-1";

					CSqlFragment sqlDetailsUsed, sqlDetailsFilled, sqlTemplateDetailsUsed, sqlTemplateDetailsFilled;
					if(m_bIsCurrentDetailTemplate) {
						sqlTemplateDetailsUsed = CSqlFragment("AND EmrTemplateDetailsT.ID NOT IN ({INTSTRING})", strDetailsUsed);
						sqlTemplateDetailsFilled = CSqlFragment("AND EmrTemplateDetailsT.ID NOT IN ({INTSTRING})", strDetailsFilled);
					}
					else {
						sqlDetailsUsed = CSqlFragment("AND EMRDetailsT.ID NOT IN ({INTSTRING})", strDetailsUsed);
						sqlDetailsFilled = CSqlFragment("AND EMRDetailsT.ID NOT IN ({INTSTRING})", strDetailsFilled);
					}

					// (a.walling 2009-04-03 10:44) - PLID 33831 - blank data is no longer saved to the database
					// (z.manning 2011-05-02 12:59) - PLID 43524 - I changed these queries to check all versions of this
					// item (as opposed to just the current version as it used to be) for added safety and robustness.
					// I also paramaterized it.
					_RecordsetPtr prs = CreateParamRecordset(
						"SET NOCOUNT ON \r\n"
						"DECLARE @nEmrInfoMasterID int \r\n"
						"SET @nEmrInfoMasterID = {INT} \r\n"
						"DECLARE @nDataGroupID int \r\n"
						"SET @nDataGroupID = (SELECT EmrDataGroupID FROM EmrDataT WHERE ID = {INT}) \r\n"
						"SET NOCOUNT OFF \r\n"
						"\r\n"
						"SELECT \r\n"
						"	(SELECT COUNT(DISTINCT EMRID) FROM EMRDetailsT \r\n"
						"	 INNER JOIN EmrInfoT ON EmrDetailsT.EmrInfoID = EmrInfoT.ID \r\n"
						"	 WHERE Deleted = 0 AND EmrInfoT.EmrInfoMasterID = @nEmrInfoMasterID {SQL} \r\n"
						"	) AS EMNUsed, \r\n"
						"\r\n"
						"	(SELECT COUNT(DISTINCT TemplateID) FROM EmrTemplateDetailsT \r\n"
						"	 WHERE EmrTemplateDetailsT.EmrInfoMasterID = @nEmrInfoMasterID {SQL} \r\n"
						"	) AS TemplateUsed, \r\n"
						"\r\n"
						"	(SELECT COUNT(DISTINCT EMRID) FROM EMRDetailsT \r\n"
						"	 INNER JOIN EmrInfoT ON EmrDetailsT.EmrInfoID = EmrInfoT.ID \r\n"
						"	 WHERE Deleted = 0 AND EmrInfoT.EmrInfoMasterID = @nEmrInfoMasterID {SQL} AND EmrDetailsT.ID IN \r\n"
						"		(SELECT EMRDetailID FROM EMRDetailTableDataT \r\n"
						"		 INNER JOIN EMRDataT ON EMRDataT.ID = EMRDetailTableDataT.EMRDataID_Y \r\n"
						"		 WHERE EmrDataT.EmrDataGroupID = @nDataGroupID) \r\n"
						"	) AS EMNFilled, \r\n"
						"\r\n"
						"	(SELECT COUNT(DISTINCT TemplateID) FROM EMRTemplateDetailsT \r\n"
						"	 WHERE EmrTemplateDetailsT.EmrInfoMasterID = @nEmrInfoMasterID {SQL} AND EMRTemplateDetailsT.ID IN \r\n"
						"		(SELECT EMRTemplateDetailID FROM EMRTemplateTableDefaultsT \r\n"
						"		 LEFT JOIN EMRDataT ON EMRDataT.ID = EMRTemplateTableDefaultsT.EMRDataID_Y \r\n"
						"		 WHERE EmrDataT.EmrDataGroupID = @nDataGroupID AND EMRTemplateTableDefaultsT.EMRTemplateDetailID NOT IN \r\n"
						"			(SELECT ID FROM EMRTemplateDetailsT \r\n"
						"			 WHERE TemplateID IN (SELECT ID FROM EMRTemplateT WHERE Deleted = 1)) \r\n"
						"		) \r\n"
						"	) AS TemplateFilled \r\n"
						, m_nEmrInfoMasterID, nDataID, sqlDetailsUsed, sqlTemplateDetailsUsed, sqlDetailsFilled, sqlTemplateDetailsFilled);

					if (!prs->eof) {
						FieldsPtr pflds = prs->GetFields();
						nEMNUsed += AdoFldLong(pflds, "EMNUsed");
						nEMNFilled += AdoFldLong(pflds, "EMNFilled");
						nTemplateUsed += AdoFldLong(pflds, "TemplateUsed");
						nTemplateFilled += AdoFldLong(pflds, "TemplateFilled");
					} else {
						// This should be impossible
						ASSERT(FALSE);
						nEMNUsed = nEMNFilled = nTemplateUsed = nTemplateFilled = -1;
					}


					CString strWarning;

					if ((nEMNUsed != 0 || nTemplateUsed != 0) && nEMNFilled == 0 && nTemplateFilled == 0) {
						//it exists on an EMN or a Template
						strWarning.Format(
							"This table exists on %s EMNs and %s EMN Templates. However, no data has been entered for this column in any of these tables.\n"
							"If you change this column type, the type will be changed on all existing EMNs and EMN Templates.\n\n"
							"Are you SURE you wish to change this column type?",
							nEMNUsed == -1 ? "an unknown number of" : AsString(nEMNUsed), 
							nTemplateUsed == -1 ? "an unknown number of" : AsString(nTemplateUsed));

						if(IDYES == MessageBox(strWarning,"Practice",MB_YESNO|MB_ICONEXCLAMATION))
							//if they say yes, then return, as we don't need to do anything else
							return;
					}
					else if ((nEMNFilled != 0 || nTemplateFilled != 0) && ((nEMNUsed != 0 || nTemplateUsed != 0)))
					{
						if(nTemplateFilled == 0 && nOld == LIST_TYPE_DROPDOWN && nNew == LIST_TYPE_TEXT)
						{
							// (z.manning 2011-04-25 17:42) - PLID 37604 - We now allow users to change dropdown columns to text
							// as long as there is not data on a template detail for this table.
							int nResult = MessageBox(FormatString("This table is in use on patient EMNs. You can change the %s's "
								"type from dropdown to text, however, you will not be able to change it back.\r\n\r\n"
								"Are you sure you want to continue changing the %s type?", strDataType, strDataType), NULL, MB_YESNO|MB_ICONQUESTION);
							if(nResult != IDYES) {
								*pbCommit = FALSE;
							}
							// (z.manning 2011-04-26 10:27) - PLID 37604 - Either we're good or we're not but we're done either way
							// so return.
							return;
						}
						else
						{
							if (m_bMaintainCurrentTable)
							{
								if (m_bIsCurrentDetailTemplate) {
									strWarning.Format(
										"This table exists on %s EMNs and %s EMN Templates. In addition, data has been entered for this column on %s EMNs and %s EMN Templates.\n"
										"You cannot change this column type unless you first remove the table from these EMNs and/or EMN Templates.\n\n"
										"If there is no data assigned to this table in the open template, please go back and click on 'Save Changes', then try again.",
										nEMNUsed == -1 ? "an unknown number of" : AsString(nEMNUsed), 
										nTemplateUsed == -1 ? "an unknown number of" : AsString(nTemplateUsed),
										nEMNFilled == -1 ? "an unknown number of" : AsString(nEMNFilled), 
										nTemplateFilled == -1 ? "an unknown number of" : AsString(nTemplateFilled));
								}
								else {
									strWarning.Format(
										"This table exists on %s EMNs and %s EMN Templates. In addition, data has been entered for this column on %s EMNs and %s EMN Templates.\n"
										"You cannot change this column type unless you first remove the table from these EMNs and/or EMN Templates.\n\n"
										"If there is no data assigned to this table in the open EMR, please go back and click on 'Save Changes', then try again.",
										nEMNUsed == -1 ? "an unknown number of" : AsString(nEMNUsed), 
										nTemplateUsed == -1 ? "an unknown number of" : AsString(nTemplateUsed),
										nEMNFilled == -1 ? "an unknown number of" : AsString(nEMNFilled), 
										nTemplateFilled == -1 ? "an unknown number of" : AsString(nTemplateFilled));
								}
							}
							else {
								strWarning.Format(
									"This table exists on %s EMNs and %s EMN Templates. In addition, data has been entered for this column on %s EMNs and %s EMN Templates.\n"
									"You cannot change this column type unless you first remove the table from these EMNs and/or EMN Templates.",
									nEMNUsed == -1 ? "an unknown number of" : AsString(nEMNUsed), 
									nTemplateUsed == -1 ? "an unknown number of" : AsString(nTemplateUsed),
									nEMNFilled == -1 ? "an unknown number of" : AsString(nEMNFilled), 
									nTemplateFilled == -1 ? "an unknown number of" : AsString(nTemplateFilled));
							}

							AfxMessageBox(strWarning);
							//do NOT return - staying in this function will revert the selection
						}
					}
					else {
						//it doesn't cause a problem so, let's leave!
						return;
					}

					//if we're still here, we're not allowed to change the type
					*pbCommit = FALSE;
					return;
				}
				else {

					// (z.manning 2008-06-23 10:36) - PLID 16443 - If the column type was text and it had
					// a formula, let's make sure they want to clear out that formula.
					if(nOld == LIST_TYPE_TEXT && !pElement->m_strFormula.IsEmpty()) {
						if(IDYES != MessageBox("This column has a formula. Changing the column type will clear out the formula.\r\n\r\nAre you sure you want to change the column type?", NULL, MB_YESNO)) {
							*pbCommit = FALSE;
							return;
						}
						else {
							// (z.manning 2008-06-23 10:36) - OnEditingFinished will handle clearing the formula.
						}
					}

					//TES 3/18/2011 - PLID 42858 - Why would we touch this variable here?
					//*pbCommit = TRUE;
					return;
				}
				break;
			}
			NxCatchAll("Error in OnEditingFinishingEmrColumnDataList");
			*pbCommit = FALSE;
			break;

		case cdelcIsGrouped:

			// (c.haag 2007-01-29 16:08) - PLID 24423 - If the following is true, then this is
			// the Rx column of the internal Current Medications item. Do not allow the user to
			// group it
			if (IsSystemCurrentMedicationsItem() && pRow == m_pdlColumnDataElementList->GetFirstRow()) {
				MsgBox("You may not group the Rx column of the system Current Medications item");
				*pbCommit = FALSE;
			}

			// (c.haag 2007-04-05 11:58) - PLID 25468 - You may not group the Yes column of the
			// official Allergies item
			if (IsSystemAllergiesItem() && pRow == m_pdlColumnDataElementList->GetFirstRow()) {
				MsgBox("You may not group the Yes column of the system Allergies item");
				*pbCommit = FALSE;
			}

			break;

		// (z.manning 2010-04-20 11:14) - PLID 29301 - Table columns can now be labels so I added this case to
		// to the column edit finishing handler as well.
		case cdelcIsLabel:
			try {
				if(!VarBool(varOldValue)) {
					long nArrayIndex = GetCurDataElementArrayIndex(pRow->GetValue(cdelcSortOrder), TRUE);
					CEmrInfoDataElement *peide = m_aryCurColumnDataElements.GetAt(nArrayIndex);
					long nEmrDataID = VarLong(pRow->GetValue(cdelcID), -1);

					// (z.manning 2010-05-04 10:31) - PLID 29301 - No making columns labels if they are reference in a formula
					CString strReferencingColumn;
					if(IsDataElementReferencedInAnyFormula(peide, m_aryCurDataElements, m_aryCurColumnDataElements, strReferencingColumn)) {
						MessageBox(FormatString("This item is referenced in the formula for item '%s.'\r\n\r\n"
							"You may not make this item a label.", strReferencingColumn));
						*pbCommit = FALSE;
						return;
					}
					
					BOOL bInUseByCurrent = FALSE;
					BOOL bInUseByTopic = FALSE;
					CheckDataItemUse(nEmrDataID, TRUE, bInUseByCurrent, bInUseByTopic);
					if(bInUseByCurrent) {
						MsgBox("This item is selected on the item you are currently editing.  It cannot be made into a label.");
						*pbCommit = FALSE;
						return;
					}
					else if(bInUseByTopic) {
						if(IDYES != MsgBox("This item has been selected on the topic. Changing this item to a label will not revoke any actions associated with it. Do you want to continue?")) {
							*pbCommit = FALSE;
							return;
						}
					}
					
					// (z.manning 2010-04-19 15:08) - PLID 29301 - Moved the logic here to its own function
					if(CheckDataItemUseInDataForLabel(nEmrDataID)) {
						*pbCommit = FALSE;
						return;
					}

					// (z.manning 2010-05-04 11:09) - PLID 29301 - We need to clear out the formula if they are making this a label
					if(!peide->m_strFormula.IsEmpty()) {
						if(IDYES != MessageBox("If you this make this item a label it will delete its formula. Are you sure you want to make it a label?", NULL, MB_YESNO)) {
							*pbCommit = FALSE;
							return;
						}
						peide->m_strFormula.Empty();
					}					
					
				}
				//TES 3/15/2011 - PLID 42858 - Why would we touch this variable here?
				//*pbCommit = TRUE;
				return;
			}
			NxCatchAll("Error in OnEditingFinishingEmrColumnDataList:Label");
			*pbCommit  = FALSE;
			break;
		case cdelcWoundCareDataType:
			{
				// (r.gonet 08/03/2012) - PLID 51735 - Wound care calculation expects certain cell types
				EWoundCareDataType ewccNew = (EWoundCareDataType)VarLong(*pvarNewValue, (long)wcdtNone);
				switch(ewccNew) {
				case wcdtNone:
					break;
				case wcdtWoundSurfaceArea:
					if(VarLong(pRow->GetValue(cdelcType), LIST_TYPE_TEXT) != LIST_TYPE_TEXT) {
						MsgBox("Only a Text %s can be used as the '%s' field.", !IsDlgButtonChecked(IDC_TABLE_ROWS_AS_FIELDS) ? "column" : "row", GetWoundCareDataTypeDescription(ewccNew));
						*pbCommit = FALSE;
						return;
					}
					break;
				case wcdtSkinDebridement:
				case wcdtSubQDebridement:
				case wcdtMuscleDebridement:
				case wcdtBoneDebridement:
				case wcdtNoDebridement:
					if(VarLong(pRow->GetValue(cdelcType), LIST_TYPE_TEXT) != LIST_TYPE_CHECKBOX) {
						MsgBox("Only a Checkbox %s can be used as the '%s' field.", !IsDlgButtonChecked(IDC_TABLE_ROWS_AS_FIELDS) ? "column" : "row", GetWoundCareDataTypeDescription(ewccNew));
						*pbCommit = FALSE;
						return;
					}
					break;
				default:
					break;
				}
			}
			break;
		default:
			break;
		}
	}NxCatchAll(__FUNCTION__);
}

void CEmrItemEntryDlg::OnEditingFinishedEmrColumnList(LPDISPATCH lpRow, short nCol, const VARIANT& varOldValue, const VARIANT& varNewValue, BOOL bCommit)
{
	//TES 3/14/2011 - PLID 42784 - Converted to datalist2
	try {
		// This should really be impossible but we should probably check just in case
		NXDATALIST2Lib::IRowSettingsPtr pRow(lpRow);
		if (pRow == NULL) {
			ASSERT(FALSE);
			return;
		}

		switch (nCol) {
		
		// The data text itself
		case cdelcData:
			{
				// Get the data element we're working with
				long nSortOrder = VarLong(pRow->GetValue(cdelcSortOrder));
				long nArrayIndex = GetCurDataElementArrayIndex(nSortOrder, TRUE);
				CEmrInfoDataElement *peide = m_aryCurColumnDataElements.GetAt(nArrayIndex);

				// We're dealing with the delcData column, so see if this was a new entry (we'll use this later)
				BOOL bWasNewEntry;
				if (VarLong(pRow->GetValue(cdelcID)) == -2) {
					bWasNewEntry = TRUE;
				} else {
					bWasNewEntry = FALSE;
				}

				CString strToUse = AsString(varNewValue);
				strToUse.TrimLeft();
				strToUse.TrimRight();
				// (c.haag 2007-03-19 14:55) - PLID 24695 - We now allow users to make whitespace only names, but not empty names.
				// The reason we just don't take out the trimming outright is to prevent users from entering names like "200     "
				// (c.haag 2007-09-26 15:42) - The decision to do this has been reversed now that the importer supports it and
				// by request from the EMR group
				/*if (strToUse.IsEmpty()) {
					strToUse = AsString(varNewValue);
				}*/

				// See if the user committed or canceled
				if (bCommit && !(bWasNewEntry && strToUse == AsString(varOldValue))) {
					// The user committed a change to a data cell
					peide->m_strData = strToUse;

					// (j.gruber 2013-09-27 08:24) - PLID 57676 - update our map to the new value
					m_TableCellCodes.UpdateColumnName(AsString(varOldValue), strToUse);
					//we also have to update the savd map since we will be comparing them when we save
					m_SavedCellCodes.UpdateColumnName(AsString(varOldValue), strToUse);

					// And if it was a new entry we have to update the id, and possibly create another new entry
					if (bWasNewEntry) {
						// It is a new entry, and the user just committed it, so change its ID to be the official 
						// sentinel value that means it's set, rather than the one saying the user hasn't committed 
						// her decision to even create this item yet.
						pRow->PutValue(cdelcID, (long)-1);
						peide->m_nID = -1;

						// And see if we're in an add-multiple loop
						if (m_bAddingMultipleDataElements) {
							// Go again!
							// (j.jones 2009-08-13 15:53) - PLID 31730 - pass in the next sort order
							OnAddDataItem(TRUE, nSortOrder+1);
						}
					}
					else {
						// It wasn't a new entry, so we just do nothing because everything is taken care of by the 
						// user in combination with the datalist default behavior

						// (j.gruber 2014-08-04 14:48) - PLID 62632 - check for a keyword override
						if (VarString(varOldValue) != strToUse)
						{
							if (peide->m_bUseKeyword && !peide->m_strKeywordOverride.IsEmpty())
							{
								MsgBox(KEYWORD_OVERRIDE_WARNING);
							}
						}
					}
				} else {
					// User canceled
					if (bWasNewEntry) {
						// It was a new entry and the user canceled it, so delete it

						// (j.jones 2009-08-13 10:02) - PLID 31730 - update the sort orders of all subsequent elements in the cur list
						for (long i=0; i<m_aryCurColumnDataElements.GetSize(); i++) {
							if(m_aryCurColumnDataElements.GetAt(i)->m_nSortOrder > peide->m_nSortOrder)
								m_aryCurColumnDataElements.GetAt(i)->m_nSortOrder--;
						}

						NXDATALIST2Lib::IRowSettingsPtr pTmp = m_pdlColumnDataElementList->GetFirstRow();
						while(pTmp) {
							long nPriorSortOrder = VarLong(pTmp->GetValue(cdelcSortOrder));
							if (nPriorSortOrder > peide->m_nSortOrder) {
								pTmp->PutValue(cdelcSortOrder, (long)(nPriorSortOrder - 1));
							}
							pTmp = pTmp->GetNextRow();
						}
						
						// Remove the entry from the array
						delete peide;
						m_aryCurColumnDataElements.RemoveAt(nArrayIndex);

						// Remove the row from the datalist
						m_pdlColumnDataElementList->RemoveRow(pRow);

						// And if we were in an "add-multple" loop then get out of it (because the user canceled)
						m_bAddingMultipleDataElements = FALSE;
						
						// (j.jones 2009-08-13 15:48) - PLID 31730 - reset the sort order of the last multiply-added row
						m_nLastMultiplyAddedItemSortOrder = -1;

						// Reflect the correct state to the surrounding controls
						ReflectDataElementSelection();

						UpdateFormulaReferences();
					} else {
						// Wasn't a new entry so the cancel is already taken care of by the user in combination with 
						// the datalist default bahavior
					}
				}
				if(!m_bAddingMultipleDataElements) {
					ReflectDataElementList(sdeidPriorSelection);
				}
			}
			break;

		//they changed the type of the list
		case cdelcType:
			if(bCommit) {
				long nIndex = GetCurDataElementArrayIndex(VarLong(pRow->GetValue(cdelcSortOrder)), TRUE);
				CEmrInfoDataElement* pElement = m_aryCurColumnDataElements.GetAt(nIndex);
				long nNewValue = VarLong(varNewValue);
				pElement->m_nListType = nNewValue;
				ReflectDataElementSelection();

				// (z.manning, 05/30/2008) - PLID 16443 - If the old type was a text, we need to 
				// clear out the formula
				if(VarLong(varOldValue, -1) == LIST_TYPE_TEXT) {
					pElement->m_strFormula.Empty();
				}

				// (z.manning 2011-03-22 10:40) - PLID 23662 - If the new value is not a text type then
				// we need to make sure there's no autofill setting.
				if(nNewValue != LIST_TYPE_TEXT) {
					pElement->m_eAutofillType = etatNone;
				}

				// (j.gruber 2013-09-27 08:29) - PLID 58676 - if it was text or a checkbox, see if it has any codes, and if so, remove them
				if ((VarLong(varOldValue, -1) == LIST_TYPE_TEXT || VarLong(varOldValue, -1) == LIST_TYPE_CHECKBOX) && 
					(nNewValue != LIST_TYPE_TEXT || nNewValue != LIST_TYPE_CHECKBOX))
				{
					m_TableCellCodes.RemoveColumn(pElement->m_strData);
				}

				// (j.gruber 2014-07-22 14:04) - PLID 62621 - Keyword column for columns only are allowed for checkboxes
				//if the old value is checkbox and the new value isn't, clear the column
				// (j.gruber 2014-07-17 13:30) - PLID 62621 - actually we are showing the check for all except link, but we still need to clear the override if its not a checkbox
				if (VarLong(varOldValue, -1) == LIST_TYPE_LINKED && nNewValue != LIST_TYPE_LINKED)
				{
					pRow->PutValue(cdelcUseKeyword, pElement->m_bUseKeyword ? g_cvarTrue : g_cvarFalse);
				}

				//if the old type was not checkbox and not it is, show the column
				if (VarLong(varOldValue, -1) != LIST_TYPE_LINKED && nNewValue == LIST_TYPE_LINKED)
				{
					pElement->m_bUseKeyword = FALSE;
					pRow->PutValue(cdelcUseKeyword, g_cvarNull);														
				}

				if (nNewValue != LIST_TYPE_CHECKBOX)
				{
					//clear the override
					pElement->m_strKeywordOverride = "";

					// (j.gruber 2014-08-06 10:21) - PLID 63188 - if you check the keyword column for a drop down and none of the underlying list elements are already checked, check them all.  
					if (nNewValue == LIST_TYPE_DROPDOWN)
					{
						HandleKeywordDropDownContents(pElement, pElement->m_bUseKeyword);
					}
				}

				// (j.gruber 2014-07-30 13:20) - PLID 62630 - do we already have an override
				if (pElement->m_bUseKeyword  && !pElement->m_strKeywordOverride.IsEmpty())
				{
					pRow->PutCellBackColor(cdelcUseKeyword, HAS_KEYWORD_OVERRIDE_COLOR);
				}
				else
				{
					pRow->PutCellBackColor(cdelcUseKeyword, HAS_NO_KEYWORD_OVERRIDE_COLOR);
				}

				// (c.haag 2006-03-07 10:13) - PLID 19581 - Remember which column we changed the
				// type of so that we can clear it for all existing tables on all existing EMR's
				m_aryChangedCols.Add(pElement);

				//TES 3/14/2011 - PLID 42757 - Since the list type changed, clear out the GlassesOrder fields, then update the cell formats
				// so that the combos have the right fields.
				//TES 3/15/2011 - PLID 42757 - We also need to clear any GlassesOrder data in any associated dropdown.
				// (a.walling 2014-06-30 10:21) - PLID 62497
				for(auto& pddi : pElement->m_arypEMRDropDownList) {
					pddi->nGlassesOrderDataID = -1;
					pddi->strGlassesOrderDataName = "";
				}
				pElement->m_GlassesOrderDataType = godtInvalid;
				pRow->PutValue(cdelcGlassesOrderDataType,g_cvarNull);
				pElement->m_nGlassesOrderDataID = -1;
				pRow->PutValue(cdelcGlassesOrderDataID,g_cvarNull);
				// (r.gonet 08/03/2012) - PLID 51735
				pElement->m_ewccWoundCareDataType = wcdtNone;
				pRow->PutValue(cdelcWoundCareDataType,g_cvarNull);

				ReflectColumnType(pRow);
				ReflectGlassesOrderDataType(pRow, TRUE);
			}
			break;

		// (j.gruber 2014-07-17 13:39) - PLID 62621 - When editing multi & single select lists, table row sand columns,  add a new checkbox column labeled Keyword to the right of the action column - Loading
		case cdelcUseKeyword:
			if (bCommit) {
				BOOL bOld = AsBool(varOldValue);
				BOOL bNew = AsBool(varNewValue);
				if (bOld != bNew) {
					long nIndex = GetCurDataElementArrayIndex(VarLong(pRow->GetValue(cdelcSortOrder)), TRUE);
					m_aryCurColumnDataElements.GetAt(nIndex)->m_bUseKeyword = bNew;

					// (j.gruber 2014-07-30 13:20) - PLID 62630 - do we already have an override
					if (m_aryCurColumnDataElements.GetAt(nIndex)->m_bUseKeyword  && !m_aryCurColumnDataElements.GetAt(nIndex)->m_strKeywordOverride.IsEmpty())
					{											   
						pRow->PutCellBackColor(cdelcUseKeyword, HAS_KEYWORD_OVERRIDE_COLOR);
					}
					else
					{
						pRow->PutCellBackColor(cdelcUseKeyword, HAS_NO_KEYWORD_OVERRIDE_COLOR);
					}

					// (j.gruber 2014-08-06 10:21) - PLID 63188 - if you check the keyword column for a drop down and none of the underlying list elements are already checked, check them all.  
					HandleKeywordDropDownContents(m_aryCurColumnDataElements.GetAt(nIndex), bNew);
				}
			}
			break;


		//the "Grouped" checkbox
		case cdelcIsGrouped:
			if(bCommit) {
				long nIndex = GetCurDataElementArrayIndex(VarLong(pRow->GetValue(cdelcSortOrder)), TRUE);
				CEmrInfoDataElement* pElement = m_aryCurColumnDataElements.GetAt(nIndex);
				pElement->m_bIsGrouped = VarBool(varNewValue);
				ReflectDataElementSelection();

				// (c.haag 2006-03-07 10:13) - PLID 19581 - Remember which column we changed the
				// type of so that we can clear it for all existing tables on all existing EMR's
				m_aryChangedCols.Add(pElement);
			}
			break;

		// The 'inactive' checkbox
		case cdelcInactive:
			if (bCommit) {
				BOOL bOld = AsBool(varOldValue);
				BOOL bNew = AsBool(varNewValue);
				if (bOld && !bNew) {
					// Switched from inactive to NOT active
					m_pdlCurrentDataElementList = m_pdlColumnDataElementList;
					DoActivateColumnDataElement(pRow);					
				} else if (!bOld && bNew) {
					// Switched from NOT inactive to inactive
					m_pdlCurrentDataElementList = m_pdlColumnDataElementList;
					DoInactivateColumnDataElement(pRow);				
				} else {
					// Didn't switch so do nothing
				}
			}
			break;

		// (j.jones 2007-08-15 11:50) - PLID 27053 - added UseEMCoding
		case cdelcUseEMCoding:
			if (bCommit) {
				BOOL bOld = AsBool(varOldValue);
				BOOL bNew = AsBool(varNewValue);
				if (bOld != bNew) {
					long nIndex = GetCurDataElementArrayIndex(VarLong(pRow->GetValue(cdelcSortOrder)), TRUE);
					m_aryCurColumnDataElements.GetAt(nIndex)->m_bUseEMCoding = bNew;
				}
			}
			break;

		// (j.jones 2011-03-08 12:25) - PLID 42282 - added EMCodeCategoryID
		case cdelcEMCodeCategoryID:
			if (bCommit) {
				long nOld = VarLong(varOldValue);
				long nNew = VarLong(varNewValue);
				if (nOld != nNew) {
					long nIndex = GetCurDataElementArrayIndex(VarLong(pRow->GetValue(cdelcSortOrder)), TRUE);
					m_aryCurColumnDataElements.GetAt(nIndex)->m_nEMCodeCategoryID = nNew;
				}
			}
			break;

		// (z.manning 2010-04-13 11:18) - PLID 29301 - Columns can now be marked labels
		case cdelcIsLabel:
			if (bCommit) {
				BOOL bOld = AsBool(varOldValue);
				BOOL bNew = AsBool(varNewValue);
				long nArrayIndex = GetCurDataElementArrayIndex(pRow->GetValue(cdelcSortOrder), TRUE);
				CEmrInfoDataElement *peide = m_aryCurColumnDataElements.GetAt(nArrayIndex);

				peide->m_bIsLabel = bNew;

				// (z.manning 2010-05-03 16:41) - PLID 29301 - Force the data type to text on label columns
				pRow->PutValue(cdelcType, (long)LIST_TYPE_TEXT);
				peide->m_nListType = LIST_TYPE_TEXT;

				//TES 3/16/2011 - PLID 42757 - Clear out the Glasses Order columns for Labels.
				if (bNew) {
					pRow->PutValue(cdelcGlassesOrderDataType, g_cvarNull);
					pRow->PutCellBackColor(cdelcGlassesOrderDataType, DISABLED_COLOR);
					pRow->PutCellBackColorSel(cdelcGlassesOrderDataType, DISABLED_COLOR_SEL);
					peide->m_GlassesOrderDataType = godtInvalid;
					pRow->PutValue(cdelcGlassesOrderDataID, g_cvarNull);
					pRow->PutCellBackColor(cdelcGlassesOrderDataID, DISABLED_COLOR);
					pRow->PutCellBackColorSel(cdelcGlassesOrderDataID, DISABLED_COLOR_SEL);
					peide->m_nGlassesOrderDataID = -1;
					// (r.gonet 08/03/2012) - PLID 51735
					peide->m_ewccWoundCareDataType = wcdtNone;
					pRow->PutValue(cdelcWoundCareDataType, g_cvarNull);
					pRow->PutCellBackColor(cdelcWoundCareDataType, DISABLED_COLOR);
					pRow->PutCellBackColorSel(cdelcWoundCareDataType, DISABLED_COLOR_SEL);
					// (j.gruber 2014-07-24 16:09) - PLID 62627 - clear out keyword checkbox
					peide->m_bUseKeyword = FALSE;
					pRow->PutValue(cdelcUseKeyword, g_cvarNull);
					//take off any coloring
					pRow->PutCellBackColor(cdelcUseKeyword, HAS_NO_KEYWORD_OVERRIDE_COLOR);
				}
				else{
					// (j.gruber 2014-07-24 16:09) - PLID 62621 - set the keyword back					
					pRow->PutValue(cdelcUseKeyword, peide->m_bUseKeyword ? g_cvarTrue : g_cvarFalse);
					//don't need to worry about coloring here, because this is always going to be false, since we clear it when we marked it as a label
				}
			

				ReflectColumnType(pRow);

				ReflectDataElementSelection();

				m_aryChangedCols.Add(peide);
			}
			break;

		//TES 3/11/2011 - PLID 42757 - Added Glasses Order data
		case cdelcGlassesOrderDataType:
			if(bCommit) {
				long nOld = VarLong(varOldValue,(long)godtInvalid);
				long nNew = VarLong(varNewValue,(long)godtInvalid);
				if(nOld != nNew) {
					long nArrayIndex = GetCurDataElementArrayIndex(pRow->GetValue(cdelcSortOrder), TRUE);
					CEmrInfoDataElement *pElement = m_aryCurColumnDataElements.GetAt(nArrayIndex);
					pElement->m_GlassesOrderDataType = (GlassesOrderDataType)nNew;
					//TES 3/14/2011 - PLID 42757 - Since the DataType has changed, clear out the DataID, and update the cell format so that
					// the combo has the correct fields.
					//TES 3/15/2011 - PLID 42757 - We also need to clear any GlassesOrder data in any associated dropdown.
					// (a.walling 2014-06-30 10:21) - PLID 62497
					for (auto& pddi : pElement->m_arypEMRDropDownList) {
						pddi->nGlassesOrderDataID = -1;
						pddi->strGlassesOrderDataName = "";
					}
					pRow->PutValue(cdelcGlassesOrderDataID, g_cvarNull);
					m_aryCurColumnDataElements.GetAt(nArrayIndex)->m_nGlassesOrderDataID = -1;
					ReflectGlassesOrderDataType(pRow, TRUE);
				}
			}
			break;
		case cdelcGlassesOrderDataID:
			if(bCommit) {
				long nOld = VarLong(varOldValue,-1);
				long nNew = VarLong(varNewValue,-1);
				if(nOld != nNew) {
					long nArrayIndex = GetCurDataElementArrayIndex(pRow->GetValue(cdelcSortOrder), TRUE);
					m_aryCurColumnDataElements.GetAt(nArrayIndex)->m_nGlassesOrderDataID = nNew;
				}
			}
			break;
		// (r.gonet 08/03/2012) - PLID 51735 - Added WoundCareDataType
		case cdelcWoundCareDataType:
			if(bCommit) {
				long nOld = VarLong(varOldValue,(long)wcdtNone);
				long nNew = VarLong(varNewValue,(long)wcdtNone);
				if(nOld != nNew) {
					long nArrayIndex = GetCurDataElementArrayIndex(pRow->GetValue(cdelcSortOrder), TRUE);
					CEmrInfoDataElement *pElement = m_aryCurColumnDataElements.GetAt(nArrayIndex);
					pElement->m_ewccWoundCareDataType = (EWoundCareDataType)nNew;
				}
			}
			break;
		}
	} NxCatchAll("CEmrItemEntryDlg::OnEditingFinishedEmrColumnDataList");
}

// (c.haag 2011-03-14) - PLID 42814 - This event is fired when the user clicks on the button to configure the
// Common List buttons
void CEmrItemEntryDlg::OnEditCommonLists()
{
	try {
		CEmrCommonListSetupDlg dlg(m_CommonListCollection, &m_aryCurDataElements, this);
		if (IDOK == dlg.DoModal())
		{
			m_CommonListCollection = dlg.GetResult();

			// (c.haag 2011-03-30) - PLID 43047 - Save and close if this was our only intention.
			if (eEmrItemEntryDlgBehavior_EditCommonLists == m_Behavior)
			{
				OnOK();
				EndDialog(IDOK);
			}
		}
		else
		{
			// (c.haag 2011-03-30) - PLID 43047 - Cancel out of this dialog since nothing has changed.
			if (eEmrItemEntryDlgBehavior_EditCommonLists == m_Behavior)
			{
				EndDialog(IDCANCEL);
			}
		}
	}
	NxCatchAll(__FUNCTION__);
}

// (z.manning 2011-03-18 14:57) - PLID 23662
void CEmrItemEntryDlg::OnBtnEditTableAutofill()
{
	try
	{
		EditTableAutofillSettings();
	}
	NxCatchAll(__FUNCTION__);
}

// (z.manning 2011-03-18 15:07) - PLID 23622
void CEmrItemEntryDlg::EditTableAutofillSettings()
{
	NXDATALIST2Lib::IRowSettingsPtr pRow = m_pdlColumnDataElementList->GetCurSel();
	if(pRow == NULL) {
		return;
	}

	CEmrInfoDataElement *peide = GetCurDataElementBySortOrder(VarLong(pRow->GetValue(cdelcSortOrder)), TRUE);

	if(IsSmartStampListSubType(peide->m_nListSubType)) {
		MessageBox("You may not set smart stamp items to auto-fill.", NULL, MB_OK|MB_ICONINFORMATION);
		return;
	}

	// (j.jones 2011-05-03 16:13) - PLID 43527 - disallow this for built-in Current Meds columns
	if(IsCurrentMedicationListSubType(peide->m_nListSubType)) {
		MessageBox("You may not set built-in Current Medication items to auto-fill.", NULL, MB_OK|MB_ICONINFORMATION);
		return;
	}

	CEmrTableAutofillSettingsDlg dlg(peide, this);
	dlg.DoModal();
}

long CEmrItemEntryDlg::GetCalledFromDetailID()
{
	if(m_pCalledFromDetail == NULL) {
		return -1;
	}
	else {
		return m_pCalledFromDetail->m_nEMRDetailID;
	}
}

void CEmrItemEntryDlg::OnTimer(UINT nIDEvent)
{
	try {
		switch(nIDEvent) {
			//TES 6/25/2011 - PLID 38230 - If this is our timer for when the data type changes, call that handler.
			case IDT_HANDLE_DATA_TYPE_SELECTION:
				KillTimer(IDT_HANDLE_DATA_TYPE_SELECTION);
				HandleDataTypeSelection();
				break;
		}
	}NxCatchAll(__FUNCTION__);
}

void CEmrItemEntryDlg::HandleDataTypeSelection()
{
	//TES 6/25/2011 - PLID 38230 - Moved all the code here from OnDataTypeSelected
	// (a.walling 2008-01-18 13:21) - PLID 14982 - Ensure they can't change the type
	ASSERT(!m_bPreventTypeChange);
	if (m_bPreventTypeChange) return;

	//TES 6/27/2012 - PLID 51241 - Check whether the user just clicked on the radio button that was already selected, in which case
	// we don't need to do anything.
	// (c.haag 2006-03-01 16:50) - We now have a single function for this
	long nNewSelect = CalcDataTypeByCurSelection();
	if(m_nCurrentlySelectedDataType == nNewSelect) {
		return;
	}

	// (a.wilson 2012-07-16 16:26) - PLID 49704 - variable pushed outside of if statement to prevent excess code generation.
	BOOL bRevert = FALSE;

	if(m_nID != -1 && m_bIsEditingOnEMN) {
		// (j.jones 2006-09-11 11:14) - PLID 22381 - We only need to warn if they are editing
		// an item on the fly from a patient's EMN (not templates) because only then is there
		// a possibility that changing the data type may cause entered clinical data to be lost.

		if(nNewSelect == 3 && m_nDataType == 2) {
			//if they are changing from a single-select list to a multi-select list,
			//there is no problem here
		}
		else if(nNewSelect == 2 && m_nDataType == 3) {
			//if they are changing from a multi-select list to a single-select list,
			//warn that they will lose some selections
			if(IDNO == MessageBox("If you have multiple selections on your currently edited item, changing to a single-select list will cause multiple selections to be lost.\n"
							"Are you sure you wish to do this?","Practice",MB_YESNO|MB_ICONEXCLAMATION)) {
				bRevert = TRUE;
			}
		}
		else if(nNewSelect != m_nDataType) {
			//otherwise give a threatening warning
			if(IDNO == MessageBox("Changing the data type will cause your currently edited detail to lose its data.\n"
								  "Are you sure you wish to do this?","Practice",MB_YESNO|MB_ICONEXCLAMATION)) {
				bRevert = TRUE;
			}
		}			

		if(bRevert) {
			//revert to the saved type
			RevertToSavedDataType();				
		}
	}

	// (j.gruber 2009-11-18 16:00) - PLID 35945 - check if this item has a tops code and if so, if we can change the type
	NXDATALIST2Lib::IRowSettingsPtr pRow;
	pRow = m_dlEmrDataCode->CurSel;
	if (pRow && bRevert == FALSE) {

		CString strCode = VarString(pRow->GetValue(lcCode), "");
		// (j.gruber 2009-12-23 09:57) - PLID 35771 - added check for report
		// (j.gruber 2010-01-18 10:06) - PLID 36929 - removed report and thus report codes
		if (IsTOPSCode(strCode) /*|| IsReportCode(strCode)*/) {
			// (j.gruber 2009-12-23 09:53) - PLID 35771 - check for report codes also
			if (!CheckTOPSCodeAgainstType(strCode, "Your selection will be reverted.")) {
				//this already gives a message, but we need to revert the selection
				RevertToSavedDataType();
				bRevert = TRUE;
			}
		}

		// (j.gruber 2010-04-28 12:17) - PLID 38377 - BOLD Code
		if (IsBOLDCode(strCode) ) {				
			if (!CheckBOLDCodeAgainstType(strCode, "Your selection will be reverted.")) {
				//this already gives a message, but we need to revert the selection
				RevertToSavedDataType();
				bRevert = TRUE;
			}
		}
	}

	// (a.wilson 2012-07-16 10:53) - PLID 49704 - warn the user if the current item is attached to graphing
	// that if they change the items type then the past typed items will not be graphed.
	if (bRevert == FALSE) {
		CString strAssignedTo = IsItemIDAssignedInGraphing(m_nEmrInfoMasterID);
		if (!strAssignedTo.IsEmpty()) {
			if (IDNO == MsgBox(MB_YESNO, "The current item is assigned in graphing under the following graphs:\r\n\r\n%s\r\n"
				"If you change the data type of this item then past versions cannot be graphed. "
				"Instead you could make a new item with the new data type you have selected "
				"and assign it to the same line as long as the new data type is supported.\r\n\r\n"
				"Are you sure you want to continue with changing this item's data type?", strAssignedTo)) {
				//if they decide not to change then revert to original data type.
				RevertToSavedDataType();
				bRevert = TRUE;
			}
		}
	}

	// (j.gruber 2013-09-27 14:00) - PLID 58676 - check if they have any codes 
	//it they changed from a table to not a table, tell them the codes will be deleted
	if (bRevert == FALSE &&
		m_nDataType == 7 && nNewSelect != 3 )
	{
		if (m_TableCellCodes.size() > 0) {
			if (IDYES == MsgBox(MB_YESNO, "This table has codes associated with at least one cell.  If you change the type, these codes will be removed.  Are you sure you want to continue?"))
			{
				//they want to switch, remove the codes
				m_TableCellCodes.Clear();
			}
			else {
				RevertToSavedDataType();
				bRevert = TRUE;
			}
		}

	}



	ReflectDataType();
	ReflectDataElementList(sdeidClearSelection);
}

// (z.manning 2011-07-21 17:42) - PLID 44676
void CEmrItemEntryDlg::OnBnClickedUseSelected3dimage()
{
	try
	{
		CEMRHotSpotArray aryCurrentHotSpots;
		GetCurrentHotSpots(&aryCurrentHotSpots);
		if(!aryCurrentHotSpots.Is3DHotSpotArray()) {
			if(!CheckForAndPromptToClearHotSpots()) {
				Reset3DImageRadioIfNecessary();
				return;
			}
		}

		OnImageTypeSelected();

		BOOL bIsImageDataType = IsDlgButtonChecked(IDC_RADIO_IMAGE) == BST_CHECKED ? TRUE : FALSE;
		if (bIsImageDataType)
		{
			// (z.manning 2011-07-22 11:36) - PLID 44676 - Prompt for the 3D image obj file to use
			// (j.kuziel 2011-09-01 17:42) - PLID 44514 - Read only (faster) .nx3 files now.
			CFileDialog dlgFile(TRUE, "nx3", NULL, OFN_FILEMUSTEXIST|OFN_ENABLESIZING, "3D Images|*.nx3||", this);
			CString strImagePath = GetSharedPath() ^ "Images";
			dlgFile.m_ofn.lpstrInitialDir = strImagePath;
			if(dlgFile.DoModal() == IDOK)
			{
				CString str3DImageFilePath = dlgFile.GetPathName();
				CString strPathOnly = FileUtils::GetFilePath(str3DImageFilePath);
				strPathOnly.TrimRight('\\');
				CString strFile = dlgFile.GetFileName();
				if(strPathOnly.CompareNoCase(strImagePath) != 0)
				{
					// (z.manning 2011-07-22 11:39) - PLID 44676 - We only allow them to use images in the shared images
					// folder so if they chose another one copy it there first. If they chose a file with the same name as a
					// file that already exists in the shared images folder we do NOT allow them to overwite it for safety reasons
					// in case another EMR item is already using that image.
					if(FileUtils::DoesFileOrDirExist(strImagePath ^ strFile)) {
						MessageBox("You already have a 3D image with the same file name.", NULL, MB_OK|MB_ICONERROR);
						Reset3DImageRadioIfNecessary();
						return;
					}
					if(!CopyFile(str3DImageFilePath, strImagePath ^ strFile, TRUE)) {
						MessageBox("Failed to copy 3D image file to " + strImagePath, NULL, MB_OK|MB_ICONERROR);
						Reset3DImageRadioIfNecessary();
						return;
					}

					str3DImageFilePath = strImagePath ^ strFile;
				}

				// (z.manning 2011-09-27 15:54) - PLID 44676 - Clear out the 2D image if we had one.
				if (NULL != m_btnEmrImage.m_image) {
					DeleteObject(m_btnEmrImage.m_image);
				}
				m_btnEmrImage.m_image = NULL;

				CString strNewFileName = FileUtils::GetFileName(str3DImageFilePath);
				m_strCurImagePath = strNewFileName;
				if(!LoadCurrent3DImage()) {
					m_strCurImagePath.Empty();
					Reset3DImageRadioIfNecessary();
					return;
				}

				//1)  Anything in new has to go.  Since they're 'new', we can just drop them altogether, noone else needs to know.
				m_aryNewHotSpots.Clear();
				//2)  We want to throw away anything that has changed.  These are in the last saved, so we don't care what the changes are, and
				//	we do not need to deallocate the memory.
				m_aryChangedHotSpots.RemoveAll();
				//3)  Lastly, we need to dump everything that was previously saved.  In order for them to be deleted properly, they need to be moved
				//	to the removed array.  But we need to not re-add ones that are already marked deleted, if the user might have 
				//	done that themselves already.
				for(int nExistingHotSpotIndex = 0; nExistingHotSpotIndex < m_aryLastSavedHotSpots.GetCount(); nExistingHotSpotIndex++) {
					CEMRHotSpot *pHotSpot = m_aryLastSavedHotSpots.GetAt(nExistingHotSpotIndex);
					if(!m_aryRemovedHotSpots.Contains(pHotSpot)) {
						m_aryRemovedHotSpots.Add(pHotSpot);
					}
				}

				// (z.manning 2011-07-22 17:33) - PLID 44676 - Now add the new hot spots
                // (j.kuziel 2012-12-14 09:44) - PLID 54185 - Optimized to only call GetHotSpotIDCount once.
                unsigned long nHotSpotIDCount = m_p3DImage->GetHotSpotIDCount();
				for(unsigned long nNewHotSpotIndex = 0; nNewHotSpotIndex < nHotSpotIDCount; nNewHotSpotIndex++)
				{
					short n3DHotSpotID = m_p3DImage->GetHotSpotIDByIndex(nNewHotSpotIndex);
					if(n3DHotSpotID != -1)
					{
						// (z.manning 2011-10-19 16:38) - PLID 44676 - Safety check to make sure we don't have multiple
						// hot spots with the same ID value since this is how we identify 3D hot spots.
						if(m_aryNewHotSpots.FindBy3DHotSpotID(n3DHotSpotID) != NULL) {
							ThrowNxException("Found duplicate 3D hot spot ID (%li) in newly selected 3D model", n3DHotSpotID);
						}
						CEMRHotSpot *pNewHotSpot = new CEMRHotSpot();
						pNewHotSpot->Set3DHotSpotID(n3DHotSpotID);
						m_aryNewHotSpots.Add(pNewHotSpot);
					}
				}
			}
			else {
				m_strCurImagePath.Empty();
				Reset3DImageRadioIfNecessary();
			}
		}
	}
	NxCatchAllCall(__FUNCTION__, 
		m_strCurImagePath.Empty();
		Reset3DImageRadioIfNecessary();
		);
}

// (z.manning 2011-09-27 15:52) - PLID 44676
void CEmrItemEntryDlg::Reset3DImageRadioIfNecessary()
{
	if(FileUtils::GetFileExtension(m_strCurImagePath).CompareNoCase("nx3") != 0) {
		CheckDlgButton(IDC_USE_SELECTED_3DIMAGE, BST_UNCHECKED);
		CheckDlgButton(IDC_PROMPT_FOR_IMAGE, BST_CHECKED);
		OnImageTypeSelected();
	}
}

// (z.manning 2011-07-22 10:04) - PLID 44676
BOOL CEmrItemEntryDlg::LoadCurrent3DImage()
{
	try
	{
		if(m_strCurImagePath.IsEmpty()) {
			m_p3DImage->PutModelFileName("");
		}
		else {
			m_p3DImage->PutModelFileName(_bstr_t(GetSharedPath() ^ "Images" ^ m_strCurImagePath));
		}

		return TRUE;
	}
	NxCatchAll(__FUNCTION__);
	return FALSE;
}

//TES 3/9/2012 - PLID 48779 - Moved the HotspotRightClicked handling into OnContextMenu

// (z.manning 2011-07-25 10:28) - PLID 44676
void CEmrItemEntryDlg::OpenAnatomicLocationEditorForHotSpot(CEMRHotSpot *pHotSpot)
{
	CEmrHotspotLocationDlg dlg(this);
	dlg.SetSpot(pHotSpot);
	if(dlg.DoModal() == IDOK)
	{
		if(pHotSpot->GetID() != -1) {
			if(!m_aryChangedHotSpots.Contains(pHotSpot)) {
				m_aryChangedHotSpots.Add(pHotSpot);
			}
		}
		else {
			// (z.manning 2011-07-25 10:03) - PLID 44676 - This is a new hot spot and thus is already in the array
			// tracking new hot spots.
		}
	}
}

// (z.manning 2011-07-25 09:54) - PLID 44676
void CEmrItemEntryDlg::GetCurrentHotSpots(CEMRHotSpotArray *parypCurrentHotSpots)
{
	// (z.manning 2011-07-25 09:55) - PLID 44676 - First get all the newly added hot spots.
	parypCurrentHotSpots->Append(m_aryNewHotSpots);

	// (z.manning 2011-07-25 09:55) - PLID 44676 - Also get any previously saved hot spots (assuming they haven't been deleted)
	for(int nLastSavedHotSpotIndex = 0; nLastSavedHotSpotIndex < m_aryLastSavedHotSpots.GetCount(); nLastSavedHotSpotIndex++)
	{
		CEMRHotSpot *pLastSavedHotSpot = m_aryLastSavedHotSpots.GetAt(nLastSavedHotSpotIndex);
		if(!m_aryRemovedHotSpots.Contains(pLastSavedHotSpot)) {
			parypCurrentHotSpots->Add(pLastSavedHotSpot);
		}
	}
}

// (z.manning 2011-07-25 10:36) - PLID 44676
CEMRHotSpot* CEmrItemEntryDlg::GetHotSpotFrom3DHotSpotID(const short n3DHotSpotID)
{
	CEMRHotSpotArray arypCurrentHotSpots;
	GetCurrentHotSpots(&arypCurrentHotSpots);
	CEMRHotSpot *pHotSpot = arypCurrentHotSpots.FindBy3DHotSpotID(n3DHotSpotID);
	return pHotSpot;
}

// (z.manning 2011-10-24 11:27) - PLID 46082
void CEmrItemEntryDlg::OnBnClickedEmrItemSelectStamps()
{
	try
	{
		CEmrItemSelectStampsDlg dlg(&m_StampExclusions, this);
		dlg.DoModal();
	}
	NxCatchAll(__FUNCTION__);
}

// (z.manning 2011-11-17 17:10) - PLID 46485
void CEmrItemEntryDlg::UpdateDontSpawnRememberedValuesCheck()
{
	if(IsDlgButtonChecked(IDC_REMEMBER_FOR_PATIENT) == BST_CHECKED || IsDlgButtonChecked(IDC_REMEMBER_FOR_EMR) == BST_CHECKED) {
		GetDlgItem(IDC_DONT_SPAWN_WHEN_REMEMBERING)->EnableWindow(TRUE);
	}
	else {
		GetDlgItem(IDC_DONT_SPAWN_WHEN_REMEMBERING)->EnableWindow(FALSE);
	}
}

void CEmrItemEntryDlg::OnAssociateWithGlassesOrderOrCL()
{
	try {
		//TES 4/6/2012 - PLID 49367 - New checkbox for tables, which can have either Glasses Order or Contact Lens data
		ReflectGlassesOrderCheck();
	}NxCatchAll(__FUNCTION__);
}

BOOL CEmrItemEntryDlg::OnSetCursor(CWnd* pWnd, UINT nHitTest, UINT message) 
{
	try {
		//TES 4/6/2012 - PLID 49367 - Show the hand over our label, if it's enabled.
		CPoint pt;
		GetCursorPos(&pt);
		ScreenToClient(&pt);

		CRect rc;

		// (a.walling 2010-01-18 11:22) - PLID 36936		
		m_nxlGOCLToggle.GetWindowRect(rc);
		ScreenToClient(&rc);

		if (rc.PtInRect(pt) && m_nxlGOCLToggle.GetType() == dtsHyperlink) {
			SetCursor(GetLinkCursor());
			return TRUE;
		}

	}NxCatchAllIgnore();
		
	return CNxDialog::OnSetCursor(pWnd, nHitTest, message);
}

LRESULT CEmrItemEntryDlg::OnLabelClick(WPARAM wParam, LPARAM lParam)
{
	try {
		UINT nIdc = (UINT)wParam;
		switch(nIdc) {
			//TES 4/6/2012 - PLID 49367 - Toggle between Glasses Order Data and Contact Lens DAta
			case IDC_GO_CL_TOGGLE:
				if(m_bHasContactLensData) {
					m_bHasContactLensData = FALSE;
					m_nxlGOCLToggle.SetText("Glasses Order Data");
				}
				else {
					m_bHasContactLensData = TRUE;
					m_nxlGOCLToggle.SetText("Contact Lens Data");
				}
				//TES 4/6/2012 - PLID 49367 - Update the datalist
				ReflectDataElementList(sdeidPriorSelection);
				break;
		default:
			//What?  Some strange NxLabel is posting messages to us?
			ASSERT(FALSE);
			break;
		}
	} NxCatchAll(__FUNCTION__);
	return 0;
}

// (r.gonet 08/03/2012) - PLID 51735
void CEmrItemEntryDlg::OnUseWithWoundCareCoding()
{
	try {
		ReflectUseWithWoundCareCodingCheck();
	} NxCatchAll(__FUNCTION__);
}

// (a.wilson 2012-06-29 18:01) - PLID 51306 - find out if the current row or column is contained within the graphing setup. if so warn them.
CString CEmrItemEntryDlg::IsDataIDAssignedInGraphing(long nDataID)
{
	_RecordsetPtr prs = CreateParamRecordset(
		"SELECT EMRGraphsT.Name AS GraphName, EMRGraphLinesT.Name AS LineName, EMRInfoT.Name AS ItemName "
		"FROM EMRGraphLineDetailsT "
		"INNER JOIN EMRGraphLinesT ON EMRGraphLinesT.ID = EMRGraphLineDetailsT.LineID "
		"INNER JOIN EMRGraphsT ON EMRGraphsT.ID = EMRGraphLinesT.GraphID "
		"INNER JOIN EMRDataT ON EMRGraphLineDetailsT.RowID = EMRDataT.EMRDataGroupID "
		"OR EMRGraphLineDetailsT.ColumnID = EMRDataT.EMRDataGroupID "
		"OR EMRGraphLineDetailsT.DateID = EMRDataT.EMRDataGroupID "
		"INNER JOIN EMRInfoT ON EMRInfoT.ID = EMRDataT.EMRInfoID "
		"WHERE EMRDataT.ID = {INT} ", nDataID);

	CString strList = "";
	//get the names of the graphs, lines, and items to return for the message.
	while (!prs->eof) {
		strList += FormatString("%s -> %s -> %s\r\n", AdoFldString(prs, "GraphName"), 
			AdoFldString(prs, "LineName"), AdoFldString(prs, "ItemName"));
		prs->MoveNext();
	}
	prs->Close();
	return strList;
}

// (a.wilson 2012-07-16 10:55) - PLID 49704 - check to see if the current item is attached to graphing setup. 
//return all the graphs with lines that have the item assigned to them.
CString CEmrItemEntryDlg::IsItemIDAssignedInGraphing(long nItemID)
{
	CString strList = "";

	if (nItemID != -1) {
		_RecordsetPtr prs = CreateParamRecordset (
			"SELECT EMRGraphsT.Name AS GraphName, EMRGraphLinesT.Name AS LineName FROM EMRGraphsT "
			"INNER JOIN EMRGraphLinesT ON EMRGraphsT.ID = EMRGraphLinesT.GraphID "
			"INNER JOIN EMRGraphLineDetailsT ON EMRGraphLinesT.ID = EMRGraphLineDetailsT.LineID "
			"WHERE EMRGraphLineDetailsT.EMRInfoMasterID = {INT}", nItemID);

		while (!prs->eof) {
			strList += FormatString("%s -> %s\r\n", AdoFldString(prs, "GraphName"), AdoFldString(prs, "LineName"));
			prs->MoveNext();
		}
		prs->Close();
	}
	return strList;
}

// (j.jones 2012-09-20 12:58) - PLID 52316 - will update the ParentLabelID column's
// dropdown list with all current labels
void CEmrItemEntryDlg::RecalculateAndApplyParentLabelComboSql()
{
	try {

		//if not a list item, do nothing
		if(!IsDlgButtonChecked(IDC_RADIO_LIST_SELECT) && !IsDlgButtonChecked(IDC_RADIO_LIST_MULTISELECT)) {
			return;
		}

		// (j.jones 2012-09-19 17:04) - PLID 52316 - add this label to the list of available parent labels
		NXDATALIST2Lib::IColumnSettingsPtr pParentLabelCol = m_pdlDataElementList->GetColumn(delcParentLabelID);
		if(pParentLabelCol == NULL) {
			//if the column doesn't exist, do nothing
			return;
		}

		//now build the combo source with all labels
		CString strComboSource = "SELECT 0 AS ID, ' <No Parent>' AS Name ";

		for(int i=0;i<m_aryCurDataElements.GetSize(); i++) {
			CEmrInfoDataElement *peide = m_aryCurDataElements.GetAt(i);
			if(peide != NULL && peide->m_bIsLabel && !peide->m_bInactive) {
				CString strNewEntry;
				strNewEntry.Format("UNION SELECT %li AS ID, '%s' AS Name ", (long)peide, _Q(peide->m_strData));
				strComboSource += strNewEntry;
			}
		}

		strComboSource += "ORDER BY Name";

		//always update the combo source
		pParentLabelCol->PutComboSource((LPCTSTR)strComboSource);

	}NxCatchAll(__FUNCTION__);
}

// (j.jones 2012-09-21 11:11) - PLID 52316 - given a pointer that was formerly a valid
// label, this function will find any rows using this label as its parent, and clear their parents
void CEmrItemEntryDlg::TryRemoveParentLabelReferences(CEmrInfoDataElement *peideLabelToRemove)
{
	try {

		//update our stored array
		for(int i=0;i<m_aryCurDataElements.GetSize(); i++) {
			CEmrInfoDataElement *peide = m_aryCurDataElements.GetAt(i);
			if(peide != NULL && peide->m_peideParentLabelPtr == peideLabelToRemove) {
				//clear the parent
				peide->m_peideParentLabelPtr = NULL;
				peide->m_nParentLabelID = -1;
			}
		}

		//update the datalist
		NXDATALIST2Lib::IRowSettingsPtr pRow = m_pdlDataElementList->GetFirstRow();
		while(pRow) {
			long nParentLabelPtr = VarLong(pRow->GetValue(delcParentLabelID), 0);
			if(nParentLabelPtr != 0) {
				CEmrInfoDataElement *peideParent = (CEmrInfoDataElement*)nParentLabelPtr;
				if(peideParent == peideLabelToRemove) {
					//clear the parent
					pRow->PutValue(delcParentLabelID, (long)0);
				}
			}

			pRow = pRow->GetNextRow();
		}

	}NxCatchAll(__FUNCTION__);
}

// (d.thompson 2012-10-15) - PLID 53184 - This version is called for single select lists, multi select lists, and table rows
void CEmrItemEntryDlg::OnPasteSetupData()
{
	try {
		PasteSetupData(FALSE);
	} NxCatchAll(__FUNCTION__);
}

// (d.thompson 2012-10-16) - PLID 53184 - This version is called only on table columns
void CEmrItemEntryDlg::OnPasteSetupDataColumns()
{
	try {
		PasteSetupData(TRUE);
	} NxCatchAll(__FUNCTION__);
}

// (d.thompson 2012-10-16) - PLID 53184 - Paste data from the clipboard into a datalist.  Use
//	FALSE for single select, multi select, and table rows.  Use TRUE for table columns.
void CEmrItemEntryDlg::PasteSetupData(BOOL bInTableColumns)
{
	//Give them a warning, as the icon may be a touch unclear, and if they just click it at random, who knows what may result.
	int nResult = DontShowMeAgain(this, "This button will paste the current contents of your clipboard into the item list.  Each item should be separated by a newline.\r\n\r\nDo you wish to paste now?", 
		"EMRItemEntryPasteWarning", "Warning", FALSE, TRUE);

	//For some reason, "don't show me again" forces it to forever return IDOK.  So treat that as approval.
	if(nResult != IDYES && nResult != IDOK) {
		return;
	}

	CClipboardToStringArray data(cpoAll);

	for(int i = 0; i < data.m_aryItems.GetSize(); i++) {
		CString strData = data.m_aryItems.GetAt(i);
		AddDataElement(strData, bInTableColumns);
	}
}

// (j.gruber 2013-09-30 10:55) - PLID 58676
void CEmrItemEntryDlg::OnBnClickedBtnEditTableCellCodes()
{
	try {
		if(!AtLeastOneActiveRowAndColumn()) {
			return;
		}	

		//make sure our indices have been set
		if (m_TableCellCodes.size() == 0 && m_SavedCellCodes.size() == 0) {
			UpdateVisibleIndices(TRUE);
		}
				
		// (j.jones 2011-07-08 13:18) - PLID 43032 - now we pass in m_DataSubType
		CEMREditTableCellCodeDlg dlg(m_aryCurDataElements, m_aryCurColumnDataElements, this, m_DataSubType, &m_TableCellCodes);
		// (c.haag 2008-10-23 15:02) - PLID 31735 - The dialog needs to know whether the table is flipped
		dlg.m_bTableRowsAsFields = IsDlgButtonChecked(IDC_TABLE_ROWS_AS_FIELDS) ? TRUE : FALSE;
		
		//we don't have to do anything since we sent in our array and the dialog saved to it.
		dlg.DoModal();		
		
	}NxCatchAll(__FUNCTION__);
}



// (j.gruber 2013-10-21 09:11) - PLID 59101 - needed for column codes
void CEmrItemEntryDlg::LeftClickEmrColumnList(LPDISPATCH lpRow, short nCol, long x, long y, long nFlags)
{
	try{
		NXDATALIST2Lib::IRowSettingsPtr pRow(lpRow);

		if (pRow) {
			// (j.gruber 2013-10-02 11:53) - PLID 58674 - codes
			if (nCol == cdelcCodes)
			{
				CEmrInfoDataElement *peide = m_aryCurColumnDataElements.GetAt(GetCurDataElementArrayIndex(VarLong(pRow->GetValue(cdelcSortOrder)), TRUE));

				CEMRCodeArray aryOrig;
				aryOrig = peide->m_aryCodes;
				CEMRCodeArray pTmp;
				pTmp = peide->m_aryCodes;
				CEMRCodeEditorDlg dlgCodes(&pTmp);

				if (dlgCodes.DoModal() == IDOK) 
				{
					//did our code array change
					if (aryOrig.IsDifferent(&pTmp)) 
					{
						//remove our current array values
						peide->m_aryCodes.RemoveAll();
						//add the new codes
						peide->m_aryCodes = pTmp;						
					}

					//update the link
					pRow->PutValue(cdelcCodes, (LPCTSTR)("<" + AsString((long)peide->m_aryCodes.GetSize()) + " code(s)>"));

				}
			}	
		}
	}NxCatchAll(__FUNCTION__);
}


// (j.gruber 2014-07-21 13:40) - PLID 62625 - KeywordOverride Handler
// (j.gruber 2014-07-28 11:44) - PLID 62630 - Changed to take row instead
void CEmrItemEntryDlg::OnKeywordOverride(NXDATALIST2Lib::IRowSettingsPtr pRow, BOOL bUseColumnList)
{
	try {
				
		CEmrInfoDataElement *peide = NULL;
		if (!bUseColumnList)
		{
			peide = m_aryCurDataElements.GetAt(GetCurDataElementArrayIndex(VarLong(pRow->GetValue(delcSortOrder)), bUseColumnList));
		}
		else {			
			peide = m_aryCurColumnDataElements.GetAt(GetCurDataElementArrayIndex(VarLong(pRow->GetValue(cdelcSortOrder)), bUseColumnList));
		}
		

		CString strResult = peide->m_strKeywordOverride;
		CString strResultOrig = strResult;
		if (InputBoxLimited(this, "Edit Search Keywords", strResult, "", 150, false, false, "Cancel"))
		{
			//set the varible back to what it was
			if (strResultOrig != strResult)
			{
				peide->m_strKeywordOverride = strResult;
			}

			// (j.gruber 2014-07-28 11:44) - PLID 62630 - Color the row
			if (!peide->m_strKeywordOverride.IsEmpty())
			{
				if (!bUseColumnList)
				{
					pRow->PutCellBackColor(delcUseKeyWord, HAS_KEYWORD_OVERRIDE_COLOR);
				}
				else {
					pRow->PutCellBackColor(cdelcUseKeyword, HAS_KEYWORD_OVERRIDE_COLOR);
				}
			}
			else
			{
				if (!bUseColumnList)
				{
					pRow->PutCellBackColor(delcUseKeyWord, HAS_NO_KEYWORD_OVERRIDE_COLOR);
				}
				else {
					pRow->PutCellBackColor(cdelcUseKeyword, HAS_NO_KEYWORD_OVERRIDE_COLOR);
				}
			}

		}
	}NxCatchAll(__FUNCTION__);

}

// (j.gruber 2014-07-25 13:54) - PLID 62629 - Just checks if any columns have a checkbox type
BOOL CEmrItemEntryDlg::HasCheckAllType()
{

	for (int i = 0; i < m_aryCurColumnDataElements.GetSize(); i++) {
		CEmrInfoDataElement *peide = m_aryCurColumnDataElements.GetAt(i);

		if (peide->m_nListType != LIST_TYPE_LINKED)
		{
			return TRUE;
		}
	}

	return FALSE;

}

// (j.gruber 2014-08-05 09:34) - PLID 62629 - made a function for this
void CEmrItemEntryDlg::Check_UncheckAllKeywords(BOOL bCheck, BOOL bIsColumnList)
{
	NXDATALIST2Lib::IRowSettingsPtr pRowCheck = NULL;
	if (bIsColumnList)
	{
		pRowCheck = m_pdlColumnDataElementList->GetFirstRow();
	}
	else {
		pRowCheck = m_pdlDataElementList->GetFirstRow();
	}

	while (pRowCheck)
	{

		CEmrInfoDataElement *peideCheck;

		if (bIsColumnList)
		{
			peideCheck = m_aryCurColumnDataElements.GetAt(GetCurDataElementArrayIndex(VarLong(pRowCheck->GetValue(cdelcSortOrder)), bIsColumnList));
		}
		else {
			peideCheck = m_aryCurDataElements.GetAt(GetCurDataElementArrayIndex(VarLong(pRowCheck->GetValue(delcSortOrder)), FALSE));
		}
		
		// (j.gruber 2014-07-25 13:41) - PLID 62629 - all of them can now have 
		if (peideCheck->m_nListType != LIST_TYPE_LINKED)
		{
			peideCheck->m_bUseKeyword = bCheck ? TRUE : FALSE;
			pRowCheck->PutValue(bIsColumnList ? cdelcUseKeyword : delcUseKeyWord, bCheck ? g_cvarTrue : g_cvarFalse);
			// (j.gruber 2014-09-15 13:31) - PLID 63188 - if you check the keyword column for a drop down and none of the underlying list elements are already checked, check them all.
			if (bIsColumnList && peideCheck->m_nListType == LIST_TYPE_DROPDOWN)
			{
				HandleKeywordDropDownContents(peideCheck, peideCheck->m_bUseKeyword);
			}
		}

		
		// (j.gruber 2014-08-05 09:34) - PLID 62629 When editing multi - select lists, single - select lists, tables, and table dropdowns, change the background of the Keyword checkbox cell to yellow for a visual indicator that an override is set.
		if (bCheck)
		{
			//is there a keyword override
			if (!peideCheck->m_strKeywordOverride.IsEmpty())
			{
				pRowCheck->PutCellBackColor(bIsColumnList ? cdelcUseKeyword : delcUseKeyWord, HAS_KEYWORD_OVERRIDE_COLOR);
			}
			else {
				pRowCheck->PutCellBackColor(bIsColumnList ? cdelcUseKeyword : delcUseKeyWord, HAS_NO_KEYWORD_OVERRIDE_COLOR);
			}
		}
		else {
			pRowCheck->PutCellBackColor(bIsColumnList ? cdelcUseKeyword : delcUseKeyWord, HAS_NO_KEYWORD_OVERRIDE_COLOR);
		}

		pRowCheck = pRowCheck->GetNextRow();
	}


}


// (j.gruber 2014-08-06 10:21) - PLID 63188 - this function just checks to see if the drop down list is all the opposite of what was checked
BOOL CEmrItemEntryDlg::CanDropDownListBeChanged(CEmrInfoDataElement *pElement, BOOL bChecked)
{

	for (auto& pddi : pElement->m_arypEMRDropDownList) {
		if (pddi->bUseKeyword == bChecked)
		{
			return FALSE;
		}
	}

	return TRUE;

}

// (j.gruber 2014-08-06 10:21) - PLID 63188 - if you check the keyword column for a drop down and none of the underlying list elements are already checked, check them all.  
void CEmrItemEntryDlg::HandleKeywordDropDownContents(CEmrInfoDataElement *pElement, BOOL bChecked)
{

	//first we need to find out if all our drop down elements are opposite of our checked status
	if (CanDropDownListBeChanged(pElement, bChecked))
	{
		//lets change it
		for (auto& pddi : pElement->m_arypEMRDropDownList) {
			pddi->bUseKeyword = bChecked;
		}
	}
}

// (c.haag 2015-07-07) - PLID 65572 - Audits all the EMR problem actions for this EMR item. Only used when the item is being created.
void CEmrItemEntryDlg::AuditNewItemEmrProblemActions(long& nAuditTransactionID, const CString& strName)
{
	// Audit all EMR problem actions contained among all of the list options
	for (const auto* peide : m_aryCurDataElements)
	{
		for (const auto& ea : peide->m_arActions)
		{
			AuditNewItemEmrProblemActions(nAuditTransactionID, strName, peide, NULL, ea);
		}
	}

	// Audit all EMR problem actions contained among all table column dropdowns
	for (const auto* peide : m_aryCurColumnDataElements)
	{
		for (const auto& pDDI : peide->m_arypEMRDropDownList)
		{
			for (const auto& ea : pDDI->aryActions)
			{
				AuditNewItemEmrProblemActions(nAuditTransactionID, strName, peide, pDDI.get(), ea);
			}
		}
	}

	// Audit all EMR problem actions at the EMR item level
	for (const auto& ea : m_arCurActions)
	{
		AuditNewItemEmrProblemActions(nAuditTransactionID, strName, NULL, NULL, ea);
	}

	// Audit all EMR problem hotspot actions
	for (auto* ph : m_aryNewHotSpots)
	{
		for (const auto& ea : *ph->GetCurrentActionArray())
		{
			AuditNewItemEmrProblemActions(nAuditTransactionID, strName, NULL, NULL, ea);
		}
	}
}

// (c.haag 2015-07-07) - PLID 65572 - Audits all the EMR problem actions for a single EMR action. Only used when the item is being created.
void CEmrItemEntryDlg::AuditNewItemEmrProblemActions(long& nAuditTransactionID, const CString& strName,
	const CEmrInfoDataElement* peideSourceEmrDataItem, const CEmrTableDropDownItem* pddiSourceTableDropdownItem,
	const EmrAction& ea)
{
	CString strSourceTypeText = GetAuditSourceTypeText(ea.eaoSourceType, "", peideSourceEmrDataItem, pddiSourceTableDropdownItem);
	CString strDestTypeText = GetAuditDestTypeText(ea.eaoDestType, ea.nDestID);
	CString strAction = CString("Spawning of ") + strDestTypeText + " for the " + strSourceTypeText;

	for (const auto& epa : ea.aProblemActions)
	{
		CString strOldValue = "Item: " + strName + ".   Action: " + strAction + ".";
		CString strNewValue = GetProblemActionAuditString(ea, epa);
		if (nAuditTransactionID == -1) nAuditTransactionID = BeginAuditTransaction();
		AuditEvent(-1, "", nAuditTransactionID, aeiEMRProblemActionCreated, m_nID, strOldValue, strNewValue, aepLow, aetCreated);
	}
}